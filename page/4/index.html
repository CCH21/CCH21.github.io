<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    

    <!--Author-->
    
        <meta name="author" content="John Doe">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Welcome to CCH21&#39;s Blog"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="Welcome to CCH21&#39;s Blog"/>

    <!--Type page-->
    
        <meta property="og:type" content="website" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>page - Welcome to CCH21&#39;s Blog</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about.html">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact.html">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
            <h1 id="main-title" class="title">Welcome to CCH21's Blog</h1>
        
    </div>
</header>

        <section class="main">
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/01/20/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E4%B9%8BCSV%E6%96%87%E4%BB%B6(3)/">
                Python数据分析基础之CSV文件(3)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-01-20</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <p>&emsp;&emsp;这一节主要讲一下在读写CSV文件时筛选特定的行。<br>&emsp;&emsp;有些时候，我们并不需要文件中所有的数据。例如，我们可能只需要一个包含特定词或数字的行的子集，或者是与某个具体日期关联的行的子集。在这些情况下，我们可以用Python筛选出特定的行来使用。<br>&emsp;&emsp;下面主要来讲在输入文件中筛选出特定行的3种方法：<br>&emsp;&emsp;1.行中的值满足某个条件；<br>&emsp;&emsp;2.行中的值属于某个集合；<br>&emsp;&emsp;3.行中的值匹配于某个模式（正则表达式）。<br>&emsp;&emsp;其实，这三种筛选方法的代码在结构上是一致的。通用结构如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for row in filereader:</span><br><span class="line">    ***if value in row meets some business rule or set of rules:***</span><br><span class="line">        do something</span><br><span class="line">    else:</span><br><span class="line">        do something else</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;下面我们来详细讨论一下上述3种方法。  </p>
<h2 id="行中的值满足某个条件"><a href="#行中的值满足某个条件" class="headerlink" title="行中的值满足某个条件"></a>行中的值满足某个条件</h2><h4 id="1-基础Python"><a href="#1-基础Python" class="headerlink" title="1.基础Python"></a>1.基础Python</h4><p>&emsp;&emsp;在之前的样例中，如果我们只想保留供应商名字为Supplier Z或成本大于$600.00的行，并将结果写入输出文件。代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import csv</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">with open(input_file, &apos;r&apos;, newline=&apos;&apos;) as csv_in_file:</span><br><span class="line">    with open(output_file, &apos;w&apos;, newline=&apos;&apos;) as csv_out_file:</span><br><span class="line">        filereader = csv.reader(csv_in_file)</span><br><span class="line">        filewriter = csv.writer(csv_out_file)</span><br><span class="line">        header = next(filereader)</span><br><span class="line">        filewriter.writerow(header)</span><br><span class="line">        for row_list in filereader:</span><br><span class="line">            supplier = str(row_list[0]).strip()</span><br><span class="line">            cost = str(row_list[3]).strip(&apos;$&apos;).replace(&apos;,&apos;, &apos;&apos;)</span><br><span class="line">            if supplier == &apos;Supplier Z&apos; or float(cost) &gt; 600.0:</span><br><span class="line">                filewriter.writerow(row_list)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们来解释一下上面的代码。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">header = next(filereader)</span><br><span class="line">filewriter.writerow(header)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这两行代码使用csv模块的<code>next()</code>函数读出输入文件的第一行，赋给列表变量<code>header</code>，并且使用<code>writerow()</code>函数将标题行写入输出文件。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supplier = str(row_list[0]).strip()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这行代码取出每行数据中的供应商名字，赋给变量<code>supplier</code>。这行代码使用列表索引取出每行数据的第一个值<code>row[0]</code>，使用<code>str()</code>函数将其转换为一个字符串，再使用<code>strip()</code>函数删除字符串两端的空格、制表符和换行符。最后，将处理好的字符串赋给变量<code>supplier</code>。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cost = str(row_list[3]).strip(&apos;$&apos;).replace(&apos;,&apos;, &apos;&apos;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这行代码取出每行数据中的成本，赋给变量<code>cost</code>。这行代码使用列表索引取出每行数据的第四个值<code>row[3]</code>，使用<code>str()</code>函数将其转换为一个字符串，再使用<code>strip(&#39;$&#39;)</code>函数从字符串中删除<code>$</code>符号，再使用<code>replace()</code>函数从字符串中删除逗号。最后，将处理好的字符串赋给变量<code>cost</code>。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if supplier == &apos;Supplier Z&apos; or float(cost) &gt; 600.0:</span><br><span class="line">    filewriter.writerow(row_list)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这两行代码通过创建<code>if</code>语句来检验每行中的这两个值是否满足条件，若条件满足，则使用<code>filewriter</code>的<code>writerow()</code>函数将其写入输出文件。<br>&emsp;&emsp;我们在命令行窗口运行这个脚本。在窗口中没有任何输出，我们可以打开输出文件来查看结果。<br><img src="https://img-blog.csdnimg.cn/20200120205540611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="2-pandas"><a href="#2-pandas" class="headerlink" title="2.pandas"></a>2.pandas</h4><p>&emsp;&emsp;pandas模块提供了一个<code>loc</code>函数，它可以同时选择特定的行与列。使用pandas模块的代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import pandas as pd</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">data_frame = pd.read_csv(input_file)</span><br><span class="line">data_frame[&apos;Cost&apos;] = data_frame[&apos;Cost&apos;].str.strip(&apos;$&apos;).astype(float)</span><br><span class="line">data_frame_value_meets_condition = data_frame.loc[(data_frame[&apos;Supplier Name&apos;].str.contains(&apos;Z&apos;))</span><br><span class="line">                                                  | (data_frame[&apos;Cost&apos;] &gt; 600.0), :]</span><br><span class="line">data_frame_value_meets_condition.to_csv(output_file, index=False)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们在命令行窗口运行这个脚本，同样地，在屏幕上我们看不到任何输出，我们可以打开输出文件查看结果。<br>&emsp;&emsp;此处省略输出结果。  </p>
<h2 id="行中的值属于某个集合"><a href="#行中的值属于某个集合" class="headerlink" title="行中的值属于某个集合"></a>行中的值属于某个集合</h2><p>&emsp;&emsp;有些时候，当行中的值属于某个集合时，才需要保留这些行。例如，我们希望在数据集中保留那些供应商名字属于集合<code>{Supplier X, Supplier Y}</code>的行，或者希望保留所有购买日期属于集合<code>{&#39;1/20/2014&#39;, &#39;1/30/2014&#39;}</code>的行。在这种情况下，我们可以检验行中的值是否属于某个集合，筛选出具有属于该集合的行。  </p>
<h4 id="1-基础Python-1"><a href="#1-基础Python-1" class="headerlink" title="1.基础Python"></a>1.基础Python</h4><p>&emsp;&emsp;代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import csv</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">important_dates = [&apos;1/20/2014&apos;, &apos;1/30/2014&apos;]</span><br><span class="line">with open(input_file, &apos;r&apos;, newline=&apos;&apos;) as csv_in_file:</span><br><span class="line">    with open(output_file, &apos;w&apos;, newline=&apos;&apos;) as csv_out_file:</span><br><span class="line">        filereader = csv.reader(csv_in_file)</span><br><span class="line">        filewriter = csv.writer(csv_out_file)</span><br><span class="line">        header = next(filereader)</span><br><span class="line">        filewriter.writerow(header)</span><br><span class="line">        for row_list in filereader:</span><br><span class="line">            a_date = row_list[4]</span><br><span class="line">            if a_date in important_dates:</span><br><span class="line">                filewriter.writerow(row_list)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们来讨论一下上述代码。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">important_dates = [&apos;1/20/2014&apos;, &apos;1/30/2014&apos;]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这行代码创建了一个名为<code>important_dates</code>的列表变量，其中包含了两个特定日期。这个列表变量就是我们的集合。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a_date = row_list[4]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这行代码取出每一行的购买日期，并赋给变量<code>a_date</code>。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if a_date in important_dates:</span><br><span class="line">    filewriter.writerow(row_list)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这行代码创建了一个<code>if</code>语句来检验变量<code>a_date</code>中的购买日期是否属于集合<code>important_date</code>，如果变量值在集合中，下一行代码就将这一行写入输出文件。<br>&emsp;&emsp;我们在命令行窗口中运行这个脚本，并打开输出文件来查看结果。<br><img src="https://img-blog.csdnimg.cn/20200120211035351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="2-pandas-1"><a href="#2-pandas-1" class="headerlink" title="2.pandas"></a>2.pandas</h4><p>&emsp;&emsp;使用pandas模块的代码如下所示：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import pandas as pd</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">data_frame = pd.read_csv(input_file)</span><br><span class="line">important_dates = [&apos;1/20/2014&apos;, &apos;1/30/2014&apos;]</span><br><span class="line">data_frame_value_in_set = data_frame.loc[data_frame[&apos;Purchase Date&apos;].isin(important_dates), :]</span><br><span class="line">data_frame_value_in_set.to_csv(output_file, index=False)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里的输出结果和上面基础Python方法的输出结果一致，故省略。  </p>
<h2 id="行中的值匹配于某个模式（正则表达式）"><a href="#行中的值匹配于某个模式（正则表达式）" class="headerlink" title="行中的值匹配于某个模式（正则表达式）"></a>行中的值匹配于某个模式（正则表达式）</h2><p>&emsp;&emsp;有些时候，当行中的值匹配或包含一个特定模式（正则表达式）时，才需要保留这些行。例如，我们希望在数据集中保留所有发票开始于“001-”的行，或者希望保留所有供应商名字中包含“Y”的行。在这种情况下，我们可以检验行中的值是否匹配或包含某种模式，然后筛选出匹配或包含该模式的行。  </p>
<h4 id="1-基础Python-2"><a href="#1-基础Python-2" class="headerlink" title="1.基础Python"></a>1.基础Python</h4><p>&emsp;&emsp;代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import csv</span><br><span class="line">import re</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">pattern = re.compile(r&apos;(?P&lt;my_pattern_group&gt;^001-.*)&apos;, re.I)</span><br><span class="line">with open(input_file, &apos;r&apos;, newline=&apos;&apos;) as csv_in_file:</span><br><span class="line">    with open(output_file, &apos;w&apos;, newline=&apos;&apos;) as csv_out_file:</span><br><span class="line">        filereader = csv.reader(csv_in_file)</span><br><span class="line">        filewriter = csv.writer(csv_out_file)</span><br><span class="line">        header = next(filereader)</span><br><span class="line">        filewriter.writerow(header)</span><br><span class="line">        for row_list in filereader:</span><br><span class="line">            invoice_number = row_list[1]</span><br><span class="line">            if pattern.search(invoice_number):</span><br><span class="line">                filewriter.writerow(row_list)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们来讨论一下上述代码。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这一行代码导入了re模块，也就是正则表达式模块。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(r&apos;(?P&lt;my_pattern_group&gt;^001-.*)&apos;, re.I)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这行代码使用re模块的<code>compile()</code>函数创建变量<code>pattern</code>。其中<code>r</code>表示将单引号之间的模式当作原始字符串来处理。元字符<code>?P&lt;my_pattern_group&gt;</code>捕获了名为<code>&lt;my_pattern_group&gt;</code>的组中匹配了的字符串，以便在需要的时候将它们打印到屏幕或写入文件。这里要搜索的实际模式是<code>^001-.*</code>。插入符号<code>^</code>表示只在字符串开头搜索模式，<code>*</code>表示重复前面的字符0次或更多次，<code>.*</code>组合在一起使用表示除换行符<code>\n</code>之外的任意字符可以在“001-”后面出现任意次。最后，参数<code>re.I</code>告诉了正则表达式进行大小写敏感的匹配。<br>&emsp;&emsp;有关正则表达式的内容，可以参考我之前写的博客：<a href="https://blog.csdn.net/qq_45554010/article/details/104022260" target="_blank" rel="noopener">Python与正则表达式</a>。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if pattern.search(invoice_number):</span><br><span class="line">    filewriter.writerow(row_list)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里使用re模块的<code>search()</code>函数在<code>invoice_number</code>的值中寻找模式，如果模式出现在变量值中，就将这行写入输出文件。<br>&emsp;&emsp;我们在命令行窗口运行这个脚本，得到输出文件如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200120212816274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="2-pandas-2"><a href="#2-pandas-2" class="headerlink" title="2.pandas"></a>2.pandas</h4><p>&emsp;&emsp;使用pandas模块的代码如下所示：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import pandas as pd</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">data_frame = pd.read_csv(input_file)</span><br><span class="line">data_frame_value_matches_pattern = data_frame.loc[data_frame[&apos;Invoice Number&apos;].str.startswith(&quot;001-&quot;), :]</span><br><span class="line">data_frame_value_matches_pattern.to_csv(output_file, index=False)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上述代码中，<code>startswith()</code>函数用来搜索数据，不用再使用正则表达式。<br>&emsp;&emsp;这里的输出结果和上面基础Python方法的输出结果一致，故省略。  </p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/01/19/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E4%B9%8BCSV%E6%96%87%E4%BB%B6(2)/">
                Python数据分析基础之CSV文件(2)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-01-19</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="基本字符串分析的失败"><a href="#基本字符串分析的失败" class="headerlink" title="基本字符串分析的失败"></a>基本字符串分析的失败</h2><p>&emsp;&emsp;在上一节我们讲了使用Python对CSV文件进行读写。事实上，当列中包含额外的逗号时，CSV分析会失败。<br>&emsp;&emsp;我们打开supplier_data.csv，将Cost列中的最后两个成本数量分别改为$6,015.00和$1,006,015.00，如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200119164515385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">&emsp;&emsp;之前的脚本是按照行中的逗号分析每行数据的，这会让脚本错误地拆分最后两行的数据，因为数据中有逗号。<br>&emsp;&emsp;有很多方法可以改进这个脚本中的代码，使它可以正确地处理包含逗号的数值。我们可以使用正则表达式，但为了不使脚本复杂化，我们可以使用Python内置的csv模块。这个模块可以方便灵活地处理复杂的CSV文件。  </p>
<h2 id="修改后的脚本读写CSV文件"><a href="#修改后的脚本读写CSV文件" class="headerlink" title="修改后的脚本读写CSV文件"></a>修改后的脚本读写CSV文件</h2><p>&emsp;&emsp;使用Python内置的csv模块处理CSV文件的一个优点是，这个模块就是被设计用于正确处理数据值中的嵌入逗号和其他复杂模式的，它可以识别出这些模式并正确地处理数据。<br>&emsp;&emsp;修改后的代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import csv</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">with open(input_file, &apos;r&apos;, newline=&apos;&apos;) as csv_in_file:</span><br><span class="line">    with open(output_file, &apos;w&apos;, newline=&apos;&apos;) as csv_out_file:</span><br><span class="line">        filereader = csv.reader(csv_in_file, delimiter=&apos;,&apos;)</span><br><span class="line">        filewriter = csv.writer(csv_out_file, delimiter=&apos;,&apos;)</span><br><span class="line">        for row_list in filereader:</span><br><span class="line">            print(row_list)</span><br><span class="line">            filewriter.writerow(row_list)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们来解释一下上面的代码。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import csv</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这行代码导入csv模块，以便可以使用其中的函数来分析输入文件，写入输入文件。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filereader = csv.reader(csv_in_file, delimiter=&apos;,&apos;)</span><br><span class="line">filewriter = csv.writer(csv_out_file, delimiter=&apos;,&apos;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这两行代码使用csv模块中的<code>reader()</code>函数和<code>writer()</code>函数分别创建了一个文件读取对象<code>filereader</code>和文件写入对象<code>filewriter</code>。这两个函数中的第二个参数<code>delimiter=&#39;,&#39;</code>是默认分隔符，如果输入文件和输出文件都是用逗号分隔的，就不需要指定这个参数。这里指定分隔符函数，是为了防备待处理的输入文件或要写入的输出文件具有不同的分隔符，例如分号<code>;</code>或制表符<code>\t</code>。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filewriter.writerow(row_list)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这行代码使用<code>filewriter</code>对象的<code>writerow()</code>函数来将每行中的列表值写入输出文件。<br>&emsp;&emsp;我们在命令行窗口运行这个脚本，如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200119170337420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200119170405927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/01/19/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E4%B9%8BCSV%E6%96%87%E4%BB%B6(1)/">
                Python数据分析基础之CSV文件(1)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-01-19</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <blockquote>
<p>参考资料：<br>《Python数据分析基础》，作者[美]Clinton W. Brownley，译者陈光欣，中国工信出版集团，人民邮电出版社</p>
</blockquote>
<h2 id="CSV文件简述"><a href="#CSV文件简述" class="headerlink" title="CSV文件简述"></a>CSV文件简述</h2><p>&emsp;&emsp;CSV（comma-separated value，逗号分隔值）文件格式是一种非常简单的<strong>数据存储与分享</strong>方式。CSV文件将数据表格存储为纯文本，表格（或电子表格）中的每个单元格都是一个数值或字符串。与Excel文件相比，CSV文件的一个主要优点是<strong>有很多程序可以存储、转换和处理纯文本文件</strong>；相比之下，能够处理Excel文件的程序却不多。<br>&emsp;&emsp;当我们使用CSV文件时，确实会失去某些Excel功能：在Excel电子表格中，每个单元格都有一个定义好的“类型”，<strong>CSV文件中的单元格则只是原始数据</strong>。使用CSV文件的另一个问题是<strong>它只能保存数据而不能保存公式</strong>。  </p>
<h2 id="CSV文件初体验"><a href="#CSV文件初体验" class="headerlink" title="CSV文件初体验"></a>CSV文件初体验</h2><p>&emsp;&emsp;我们打开一个电子表格，向其中加入数据，如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200119001909232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">&emsp;&emsp;把文件保存在合适的位置。我们用记事本来打开这个文件，如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200119002141811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">&emsp;&emsp;可以看到，supplier_data.csv确实是纯文本文件。  </p>
<h2 id="用Python读写CSV文件"><a href="#用Python读写CSV文件" class="headerlink" title="用Python读写CSV文件"></a>用Python读写CSV文件</h2><h4 id="1-基础Python，不使用csv模块"><a href="#1-基础Python，不使用csv模块" class="headerlink" title="1.基础Python，不使用csv模块"></a>1.基础Python，不使用csv模块</h4><p>&emsp;&emsp;我们新建一个Python脚本，命名为<code>1csv_read_with_simple_parsing_and_write.py</code>。输入以下代码：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">with open(input_file, &apos;r&apos;, newline=&apos;&apos;) as filereader:</span><br><span class="line">    with open(output_file, &apos;w&apos;, newline=&apos;&apos;) as filewriter:</span><br><span class="line">        header = filereader.readline()</span><br><span class="line">        header = header.strip()</span><br><span class="line">        header_list = header.split(&apos;,&apos;)</span><br><span class="line">        print(header_list)</span><br><span class="line">        filewriter.write(&apos;,&apos;.join(map(str, header_list)) + &apos;\n&apos;)</span><br><span class="line">        for row in filereader:</span><br><span class="line">            row = row.strip()</span><br><span class="line">            row_list = row.split(&apos;,&apos;)</span><br><span class="line">            print(row_list)</span><br><span class="line">            filewriter.write(&apos;,&apos;.join(map(str, row_list)) + &apos;\n&apos;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;下面我们来解释一下上面的代码。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这一行称为shebang行。在Python脚本中，我们应该一直把它作为第一行。以<code>#</code>开头的行为单行注释，在Windows系统中，计算机不读取也不执行这一行代码。但是，安装了Unix系统的计算机使用这一行来找到执行文件中代码的Python版本。加入这一行可以使脚本在不同操作系统的计算机之间具有可移植性。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这两行代码使用sys模块的argv参数，它是一个传递给Python脚本的命令行参数列表，也就是当你运行脚本时在命令行输入的内容。在argv这个特殊的列表中，第一个元素<code>argv[0]</code>用做脚本名称，<code>argv[1]</code>则用作CSV输入文件的路径和文件名，<code>argv[2]</code>用作CSV输出文件的路径和文件名。在上面的代码中，<code>argv[1]</code>和<code>argv[2]</code>被分别赋值给变量<code>input_file</code>和<code>output_file</code>。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(input_file, &apos;r&apos;, newline=&apos;&apos;) as filereader:</span><br><span class="line">    with open(output_file, &apos;w&apos;, newline=&apos;&apos;) as filewriter:</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里的<code>with</code>语句可以在语句结束时自动关闭文件对象。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">header = filereader.readline()</span><br><span class="line">header = header.strip()</span><br><span class="line">header_list = header.split(&apos;,&apos;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里使用了文件对象的<code>readline</code>方法读取输入文件中的第一行数据。第一行是标题行，读入后将其作为字符串赋给变量<code>header</code>。<code>strip()</code>去掉了<code>header</code>字符串两端的空格、制表符和换行符。接下来使用<code>split(&#39;,&#39;)</code>将字符串用逗号拆分成列表并赋给变量<code>header_list</code>，列表中的每个值都是一个列标题。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filewriter.write(&apos;,&apos;.join(map(str, header_list)) + &apos;\n&apos;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这行代码使用<code>filewriter</code>对象的<code>write()</code>方法将<code>header_list</code>中的每个值写入输出文件。<code>map()</code>函数将<code>str()</code>函数应用于<code>header_list</code>中的每个元素，确保每个元素都是字符串。<code>join()</code>函数在<code>header_list</code>中的每个值之间插入一个逗号，将这个列表转换为一个字符串。在此之后，在这个字符串最后添加一个换行符<code>\n</code>。<code>filewriter</code>对象将这个字符串写入输出文件，作为输出文件的第一行。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for row in filereader:</span><br><span class="line">    row = row.strip()</span><br><span class="line">    row_list = row.split(&apos;,&apos;)</span><br><span class="line">    print(row_list)</span><br><span class="line">    filewriter.write(&apos;,&apos;.join(map(str, row_list)) + &apos;\n&apos;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里创建了一个for循环，在输入文件剩余的各行中迭代。<code>strip()</code>除去每行字符串两端的空格、换行符和制表符。<code>split(&#39;,&#39;)</code>用逗号将字符串拆分成一个列表并赋给变量<code>row_list</code>，列表中的每个值都是这行中某一列的值。最后，将这些值打印到屏幕上并写入输出文件。<br>&emsp;&emsp;我们在命令行窗口运行这个脚本，如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200119082504658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">&emsp;&emsp;输入文件的所有行都被打印到了屏幕上，也被写入了输出文件。<br><img src="https://img-blog.csdnimg.cn/20200119082658257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="2-使用pandas模块"><a href="#2-使用pandas模块" class="headerlink" title="2.使用pandas模块"></a>2.使用pandas模块</h4><p>&emsp;&emsp;使用pandas模块处理CSV文件的代码如下所示：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line">data_frame = pd.read_csv(input_file)</span><br><span class="line">print(data_frame)</span><br><span class="line">data_frame.to_csv(output_file, index=False)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里我们创建了一个变量<code>data_frame</code>，这种数据方式叫做<strong>数据框</strong>。数据框中保留了“表格”这种组织方式，不需要使用列表套列表的方式来分析数据。数据框包含在pandas中，如果我们没有在脚本中导入pandas模块，就不能使用数据框。<br>&emsp;&emsp;在学习阶段，将这个变量命名为<code>data_frame</code>是可以的，但是以后，我们应该使用更有描述性的变量名。<br>&emsp;&emsp;我们在命令行窗口运行这个脚本，如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200119083552160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200119083641933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/01/17/Python%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">
                Python与正则表达式
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-01-17</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <blockquote>
<p>参考资料：<br>1.菜鸟教程-Python 3 正则表达式，网址：<a href="https://www.runoob.com/python3/python3-reg-expressions.html" target="_blank" rel="noopener">https://www.runoob.com/python3/python3-reg-expressions.html</a><br>2.《Python从小白到大牛》，作者关东升，清华大学出版社<br>3.《Python数据分析基础》，作者[美]Clinton W. Brownley，译者陈光欣，中国工信出版集团，人民邮电出版社</p>
</blockquote>
<h2 id="简述正则表达式"><a href="#简述正则表达式" class="headerlink" title="简述正则表达式"></a>简述正则表达式</h2><p>&emsp;&emsp;正则表达式（Regular Expression）是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。在Python中，正则表达式的应用非常广泛，如数据挖掘、数据分析、网络爬虫、输入有效性验证等。<br>&emsp;&emsp;re模块使Python拥有全部的正则表达式功能。我们使用下面的语句来导入该模块：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br></pre></td></tr></table></figure>
<h2 id="正则表达式字符串"><a href="#正则表达式字符串" class="headerlink" title="正则表达式字符串"></a>正则表达式字符串</h2><p>&emsp;&emsp;正则表达式字符串由普通字符和元字符组成。<br>&emsp;&emsp;普通字符是按照字符字面意义表示的字符。元字符是预先定义好的一些特殊字符，如<code>\w+</code>和<code>\.</code>都属于元字符。<br>&emsp;&emsp;下面是一些基本元字符：<br>字符|说明<br>——|——<br>\|转义符号<br>.|表示任意一个字符<br>+|表示重复一次或多次<br>*|表示重复零次或多次<br>?|表示重复零次或一次<br>||选择符号，表示“或”<br>{}|定义量词<br>[]|定义字符类<br>()|定义分组<br>^|表示取反，或匹配一行的开始<br>$|匹配一行的结束<br>&emsp;&emsp;上面提到了元字符<code>^</code>和<code>$</code>，它们可以匹配一行字符串的开始和结束。当以<code>^</code>开始时，要求一行字符串的开始位置匹配；当以<code>$</code>位置结束时，要求一行字符串的结束位置匹配。需要注意的是，正则表达式<code>\w+@qq\.com</code>和<code>^\w+@qq\.com$</code>是不同的。<br>&emsp;&emsp;定义字符类需要使用元字符<code>[]</code>。例如说我们想在输入的字符串中匹配Python或python，则可以使用正则表达式<code>[Pp]ython</code>。<br>&emsp;&emsp;在正则表达式中指定不想出现的字符，可以在字符类之前加<code>^</code>符号进行字符类取反。比如说，正则表达式<code>[^0123456789]</code>表示输入的字符串中出现非0~9数字即匹配，也就是出现在<code>[0123456789]</code>之外的任意字符即匹配。<br>&emsp;&emsp;上面所说的正则表达式<code>[^0123456789]</code>写起来非常麻烦。事实上，我们引入区间的概念之后，这种连续的字符可以使用区间来表示。区间使用连字符<code>-</code>表示。例如<code>[0123456789]</code>可以采用区间表示为<code>[0-9]</code>，<code>[^0123456789]</code>可以采用区间表示为<code>[^0-9]</code>。区间也可以表示连续的英文字母字符类，例如<code>[a-z]</code>表示所有小写字符类，<code>[A-Z]</code>表示所有大写字母字符类。除此之外，也可以表示多个不同区间，例如<code>[A-Za-z0-9]</code>表示所有字母和数字字符类，<code>[0-36-8]</code>表示0、1、2、3、6、7、8几个数字字符组成的字符类。<br>&emsp;&emsp;正则表达式提供了预定义字符类。预定义字符类如下表所示：<br>字符|说明<br>——|——<br>.|匹配任意一个字符<br>\\|匹配反斜杠\字符<br>\n|匹配换行符<br>\r|匹配回车符<br>\f|匹配一个换页符<br>\t|匹配一个水平制表符<br>\v|匹配一个垂直制表符<br>\s|匹配一个空格符（等价于[\t\n\r\f\v]）<br>\S|匹配一个非空格符（等价于[^\s]）<br>\d|匹配一个数字字符（等价于[0-9]）<br>\D|匹配一个非数字字符（等价于[^0-9]）<br>\w|匹配任何语言的单词字符（包括英文字母、亚洲文字等）、数字和下划线等字符，如果正则表达式编译标志设置为ASCII，则只匹配[a-zA-Z0-9_]<br>\W|等价于[^\w]</p>
<h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><p>&emsp;&emsp;在正则表达式中，元字符只能匹配显示一次字符或字符串。如果想要匹配显示多次字符或字符串，可以使用量词。<br>&emsp;&emsp;正则表达式中的量词如下表所示：<br>字符|说明<br>——|——<br>?|出现零次或一次<br>*|出现零次或多次<br>+|出现一次或多次<br>{n}|出现n次<br>{n,m}|至少出现n次但不超过m次<br>{n,}|至少出现n次<br>&emsp;&emsp;下面是一个量词的使用示例代码：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">m = re.search(r&apos;\d?&apos;, &apos;87654321&apos;)               # 出现数字一次</span><br><span class="line">print(m)                                        # 匹配字符&apos;8&apos;</span><br><span class="line"></span><br><span class="line">m = re.search(r&apos;\d?&apos;, &apos;ABC&apos;)                    # 出现数字零次</span><br><span class="line">print(m)                                        # 匹配字符&apos;&apos;</span><br><span class="line"></span><br><span class="line">m = re.search(r&apos;\d*&apos;, &apos;87654321&apos;)               # 出现数字多次</span><br><span class="line">print(m)                                        # 匹配字符&apos;87654321&apos;</span><br><span class="line"></span><br><span class="line">m = re.search(r&apos;\d*&apos;, &apos;ABC&apos;)                    # 出现数字零次</span><br><span class="line">print(m)                                        # 匹配字符&apos;&apos;</span><br><span class="line"></span><br><span class="line">m = re.search(r&apos;\d+&apos;, &apos;87654321&apos;)               # 出现数字多次</span><br><span class="line">print(m)                                        # 匹配字符&apos;87654321&apos;</span><br><span class="line"></span><br><span class="line">m = re.search(r&apos;\d+&apos;, &apos;ABC&apos;)</span><br><span class="line">print(m)                                        # 不匹配</span><br><span class="line"></span><br><span class="line">m = re.search(r&apos;\d&#123;8&#125;&apos;, &apos;87654321&apos;)             # 出现数字8次</span><br><span class="line">print(m)                                        # 匹配字符&apos;87654321&apos;</span><br><span class="line"></span><br><span class="line">m = re.search(r&apos;\d&#123;8&#125;&apos;, &apos;ABC&apos;)</span><br><span class="line">print(m)                                        # 不匹配</span><br><span class="line"></span><br><span class="line">m = re.search(r&apos;\d&#123;7,8&#125;&apos;, &apos;87654321&apos;)          # 出现数字8次</span><br><span class="line">print(m)                                        # 匹配字符&apos;87654321&apos;</span><br><span class="line"></span><br><span class="line">m = re.search(r&apos;\d&#123;9,&#125;&apos;, &apos;87654321&apos;)</span><br><span class="line">print(m)                                        # 不匹配</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;输出结果如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;re.Match object; span=(0, 1), match=&apos;8&apos;&gt;</span><br><span class="line">&lt;re.Match object; span=(0, 0), match=&apos;&apos;&gt;</span><br><span class="line">&lt;re.Match object; span=(0, 8), match=&apos;87654321&apos;&gt;</span><br><span class="line">&lt;re.Match object; span=(0, 0), match=&apos;&apos;&gt;</span><br><span class="line">&lt;re.Match object; span=(0, 8), match=&apos;87654321&apos;&gt;</span><br><span class="line">None</span><br><span class="line">&lt;re.Match object; span=(0, 8), match=&apos;87654321&apos;&gt;</span><br><span class="line">None</span><br><span class="line">&lt;re.Match object; span=(0, 8), match=&apos;87654321&apos;&gt;</span><br><span class="line">None</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;量词还可以细分为贪婪量词和懒惰量词。贪婪量词会尽可能多地匹配字符，懒惰量词会尽可能少地匹配字符。大多数计算机语言的正则表达式量词默认是贪婪量词，如果要使用懒惰量词，在量词之后加<code>?</code>即可。<br>&emsp;&emsp;下面是一个示例代码：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">m = re.search(r&apos;\d&#123;5,8&#125;&apos;, &apos;87654321&apos;)               # 出现数字8次</span><br><span class="line">print(m)                                            # 匹配字符&apos;87654321&apos;</span><br><span class="line"></span><br><span class="line">m = re.search(r&apos;\d&#123;5,8&#125;?&apos;, &apos;87654321&apos;)              # 出现数字5次</span><br><span class="line">print(m)                                            # 匹配字符&apos;87654&apos;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;输出结果如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;re.Match object; span=(0, 8), match=&apos;87654321&apos;&gt;</span><br><span class="line">&lt;re.Match object; span=(0, 5), match=&apos;87654&apos;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>&emsp;&emsp;量词只能重复显示一个字符，如果想让一个字符串作为整体使用量词，可以将这个字符串放到<code>()</code>中，这就是分组，也被称作子表达式。<br>&emsp;&emsp;下面是一个使用分组的示例代码：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">p = r&apos;(121)&#123;2&#125;&apos;</span><br><span class="line">m = re.search(p, &apos;121121abcabc&apos;)</span><br><span class="line">print(m)                                # 匹配</span><br><span class="line">print(m.group())                        # 返回匹配字符串</span><br><span class="line">print(m.group(1))                       # 获得第一组内容</span><br><span class="line">p = r&apos;(\d&#123;3,4&#125;)-(\d&#123;7,8&#125;)&apos;</span><br><span class="line">m = re.search(p, &apos;010-87654321&apos;)</span><br><span class="line">print(m)                                # 匹配</span><br><span class="line">print(m.group())                        # 返回匹配字符串</span><br><span class="line">print(m.groups())                       # 获得所有组内容</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;输出结果如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;re.Match object; span=(0, 6), match=&apos;121121&apos;&gt;</span><br><span class="line">121121</span><br><span class="line">121</span><br><span class="line">&lt;re.Match object; span=(0, 12), match=&apos;010-87654321&apos;&gt;</span><br><span class="line">010-87654321</span><br><span class="line">(&apos;010&apos;, &apos;87654321&apos;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在Python中访问分组时，除了可以通过组编号访问，还可以通过组名访问。这需要我们在正则表达式中为组命名。组命名通过在组开头添加<code>?P&lt;分组名&gt;</code>实现。<br>&emsp;&emsp;在正则表达式中，反向引用语法是<code>\组编号</code>。组编号从1开始。<br>&emsp;&emsp;前面所说的分组称为捕获分组。捕获分组的子表达式结果被暂时保存到内存中，以备表达式或其他程序通过组编号或组名进行引用。但是有时，我们并不想引用子表达式的匹配结果，不想捕获匹配结果，只是将小括号作为一个整体进行匹配。这个时候我们就可以使用非捕获分组。在组开头使用<code>?:</code>可以实现非捕获分组。  </p>
<h2 id="Python的re模块"><a href="#Python的re模块" class="headerlink" title="Python的re模块"></a>Python的re模块</h2><h4 id="re-search-函数"><a href="#re-search-函数" class="headerlink" title="re.search()函数"></a>re.search()函数</h4><p>&emsp;&emsp;re.search()函数在输入字符串中查找，返回第一个匹配内容，如果找到一个则match对象，如果没有找到则返回None。<br>&emsp;&emsp;函数语法如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.search(pattern, string, flags=0)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;参数说明如下：<br>参数|参数说明<br>——|——<br>pattern|匹配的正则表达式<br>string|要匹配的字符串<br>flags|标志位，用于控制正则表达式的匹配方式，如是否区分大小写，多行匹配等</p>
<h4 id="re-match-函数"><a href="#re-match-函数" class="headerlink" title="re.match()函数"></a>re.match()函数</h4><p>&emsp;&emsp;re.match()函数在输入字符串开始处查找匹配内容，如果找到一个则match对象，如果没有找到则返回None。<br>&emsp;&emsp;函数语法如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.match(pattern, string, flags=0)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;参数说明如下：<br>参数|参数说明<br>——|——<br>pattern|匹配的正则表达式<br>string|要匹配的字符串<br>flags|标志位，用于控制正则表达式的匹配方式，如是否区分大小写，多行匹配等<br>&emsp;&emsp;下面我们简单讨论一下re.search()和re.match()的区别。<br>&emsp;&emsp;re.match()只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；re.search()匹配整个字符串，直到找到一个匹配。<br>&emsp;&emsp;re.search()和re.match()如果匹配成功都返回match对象。下面是match对象的一些常用方法：<br>方法|返回值<br>——|——<br>group()|返回匹配的子字符串<br>start()|返回子字符串的开始索引<br>end()|返回子字符串的结束索引<br>span()|返回子字符串的跨度，它是一个二元素的元组</p>
<h4 id="re-findall-函数"><a href="#re-findall-函数" class="headerlink" title="re.findall()函数"></a>re.findall()函数</h4><p>&emsp;&emsp;re.findall()函数在输入字符串中查找所有匹配内容，如果匹配成功，则返回match列表对象，如果匹配失败则返回None。<br>&emsp;&emsp;函数语法如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.findall(string[, pos[, endpos]])</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;参数说明如下：<br>参数|参数说明<br>——|——<br>string|待匹配的字符串<br>pos|可选参数，指定字符串的起始位置，默认为0<br>endpos|可选参数，指定字符串的结束为止，默认为字符串的长度</p>
<h4 id="re-finditer-函数"><a href="#re-finditer-函数" class="headerlink" title="re.finditer()函数"></a>re.finditer()函数</h4><p>&emsp;&emsp;re.finditer()函数在输入字符串中查找所有匹配内容，如果匹配成功，则返回容纳match的可迭代对象，通过迭代对象每次可以返回一个match对象，如果匹配失败则返回None。<br>&emsp;&emsp;函数语法如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.finditer(pattern, string, flags=0)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;参数说明如下：<br>参数|参数说明<br>——|——<br>pattern|匹配的正则表达式<br>string|要匹配的字符串<br>flags|标志位，用于控制正则表达式的匹配方式，如是否区分大小写，多行匹配等</p>
<h4 id="re-split-函数"><a href="#re-split-函数" class="headerlink" title="re.split()函数"></a>re.split()函数</h4><p>&emsp;&emsp;re.split()函数按照匹配的字符串进行字符串分割，返回字符串列表对象。<br>&emsp;&emsp;函数语法如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.split(pattern, string[, maxsplit=0, flags=0])</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;参数说明如下：<br>参数|参数说明<br>——|——<br>pattern|匹配的正则表达式<br>string|要匹配的字符串<br>maxsplit|分割次数，默认为0，不限制次数<br>flags|标志位，用于控制正则表达式的匹配方式，如是否区分大小写，多行匹配等</p>
<h4 id="re-sub-函数"><a href="#re-sub-函数" class="headerlink" title="re.sub()函数"></a>re.sub()函数</h4><p>&emsp;&emsp;re.sub()函数用于替换匹配的子字符串，返回替换之后的字符串。<br>&emsp;&emsp;函数语法如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.sub(pattern, repl, string, count=0, flags=0)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;参数说明如下：<br>参数|参数说明<br>——|——<br>patern|正则中的模式字符串<br>repl|替换的字符串，也可为一个函数<br>string|要被查找替换的原始字符串<br>count|模式匹配后替换的最大次数，默认为0，表示替换所有的匹配<br>flags|编译时用的匹配模式，数字形式</p>
<h4 id="re-compile-函数"><a href="#re-compile-函数" class="headerlink" title="re.compile()函数"></a>re.compile()函数</h4><p>&emsp;&emsp;re.compile()函数可以编译正则表达式。<br>&emsp;&emsp;函数语法如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.compile(pattern[, flags=0])</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;参数说明如下：<br>参数|参数说明<br>——|——<br>pattern|一个字符串形式的正则表达式<br>flags|可选参数，表示匹配模式，如是否区分大小写，多行匹配等<br>&emsp;&emsp;re.compile()函数返回一个编译的正则表达式对象regex。  </p>
<h4 id="正则表达式修饰符"><a href="#正则表达式修饰符" class="headerlink" title="正则表达式修饰符"></a>正则表达式修饰符</h4><table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>re.I</td>
<td>使匹配对大小写不敏感</td>
</tr>
<tr>
<td>re.L</td>
<td>做本地化识别匹配</td>
</tr>
<tr>
<td>re.M</td>
<td>设置多行模式，多行匹配，影响^和$</td>
</tr>
<tr>
<td>re.S</td>
<td>使.匹配包括换行在内的所有字符</td>
</tr>
<tr>
<td>re.U</td>
<td>根据Unicode字符集解析字符，影响\w, \W, \b, \B</td>
</tr>
<tr>
<td>re.X</td>
<td>设置详细模式，详细模式下可以在正则表达式中添加注释， 可以有空格和换行</td>
</tr>
</tbody></table>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/12/24/%E3%80%90%E7%AE%97%E6%B3%95%E7%A7%AF%E7%B4%AF%E3%80%91%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/">
                【算法积累】最长公共前缀
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-12-24</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>&emsp;&emsp;注：本题来自LeetCode题库14.最长公共前缀。  </p>
<blockquote>
<p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”。</p>
</blockquote>
<p>&emsp;&emsp;示例1：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;示例2：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure>
<h2 id="解法1：字符串排序取首尾公共前缀"><a href="#解法1：字符串排序取首尾公共前缀" class="headerlink" title="解法1：字符串排序取首尾公共前缀"></a>解法1：字符串排序取首尾公共前缀</h2><p>&emsp;&emsp;简单来说，把字符串按字母顺序排序后，首字符串和尾字符串的公共前缀，就是这一组字符串的公共前缀。这种解法用C语言并不是很好实现。因为Python中内置函数min()和max()，在这里我使用Python 3来解决。代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 语言：Python 3</span><br><span class="line"># 执行用时：36ms</span><br><span class="line"># 内存消耗：12.8MB</span><br><span class="line">class Solution:</span><br><span class="line">    def longestCommonPrefix(self, strs: List[str]) -&gt; str:</span><br><span class="line">        if not strs:</span><br><span class="line">            return &quot;&quot;</span><br><span class="line">        strMin = min(strs)</span><br><span class="line">        strMax = max(strs)</span><br><span class="line">        string = []</span><br><span class="line">        for i in range(0, len(strMin)):</span><br><span class="line">            if strMin[i] == strMax[i]:</span><br><span class="line">                string.append(strMin[i])</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line">        return &quot;&quot;.join(string)</span><br></pre></td></tr></table></figure>
<h2 id="解法2：取最短字符串逐个比对"><a href="#解法2：取最短字符串逐个比对" class="headerlink" title="解法2：取最短字符串逐个比对"></a>解法2：取最短字符串逐个比对</h2><p>&emsp;&emsp;上面的解法依赖于Python的内置函数min()和max()。我们换一种思路，取出其中最短的字符串，用它和其他的字符串一一比对，找出公共前缀。<br>&emsp;&emsp;特殊地，如果输入的字符串数组长度为0，则只需返回空字符串“”；如果输入的字符串数组长度为1，则只需返回这个字符串，即strs[0]。<br>&emsp;&emsp;代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 语言：C</span><br><span class="line">// 执行用时：0ms</span><br><span class="line">// 内存消耗：7.1MB</span><br><span class="line">char * longestCommonPrefix(char ** strs, int strsSize)&#123;</span><br><span class="line">    int strLen = 0;</span><br><span class="line">    char *shortStr = NULL;</span><br><span class="line">    int shortLen = 0;</span><br><span class="line">    int i, j;</span><br><span class="line">    if (strs == NULL || strsSize == 0)</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    if (strs != NULL &amp;&amp; strsSize == 1)</span><br><span class="line">        return strs[0];</span><br><span class="line">    shortStr = strs[0];</span><br><span class="line">    shortLen = strlen(strs[0]);</span><br><span class="line">    for (i = 0; i &lt; strsSize; i++) &#123;</span><br><span class="line">        strLen = strlen(strs[i]);</span><br><span class="line">        if (shortLen &gt; strLen) &#123;</span><br><span class="line">            shortLen = strLen;</span><br><span class="line">            shortStr = strs[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (j = 0; j &lt; shortLen; j++) &#123;</span><br><span class="line">        for (i = 0; i &lt; strsSize; i++) &#123;</span><br><span class="line">            if (strs[i][j] != shortStr[j]) &#123;</span><br><span class="line">                if (j == 0) &#123;</span><br><span class="line">                    return &quot;&quot;;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    shortStr[j] = &apos;\0&apos;;</span><br><span class="line">                    return shortStr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return shortStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解法3：水平扫描法"><a href="#解法3：水平扫描法" class="headerlink" title="解法3：水平扫描法"></a>解法3：水平扫描法</h2><p>&emsp;&emsp;为了便于理解，我截取了LeetCode官方题解中水平扫描法的图解：<br><img src="https://img-blog.csdnimg.cn/20191224152137404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="Alt"><br>&emsp;&emsp;代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">语言：C</span><br><span class="line">执行用时：4ms</span><br><span class="line">内存消耗：7.1MB</span><br><span class="line">char * longestCommonPrefix(char ** strs, int strsSize)&#123;</span><br><span class="line">    int i, j;</span><br><span class="line">    if (strsSize == 0)</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    if (strsSize == 1)</span><br><span class="line">        return strs[0];</span><br><span class="line">    for (i = 0; i &lt; strlen(strs[0]); i++) &#123;</span><br><span class="line">        for (j = 1; j &lt; strsSize; j++)</span><br><span class="line">            if (strs[0][i] != strs[j][i]) &#123;</span><br><span class="line">                strs[0][i] = &apos;\0&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return strs[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解法4：使用Python的os-path模块"><a href="#解法4：使用Python的os-path模块" class="headerlink" title="解法4：使用Python的os.path模块"></a>解法4：使用Python的os.path模块</h2><p>&emsp;&emsp;最后放一个“大招”吧。正所谓“人生苦短，我用Python”，就在Python的os.path模块中，有一个叫做commonprefix()的方法，可以说是为这道题而生。<br>&emsp;&emsp;我们来对os.path.commonprefix()做一下说明。它可以返回list(多个路径)中所有path共有的最长的路径。怎么样，是不是完美适配这道题呢？<br>&emsp;&emsp;还是放一下代码吧，虽然只有短短一行：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 语言：Python 3</span><br><span class="line"># 执行用时：28ms</span><br><span class="line"># 内存消耗：12.7MB</span><br><span class="line">class Solution:</span><br><span class="line">    def longestCommonPrefix(self, strs: List[str]) -&gt; str:</span><br><span class="line">        return os.path.commonprefix(strs)</span><br></pre></td></tr></table></figure>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/12/22/Python%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93/">
                Python编码规范总结
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-12-22</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;有句俗话说得好：“没有规矩，不成方圆。”这句话在计算机编程领域同样适用。大家都知道，每个人编写代码的习惯与风格是不一样的。而代码风格的统一可以带来很多好处，我认为从最直观的角度来说就是增强了代码的可读性。此外，统一代码风格还有更容易发现bug、略微提高性能等好处。<br>&emsp;&emsp;之前曾经读过一篇文章，里面提到这样一句话：“任何一个傻瓜都能写出计算机可以理解的代码，唯有写出人类容易理解的代码，才是优秀的程序员。”这句话对我的影响很深。我是一名大一本科在读学生，在平时的学习中不乏和同学互相讨论研究代码。我说过最多的一句话大概就是：“你这个代码写得太不规范了。”但是从来没有任何一个同学重视这句话，他们甚至会不屑一顾地回复我：“无所谓，又不是不能运行。”<br>&emsp;&emsp;但我认为，在系统学习一门编程语言之前，首先应该学习编码规范，从开始就养成一个良好的习惯，对于以后的学习来说也是有百利而无一害。只有这样，我们才可以编写出可读性高，无论自己和他人都易于理解的代码。  </p>
<h1 id="Python编码规范"><a href="#Python编码规范" class="headerlink" title="Python编码规范"></a>Python编码规范</h1><blockquote>
<p>参考书籍：《Python从小白到大牛》<br>作者：关东升<br>出版社：清华大学出版社<br>ISBN：978-7-302-50933-2<br>除此之外，我还参考了PEP 8编码规范。  </p>
</blockquote>
<h3 id="1-命名规范"><a href="#1-命名规范" class="headerlink" title="1.命名规范"></a>1.命名规范</h3><p>&emsp;&emsp;1.包名：全部小写字母，中间可以由点分隔开，不推荐使用下划线。作为命名空间，包名应该具有唯一性，推荐采用公司或组织域名的倒置。<br>&emsp;&emsp;2.模块名：全部小写字母，如果由多个单词构成，可以用下划线隔开。<br>&emsp;&emsp;3.类名：采用大驼峰法（即每一个单词的首字母都大写）命名。<br>&emsp;&emsp;4.异常名：异常属于类，命名同类命名，但应该使用Error作为后缀。<br>&emsp;&emsp;5.变量名：全部小写字母，如果由多个单词构成，可以用下划线隔开。如果变量应用于模块或函数内部，则变量名可以由单下划线开头；变量类内部私有使用变量名可以双下划线开头。不要命名双下划线开头和结尾的变量，这是Python保留的。另外，避免使用小写L、大写O和大写I作为变量名。<br>&emsp;&emsp;6.函数名和方法名：命名同变量命名。<br>&emsp;&emsp;7.常量名：全部大写字母，如果由多个单词构成，可以用下划线隔开。  </p>
<h3 id="2-注释规范"><a href="#2-注释规范" class="headerlink" title="2.注释规范"></a>2.注释规范</h3><p>&emsp;&emsp;Python中的注释语法有3种，分别是单行注释、多行注释和文档注释。  </p>
<h5 id="2-1-文件注释"><a href="#2-1-文件注释" class="headerlink" title="2.1  文件注释"></a>2.1  文件注释</h5><p>&emsp;&emsp;文件注释就是在每一个文件开头添加注释，采用多行注释。文件注释通常包括如下信息：版权信息、文件名、所在模块、作者信息、历史版本信息、文件内容和作用等。<br>&emsp;&emsp;文件注释要根据实际情况包括内容。  </p>
<h5 id="2-2-文档注释"><a href="#2-2-文档注释" class="headerlink" title="2.2  文档注释"></a>2.2  文档注释</h5><p>&emsp;&emsp;文档注释就是文档字符串，注释内容能够生成API帮助文档，可以使用Python官方提供的pydoc工具从Python源代码文件中提取这些信息，也可以生成HTML文件。所有公有的模块、函数、类和方法都应该进行文档注释。<br>&emsp;&emsp;文档注释推荐使用一对三重双引号“””””包裹起来，注意不推荐使用三重单引号“’’’”。文档注释应该位于被注释的模块、函数、类和方法内部的第一条语句。如果文档注释一行能够注释完成，结束的三重双引号也在同一行。如果文档注释很长，第一行注释之后要留一个空行，然后剩下的注释内容换行要与开始三重双引号对齐，最后结束的三重双引号要独占一行，并与开始三重双引号对齐。  </p>
<h5 id="2-3-代码注释"><a href="#2-3-代码注释" class="headerlink" title="2.3  代码注释"></a>2.3  代码注释</h5><p>&emsp;&emsp;程序代码中处理文档注释时还需要在一些关键的地方添加代码注释，文档注释一般是给一些看不到源代码的人看的帮助文档，而代码注释是给阅读源代码的人参考的。代码注释一般采用单行注释和多行注释。<br>&emsp;&emsp;单行注释和多行注释要求与其后的代码具有一样的缩进级别。尾端进行注释要求注释内容极短，应该再有足够的空白（至少两个空格）来分开代码和注释。  </p>
<h5 id="2-4-使用TODO注释"><a href="#2-4-使用TODO注释" class="headerlink" title="2.4  使用TODO注释"></a>2.4  使用TODO注释</h5><p>&emsp;&emsp;很多IDE工具都为源代码提供了一些特殊的注释，就是在代码中加一些标识，便于IDE工具快速定位代码，TODO注释就是其中的一种。<br>&emsp;&emsp;TODO注释虽然不是Python官方所提供的，但是主流的IDE工具也都支持TODO注释。有TODO注释说明此处有待处理的任务，或代码没有编写完成。<br>&emsp;&emsp;以PyCharm为例，TODO注释可以在PyCharm的TODO视图查看，单击其中的TODO可跳转到注释处。  </p>
<h3 id="3-导入规范"><a href="#3-导入规范" class="headerlink" title="3.导入规范"></a>3.导入规范</h3><p>&emsp;&emsp;导入语句总是放在文件顶部，位于模块注释和文档注释之后，模块全局变量和常量之前。每一个导入语句只能导入一个模块。<br>&emsp;&emsp;推荐：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">import struct</span><br><span class="line">import binascii</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;不推荐：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import re, struct, binascii</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;但是如果from import后面跟有多个代码元素是可以的。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from codeop import CommandCompiler, compile_command</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;导入语句应该按照从通用到特殊的顺序分组，顺序是：标准库→第三方库→自己的模块。每一组之间有一个空行，而且组中模块是按照英文字母顺序排序的。  </p>
<h3 id="4-代码排版"><a href="#4-代码排版" class="headerlink" title="4.代码排版"></a>4.代码排版</h3><p>&emsp;&emsp;代码排版包括空行、空格、断行和缩进等内容。  </p>
<h5 id="4-1-空行"><a href="#4-1-空行" class="headerlink" title="4.1  空行"></a>4.1  空行</h5><p>&emsp;&emsp;空行用以将逻辑相关的代码段分隔开，以提高可读性。<br>&emsp;&emsp;1.import语句块前后保留两个空行。<br>&emsp;&emsp;2.函数声明之前保留两个空行。<br>&emsp;&emsp;3.类声明之前保留两个空行。<br>&emsp;&emsp;4.方法声明之前保留一个空行。<br>&emsp;&emsp;5.两个逻辑代码块之间应该保留一个空行。  </p>
<h5 id="4-2-空格"><a href="#4-2-空格" class="headerlink" title="4.2  空格"></a>4.2  空格</h5><p>&emsp;&emsp;代码中的有些位置是需要有空格的。<br>&emsp;&emsp;1.赋值符号“=”前后各有一个空格。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 10</span><br><span class="line">c = 10</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2.所有的二元运算符都应该使用空格与操作数分开。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a += c + d</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;3.一元运算符：算法运算符取反“-”和运算符取反“~”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b = 10</span><br><span class="line">a = -b</span><br><span class="line">y = ~b</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;4.括号内不要有空格，Python中括号包括小括号“()”、中括号“[]”和大括号“{}”。<br>&emsp;&emsp;推荐：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doque(cat[1], &#123;dogs: 2&#125;, [])</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;不推荐：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doque(cat[ 1 ], &#123; dogs: 2 &#125;, [ ])</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;5.不要在逗号、分号、冒号前面有空格，而是要在它们后面有一个空格，除非该符号已经是行尾了。<br>&emsp;&emsp;推荐：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if x == 88:</span><br><span class="line">    print(x, y)</span><br><span class="line">x, y = y, x</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;不推荐：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if x == 88:</span><br><span class="line">    print(x , y)</span><br><span class="line">x , y = y , x</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;6.参数列表、索引或切片的左括号前不应有空格。<br>&emsp;&emsp;推荐：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">doque(1)</span><br><span class="line">dogs[&apos;key&apos;] = list[index]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;不推荐：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">doque (1)</span><br><span class="line">dict [&apos;key&apos;] = list [index]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;7.如果使用具有不同优先级的运算符，请考虑在具有最低优先级的运算符周围添加空格。有时需要通过自己来判断；但是，不要使用一个以上的空格，并且在二元运算符的两边使用相同数量的空格。  </p>
<h5 id="4-3-缩进"><a href="#4-3-缩进" class="headerlink" title="4.3  缩进"></a>4.3  缩进</h5><p>&emsp;&emsp;4个空格常被作为缩进排版的一个级别。虽然在开发时程序员可以使用制表符进行缩进，而默认情况下一个制表符等于8个空格，但是不同的IDE工具中一个制表符与空格对应个数会有不同，所以不要使用制表符缩进。Python 3不允许同时使用空格和制表符的缩进。<br>&emsp;&emsp;代码块的内容相当于首行缩进一个级别（4个空格）。  </p>
<h5 id="4-4-断行"><a href="#4-4-断行" class="headerlink" title="4.4  断行"></a>4.4  断行</h5><p>&emsp;&emsp;一行代码中最多79个字符，对于文档注释和多行注释时一行最多72个字符，但是如果注视中包含URL地址可以不受这个限制。否则，如果超过则需断行。<br>&emsp;&emsp;1.在逗号后面断开。<br>&emsp;&emsp;2.在运算符前面断开。<br>&emsp;&emsp;3.尽量不要使用续行符“\”，当有括号（包括大括号、中括号和小括号）则在括号中断开，这样可以不使用续行符。有时为了省略续行符，会将表达式用小括号括起来。在括号中，续行是隐式的。<br>&emsp;&emsp;4.反斜杠有时依然很有用。比如，比较长的，多个with状态语句，不能使用隐式续行，所以反斜杠是可以接受。<br>&emsp;&emsp;5.续行应该与其包裹元素对齐，要么使用圆括号、方括号和花括号内的隐式行连接来垂直对齐，要么使用挂行缩进对齐。当使用挂行缩进时，应该考虑到第一行不应该有参数，以及使用缩进以区分自己是续行。四空格的规则对于续行是可选的。挂行缩进不一定要用4个空格。  </p>
<h3 id="5-源文件编码"><a href="#5-源文件编码" class="headerlink" title="5.源文件编码"></a>5.源文件编码</h3><p>&emsp;&emsp;Python核心发布版本中的代码总是以UTF-8格式编码（或者在Python 2中用ASCII编码）。<br>&emsp;&emsp;使用ASCII（在Python 2中）或UTF-8（在Python 3中）编码的文件不应具有编码声明。<br>&emsp;&emsp;在标准库中，非默认的编码应该只用于测试，或者当一个注释或者文档字符串需要提及一个包含内ASCII字符编码的作者名字的时候；否则，使用\x,\u,\U , 或者 \N 进行转义来包含非ASCII字符。<br>&emsp;&emsp;对于Python 3和更高版本，标准库规定了以下策略（参见 PEP 3131）：Python标准库中的所有标识符必须使用ASCII标识符，并在可行的情况下使用英语单词（在许多情况下，缩写和技术术语是非英语的）。此外，字符串文字和注释也必须是ASCII。唯一的例外是测试非ASCII特征的测试用例以及作者的名称。作者的名字如果不使用拉丁字母拼写，必须提供一个拉丁字母的音译。  </p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/12/21/%E3%80%90%E7%AE%97%E6%B3%95%E7%A7%AF%E7%B4%AF%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8E%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/">
                【算法积累】动态规划与斐波那契数列
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-12-21</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>&emsp;&emsp;注：本题来自LeetCode题库70.爬楼梯。  </p>
<blockquote>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>注意：给定 n 是一个正整数。  </p>
</blockquote>
<p>&emsp;&emsp;示例1：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure>
<p> &emsp;&emsp;示例2：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure></p>
<h2 id="解法1：动态规划法"><a href="#解法1：动态规划法" class="headerlink" title="解法1：动态规划法"></a>解法1：动态规划法</h2><p>&emsp;&emsp;不难发现，这个问题可以被分解为一些包含最优子结构的子问题，即它的最优解可以从其子问题的最优解来有效地构建，我们可以使用动态规划来解决这一问题。<br>&emsp;&emsp;假设我们要爬到第n个台阶，则有两种情况：一是爬到第(n-1)个台阶，然后再往上爬1个台阶即可；二是爬到第(n-2)个台阶，然后再往上爬2个台阶即可。也就是说，爬到第n个台阶的方法数，就是爬到第(n-1)个台阶的方法数与爬到第(n-2)个台阶的方法数之和。<br>&emsp;&emsp;特别地，当n=1时，方法数为1；当n=2时，方法数为2（即1+1或直接爬2个台阶）。<br>&emsp;&emsp;代码实现如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 语言：C</span><br><span class="line">// 执行用时：0ms（又是0ms，具体情况未知）</span><br><span class="line">// 内存消耗：6.8MB</span><br><span class="line">int climbStairs(int n)&#123;</span><br><span class="line">    if (n == 1)</span><br><span class="line">        return 1;</span><br><span class="line">    int first, second, third, i;</span><br><span class="line">    first = 1;</span><br><span class="line">    second = 2;</span><br><span class="line">    for (i = 3; i &lt; n + 1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        third = first + second;</span><br><span class="line">        first = second;</span><br><span class="line">        second = third;</span><br><span class="line">    &#125;</span><br><span class="line">    return second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这种解法的时间复杂度为O(n)，空间复杂度为O(n)。  </p>
<h2 id="解法2：斐波那契数列法"><a href="#解法2：斐波那契数列法" class="headerlink" title="解法2：斐波那契数列法"></a>解法2：斐波那契数列法</h2><p>&emsp;&emsp;我们再分析一下解法1，不难发现这其实就是斐波那契数列。所以这道题还可以用斐波那契数列法来解决。下面给出C和Python 3的代码：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 语言：C</span><br><span class="line">// 执行用时：0ms（我不想再说什么了……为啥又是0啊QAQ……）</span><br><span class="line">// 内存消耗：6.9MB</span><br><span class="line">int climbStairs(int n)&#123;</span><br><span class="line">    if (n == 1)</span><br><span class="line">        return 1;</span><br><span class="line">    int fib[100];</span><br><span class="line">    fib[1] = 1;</span><br><span class="line">    fib[2] = 2;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 3; i &lt;= n; i++)</span><br><span class="line">        fib[i] = fib[i - 1] + fib[i - 2];</span><br><span class="line">    return fib[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">语言：Python 3</span><br><span class="line">执行用时：36ms（诶它终于不是0ms了嘿嘿QvQ）</span><br><span class="line">内存消耗：12.7MB</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">class Solution:</span><br><span class="line">    def climbStairs(self, n: int) -&gt; int:</span><br><span class="line">        if n == 1:</span><br><span class="line">            return 1</span><br><span class="line">        fib = [1, 1, 2]</span><br><span class="line">        for i in range(3, n + 1):</span><br><span class="line">            next = fib[i - 1] + fib[i - 2]</span><br><span class="line">            fib.append(next)</span><br><span class="line">        return fib[n]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;同样地，这种解法的时间复杂度为O(n)，空间复杂度为O(n)。  </p>
<h2 id="解法3：斐波那契公式法"><a href="#解法3：斐波那契公式法" class="headerlink" title="解法3：斐波那契公式法"></a>解法3：斐波那契公式法</h2><p>&emsp;&emsp;既然知道这道题本质上就是斐波那契数列了，那么我们就可以直接使用公式啦！<br>&emsp;&emsp;斐波那契数列的公式如下：<br>$$F_n=\frac{1}{\sqrt{5}}\left(\left(\frac{1+\sqrt{5}}{2}\right)^{n+1}-\left(\frac{1-\sqrt{5}}{2}\right)^{n+1}\right)$$<br>&emsp;&emsp;套用这个公式可以很快地解决本题。Python 3代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">语言：Python 3</span><br><span class="line">执行用时：48ms（比上一个方法慢了不少诶QnQ）</span><br><span class="line">内存消耗：12.8MB</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import math</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def climbStairs(self, n: int) -&gt; int:</span><br><span class="line">        return int((pow((1+math.sqrt(5))/2, n+1) - pow((1-math.sqrt(5))/2, n+1)) / math.sqrt(5))</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这种方法的时间复杂度为O(log(n))（pow()将会用去log(n)的时间），空间复杂度为O(1)（使用常量级空间）。  </p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/12/21/%E3%80%90%E7%AE%97%E6%B3%95%E7%A7%AF%E7%B4%AF%E3%80%91%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/">
                【算法积累】二分查找法
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-12-21</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="二分查找法简介"><a href="#二分查找法简介" class="headerlink" title="二分查找法简介"></a>二分查找法简介</h2><p>&emsp;&emsp;二分查找也称折半查找(Binary Search)，它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。<br>&emsp;&emsp;首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。<br>&emsp;&emsp;算法要求：1.必须采用顺序存储结构。2.必须按关键字大小有序排列。<br>&emsp;&emsp;比较次数的计算公式：a&lt;log<del>2</del>n&lt;b，其中a,b,n均为正整数。即当顺序表有n个关键字时：查找失败至少比较a次关键字，查找成功最多比较关键字次数是b。  </p>
<h2 id="二分查找法模板"><a href="#二分查找法模板" class="headerlink" title="二分查找法模板"></a>二分查找法模板</h2><p>&emsp;&emsp;以Java为例：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int searchInsert(int[] nums, int target) &#123;</span><br><span class="line">        int left = 0, right = nums.length - 1;</span><br><span class="line">        while(left &lt;= right) &#123;</span><br><span class="line">            int mid = (left + right) / 2;</span><br><span class="line">            if(nums[mid] == target) &#123;</span><br><span class="line">                // 相关逻辑</span><br><span class="line">            &#125; else if(nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 相关返回值</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;或者：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int searchInsert(int[] nums, int target) &#123;</span><br><span class="line">        int left = 0, right = nums.length;</span><br><span class="line">        while(left &lt; right) &#123;</span><br><span class="line">            int mid = (left + right) / 2;</span><br><span class="line">            if(nums[mid] == target) &#123;</span><br><span class="line">                // 相关逻辑</span><br><span class="line">            &#125; else if(nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                right = mid; // 注意</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 相关返回值</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：上述代码参考LeetCode用户<code>灵魂画师牧码</code>的题解<code>画解算法：35.搜索插入位置</code>。链接：<a href="https://leetcode-cn.com/problems/search-insert-position/solution/hua-jie-suan-fa-35-sou-suo-cha-ru-wei-zhi-by-guanp/" target="_blank" rel="noopener">link</a>  </p>
</blockquote>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><blockquote>
<p>题目：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。<br>注：该题目出自LeetCode题库35.搜索插入位置。  </p>
</blockquote>
<p>&emsp;&emsp;这道题最容易想到的方法是遍历法。代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 语言：C</span><br><span class="line">// 执行用时：8ms</span><br><span class="line">// 内存消耗：7.2MB</span><br><span class="line">int searchInsert(int* nums, int numsSize, int target)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (nums[i] &gt;= target)</span><br><span class="line">            return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;应用二分查找法，代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 语言：Java</span><br><span class="line">// 执行用时：0ms（具体原因未知，可能是因为提交的时候网络卡顿）</span><br><span class="line">// 内存消耗：39.2MB</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int searchInsert(int[] nums, int target) &#123;</span><br><span class="line">        int l = 0;</span><br><span class="line">        int r = nums.length - 1;</span><br><span class="line">        while (l &lt;= r) &#123;</span><br><span class="line">            int m = (l + r) / 2;</span><br><span class="line">            if (nums[m] == target) &#123;</span><br><span class="line">                return m;</span><br><span class="line">            &#125; else if (nums[m] &gt; target) &#123;</span><br><span class="line">                r = m - 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                l = m + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 语言：C</span><br><span class="line">// 执行用时：8ms</span><br><span class="line">// 内存消耗：7.1MB</span><br><span class="line">int searchInsert(int* nums, int numsSize, int target)&#123;</span><br><span class="line">    int l, r;</span><br><span class="line">    l = 0;</span><br><span class="line">    r = numsSize - 1;</span><br><span class="line">    while (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        int m = (l + r) / 2;</span><br><span class="line">        if (nums[m] == target)</span><br><span class="line">            return m;</span><br><span class="line">        else if (nums[m] &gt; target)</span><br><span class="line">            r = m - 1;</span><br><span class="line">        else</span><br><span class="line">            l = m + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当然，我们还可以使用Python无脑解决这个问题：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">语言：Python3</span><br><span class="line">执行用时：44ms</span><br><span class="line">内存消耗：13.5MB</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">class Solution:</span><br><span class="line">    def searchInsert(self, nums: List[int], target: int) -&gt; int:</span><br><span class="line">        if target in nums:</span><br><span class="line">            return nums.index(target)</span><br><span class="line">        else:</span><br><span class="line">            nums.append(target)</span><br><span class="line">            nums = sorted(nums)</span><br><span class="line">            return nums.index(target)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在逛LeetCode评论区的时候，还看到了一位大神<code>李达西</code>的Python“一行流”解法：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">语言：Python3</span><br><span class="line">执行用时：据该用户的说法是50ms</span><br><span class="line">内存消耗：未知</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">class Solution:</span><br><span class="line">    def searchInsert(self, nums: List[int], target: int) -&gt; int:</span><br><span class="line">        return len([i for i in nums if i &lt; target])</span><br></pre></td></tr></table></figure>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/12/21/%E3%80%90%E6%80%BB%E7%BB%93%E7%AF%87%E3%80%91Python%20matplotlib%E4%B9%8B%E4%BD%BF%E7%94%A8%E7%BB%9F%E8%AE%A1%E5%87%BD%E6%95%B0%E7%BB%98%E5%88%B6%E7%AE%80%E5%8D%95%E5%9B%BE%E5%BD%A2/">
                【总结篇】Python matplotlib之使用统计函数绘制简单图形
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-12-21</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>&emsp;&emsp;作者注：我在这里只总结函数的功能及其用法，程序实例参考链接：<a href="https://github.com/CCH21/Python/tree/master/Python%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B9%8Bmatplotlib%E5%AE%9E%E8%B7%B5" target="_blank" rel="noopener">link</a><br>&emsp;&emsp;我们用下面的语句来导入matplotlib库：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br></pre></td></tr></table></figure>
<h2 id="绘制简单图形的统计函数及其用法"><a href="#绘制简单图形的统计函数及其用法" class="headerlink" title="绘制简单图形的统计函数及其用法"></a>绘制简单图形的统计函数及其用法</h2><h5 id="1-函数bar"><a href="#1-函数bar" class="headerlink" title="1.函数bar()"></a>1.函数bar()</h5><p>函数bar()用来绘制柱状图。<br>函数功能：在x轴上绘制定性数据的分布特征。<br>调用签名：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.bar(x, y)</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>x：标示在x轴上的定性数据的类别。<br>y：每种定性数据的类别的数量。  </p>
<h5 id="2-函数barh"><a href="#2-函数barh" class="headerlink" title="2.函数barh()"></a>2.函数barh()</h5><p>函数barh()用于绘制条形图。<br>函数功能：在y轴上绘制定性数据的分布特征。<br>调用签名：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.barh(x, y)</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>x：标示在y轴上的定性数据的类别。<br>y：每种定性数据的类别的数量。  </p>
<h5 id="3-函数hist"><a href="#3-函数hist" class="headerlink" title="3.函数hist()"></a>3.函数hist()</h5><p>函数hist()用于绘制直方图。<br>函数功能：在x轴上绘制定量数据的分布特征。<br>调用签名：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.hist(x)</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>x：在x轴上绘制箱体的定量数据输入值。  </p>
<h5 id="4-函数pie"><a href="#4-函数pie" class="headerlink" title="4.函数pie()"></a>4.函数pie()</h5><p>函数pie()用于绘制饼图。<br>函数功能：绘制定性数据的不同类别的百分比。<br>调用签名：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.pie(x)</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>x：定性数据的不同类别的百分比。  </p>
<h5 id="5-函数polar"><a href="#5-函数polar" class="headerlink" title="5.函数polar()"></a>5.函数polar()</h5><p>函数polar()用于绘制极线图。<br>函数功能：在极坐标轴上绘制折线图。<br>调用签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.polar(theta, r)</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>theta：每个标记所在射线与极径的夹角。<br>r：每个标记到原点的距离。  </p>
<h5 id="6-函数scatter"><a href="#6-函数scatter" class="headerlink" title="6.函数scatter()"></a>6.函数scatter()</h5><p>函数scatter()用于绘制气泡图。<br>函数功能：二位数据借助气泡大小展示三维数据。<br>调用签名：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(x, y)</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>x：x轴上的数值。<br>y：y轴上的数值。<br>s：散点标记的大小。<br>c：散点标记的颜色。<br>cmap：将浮点数映射成颜色的颜色映射表。  </p>
<h5 id="7-函数stem"><a href="#7-函数stem" class="headerlink" title="7.函数stem()"></a>7.函数stem()</h5><p>函数stem()用于绘制棉棒图。<br>函数功能：绘制离散有序数据。<br>调用签名：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.stem(x, y)</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>x：指定棉棒上的x轴基线上的位置。<br>y：绘制棉棒的长度。<br>linefmt：棉棒的样式。<br>markerfmt：棉棒末端的样式。<br>basefmt：指定基线的样式。  </p>
<h5 id="8-函数boxplot"><a href="#8-函数boxplot" class="headerlink" title="8.函数boxplot()"></a>8.函数boxplot()</h5><p>函数boxplot()用于绘制箱线图。<br>函数功能：绘制箱线图。<br>调用签名：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.boxplot(x)</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>x：绘制箱线图的输入数据。  </p>
<h5 id="9-函数errorbar"><a href="#9-函数errorbar" class="headerlink" title="9.函数errorbar()"></a>9.函数errorbar()</h5><p>函数errorbar()用于绘制误差棒图。<br>函数功能：绘制y轴方向或是x轴方向的误差范围。<br>调用签名：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.errorbar(x, y, yerr=a, xerr=b)</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>x：数据点的水平位置。<br>y：数据点的垂直位置。<br>yerr：y轴方向的数据点的误差计算方法。<br>xerr：x轴方向的数据点的误差计算方法。  </p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>&emsp;&emsp;如果你有什么想法、意见和建议的话，欢迎联系我。<br>&emsp;&emsp;我的邮箱：<a href="mailto:1398635912@qq.com" target="_blank" rel="noopener">1398635912@qq.com</a></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/12/20/%E3%80%90%E6%80%BB%E7%BB%93%E7%AF%87%E3%80%91Python%20matplotlib%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E7%BB%98%E5%88%B6matplotlib%E7%9A%84%E5%9B%BE%E8%A1%A8%E7%BB%84%E6%88%90%E5%85%83%E7%B4%A0/">
                【总结篇】Python matplotlib之使用函数绘制matplotlib的图表组成元素
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-12-20</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>学习参考书籍：《Python数据可视化之matplotlib实践》<br>出版社信息：中国工信出版集团 电子工业出版社<br>作者：刘大成<br>ISBN：978-7-121-34888-4  </p>
<p>作者注：我在这里只总结函数的功能及其用法，程序实例参考链接：<a href="https://github.com/CCH21/Python/tree/master/Python%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B9%8Bmatplotlib%E5%AE%9E%E8%B7%B5" target="_blank" rel="noopener">link</a>  </p>
<h2 id="matplotlib简介"><a href="#matplotlib简介" class="headerlink" title="matplotlib简介"></a>matplotlib简介</h2><p>&emsp;&emsp;matplotlib库是Python中绘制二维、三维图表的数据可视化工具。它能让使用者很轻松地将数据图形化，并且提供多样化的输出格式。<br>&emsp;&emsp;在使用matplotlib库的时候，我们应先用下面的语句导入matplotlib库：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib as mpl</span><br><span class="line">import matplotlib.pyplot as plt</span><br></pre></td></tr></table></figure>
<h2 id="绘制图表组成元素的函数及其用法"><a href="#绘制图表组成元素的函数及其用法" class="headerlink" title="绘制图表组成元素的函数及其用法"></a>绘制图表组成元素的函数及其用法</h2><h5 id="1-函数plot"><a href="#1-函数plot" class="headerlink" title="1.函数plot()"></a>1.函数plot()</h5><p>函数功能：展现变量的趋势变化。<br>调用签名：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(s, y, ls=&quot;-&quot;, lw=2, label=&quot;plot figure&quot;)</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>x：x轴上的数值。<br>y：y轴上的数值。<br>ls：折线图的线条风格。<br>lw：折线图的线条宽度。<br>label：标记图形内容的标签文本。  </p>
<h5 id="2-函数scatter"><a href="#2-函数scatter" class="headerlink" title="2.函数scatter()"></a>2.函数scatter()</h5><p>函数功能：寻找变量之间的关系。<br>调用签名：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(x, y, c=&quot;b&quot;, label=&quot;scatter figure&quot;)</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>x：x轴上的数值。<br>y：y轴上的数值。<br>c：散点图中标记的颜色。<br>label：标记图形内容的标签文本。  </p>
<h5 id="3-函数xlim-amp-ylim"><a href="#3-函数xlim-amp-ylim" class="headerlink" title="3.函数xlim() &amp; ylim()"></a>3.函数xlim() &amp; ylim()</h5><p>函数功能：设置x轴（y轴）的数值显示范围。<br>调用签名：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.xlim(xmin, xmax)</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>xmin：x轴上的最小值。<br>xmax：x轴上的最大值。<br>平移性：上面的函数功能，调用签名和参数说明同样可以平移到函数ylim()上。  </p>
<h5 id="4-函数xlabel-amp-ylabel"><a href="#4-函数xlabel-amp-ylabel" class="headerlink" title="4.函数xlabel() &amp; ylabel()"></a>4.函数xlabel() &amp; ylabel()</h5><p>函数功能：设置x轴（y轴）的标签文本。<br>调用签名：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.xlabel(string)</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>string：标签文本内容。<br>平移性：上面的函数功能，调用签名和参数说明同样可以平移到函数ylabel()上。  </p>
<h5 id="5-函数grid"><a href="#5-函数grid" class="headerlink" title="5.函数grid()"></a>5.函数grid()</h5><p>函数功能：绘制刻度线的网格线。<br>调用签名：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ply.grid(linestyle=&quot;:&quot;, color=&quot;r&quot;)</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>linestyle：网格线的线条风格。<br>color：网格线的线条颜色。  </p>
<h5 id="6-函数axhline-amp-axvline"><a href="#6-函数axhline-amp-axvline" class="headerlink" title="6.函数axhline() &amp; axvline()"></a>6.函数axhline() &amp; axvline()</h5><p>函数功能：绘制平行于x轴（y轴）的水平（竖直）参考线。<br>调用签名：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.axhline(y=0.0, c=&quot;r&quot;, ls=&quot;--&quot;, lw=2)</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>y：水平参考线的出发点。<br>c：参考线的线条颜色。<br>ls：参考线的线条风格。<br>lw：参考线的线条宽度。<br>平移性：上面的函数功能，调用签名和参数说明同样可以平移到函数axvline()上。  </p>
<h5 id="7-函数axvspan-amp-axhspan"><a href="#7-函数axvspan-amp-axhspan" class="headerlink" title="7.函数axvspan() &amp; axhspan()"></a>7.函数axvspan() &amp; axhspan()</h5><p>函数功能：绘制垂直于x轴（y轴）的参考区域。<br>调用签名：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.avxspan(xmin=1.0, xmax=2.0, facecolor=&quot;y&quot;, alpha=0.3)</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>xmin：参考区域的起始位置。<br>xmax：参考区域的终止位置。<br>facecolor：参考区域的填充颜色。<br>alpha：参考区域的填充颜色的透明度。<br>平移性：上面的函数功能、调用签名和参数说明可以平移到函数axhspan()上。  </p>
<h5 id="8-函数annotate"><a href="#8-函数annotate" class="headerlink" title="8.函数annotate()"></a>8.函数annotate()</h5><p>函数功能：添加图形内容细节的指向型注释文本。<br>调用签名：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.annotate(string, xy=(np.pi/2, 1.0),</span><br><span class="line">             xytext=((np.pi/2)+0.15, 1.5), </span><br><span class="line">             weight=&quot;bold&quot;, </span><br><span class="line">             color=&quot;b&quot;, </span><br><span class="line">             arrowprops=dict(arrowstyle=&quot;-&gt;&quot;, connectionstyle=&quot;arc3&quot;, color=&quot;b&quot;))</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>string：图形内容的注释文本。<br>xy：被注释图形内容的位置坐标。<br>xytext：注释文本的位置坐标。<br>weight：注释文本的字体粗细风格。<br>color：注释文本的字体颜色。<br>arrowprops：指示被注释内容的箭头的属性字典。  </p>
<h5 id="9-函数text"><a href="#9-函数text" class="headerlink" title="9.函数text()"></a>9.函数text()</h5><p>函数功能：添加图形内容细节的无指向性注释文本。<br>调用签名：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.text(x, y, string, weight=&quot;bold&quot;, color=&quot;b&quot;)</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>x：注释文本内容所在位置的横坐标。<br>y：注释文本内容所在位置的纵坐标。<br>string：注释文本内容。<br>weight：注释文本内容的粗细风格。<br>color：注释文本内容的字体颜色。  </p>
<h5 id="10-函数title"><a href="#10-函数title" class="headerlink" title="10.函数title()"></a>10.函数title()</h5><p>函数功能：添加图形内容的标题。<br>调用签名：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.title(string)</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>string：图形内容的标题文本。  </p>
<h5 id="11-函数legend"><a href="#11-函数legend" class="headerlink" title="11.函数legend()"></a>11.函数legend()</h5><p>函数功能：标示不同图形的文本标签图例。<br>调用签名：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.legend(loc=&quot;lower left&quot;)</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>loc：图例在图中的地理位置。  </p>
<h5 id="12-函数show"><a href="#12-函数show" class="headerlink" title="12.函数show()"></a>12.函数show()</h5><p>函数功能：在屏幕上显示出绘制的图表。<br>调用签名：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>&emsp;&emsp;我最近刚刚开始学习Python的matplotlib库，对此的感觉就是函数及其参数很多、很不好记。但是matplotlib真的是一个功能很强大的库，在数据可视化领域的重要性不言而喻。希望自己可以通过这一段时间的学习熟练掌握matplotlib库的用法。<br>&emsp;&emsp;如果你有什么想法、意见和建议的话，欢迎联系我。<br>&emsp;&emsp;我的邮箱：<a href="mailto:1398635912@qq.com" target="_blank" rel="noopener">1398635912@qq.com</a></p>

        </div>
    

</div>
            
        </section>
    </div>
</div>



    <div class="row">
        <div class="col-sm-12">
            <div class="wrap-pagination">
                <a class="" href="/page/3/">
                    <i class="fa fa-chevron-left" aria-hidden="true"></i>
                </a>
                <a class="" href="/page/5/">
                    <i class="fa fa-chevron-right" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>




</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    I'd walk a million miles just to see your smile. 
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2020/07/15/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%91%A8%E4%BB%BB%E5%8A%A1%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E7%88%AC%E8%99%AB/">实验室暑假学习第一周任务总结——爬虫</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/05/10/%E5%9F%BA%E4%BA%8EFluent-Terminal%E5%92%8CCmder%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E7%BE%8E%E8%A7%82%E7%9A%84Windows%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/">基于Fluent Terminal和Cmder打造</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/04/24/%E3%80%90Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%E3%80%91%E8%BF%9115%E5%B9%B4%E7%9A%84%E4%B8%AD%E5%9B%BD%E5%9B%BD%E5%86%85%E7%94%9F%E4%BA%A7%E6%80%BB%E5%80%BC/">【Python网络爬虫与数据可视化实战案例】近15</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/04/17/%E3%80%90Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%E3%80%91%E6%9C%AA%E6%9D%A515%E5%A4%A9%E6%B0%94%E6%B8%A9%E8%B5%B0%E5%8A%BF%E5%9B%BE/">【Python网络爬虫与数据可视化实战案例】未来1</a>
            </li>
            
        </ul>
    </div>



            
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/CCH21" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:1398635912@qq.com" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a href="http://www.codeblocq.com/" target="_blank" rel="noopener">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



</body>

</html>