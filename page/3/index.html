<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    

    <!--Author-->
    
        <meta name="author" content="John Doe">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Welcome to CCH21&#39;s Blog"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="Welcome to CCH21&#39;s Blog"/>

    <!--Type page-->
    
        <meta property="og:type" content="website" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>page - Welcome to CCH21&#39;s Blog</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about.html">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact.html">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
            <h1 id="main-title" class="title">Welcome to CCH21's Blog</h1>
        
    </div>
</header>

        <section class="main">
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/01/26/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E4%B9%8BCSV%E6%96%87%E4%BB%B6(6)/">
                Python数据分析基础之CSV文件(6)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-01-26</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <p>&emsp;&emsp;之前的5篇文章全部讲的是处理单个CSV文件。但是，在大多数情况下，我们需要处理很多文件，而手工处理效率低，或者文件多到手工处理根本行不通。在这种情况下，使用Python可以规模化地处理文件，减少了人为工作量的同时，也有效地减少了人为犯错的概率。<br>&emsp;&emsp;为了规模化地处理CSV文件，我们需要使用Python内置的glob模块。我们使用下面的语句来导入该模块：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import glob</span><br></pre></td></tr></table></figure>
<h2 id="读取多个CSV文件"><a href="#读取多个CSV文件" class="headerlink" title="读取多个CSV文件"></a>读取多个CSV文件</h2><p>&emsp;&emsp;在本例中，我们需要先新建3个CSV文件，如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200126172215597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/2020012617224251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200126172308766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;我们先从最简单的行列计数开始。尽管有些时候我们知道要处理的文件中的内容，但在多数情况下，文件是别人发送给我们的，我们不会立即知道文件中的内容。因此，行列计数是最简单的，也是最重要的。<br>&emsp;&emsp;我们编写下列代码，来读取上面创建的3个CSV文件。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import csv</span><br><span class="line">import glob</span><br><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_path = sys.argv[1]</span><br><span class="line"></span><br><span class="line">file_counter = 0</span><br><span class="line">for input_file in glob.glob(os.path.join(input_path, &apos;sales_*&apos;)):</span><br><span class="line">    row_counter = 1</span><br><span class="line">    with open(input_file, &apos;r&apos;, newline=&apos;&apos;) as csv_in_file:</span><br><span class="line">        filereader = csv.reader(csv_in_file)</span><br><span class="line">        header = next(filereader, None)</span><br><span class="line">        for row in filereader:</span><br><span class="line">            row_counter += 1</span><br><span class="line">    print(&apos;&#123;0!s&#125;: \t&#123;1:d&#125; rows \t&#123;2:d&#125; columns&apos;.format(os.path.basename(input_file), row_counter, len(header)))</span><br><span class="line">    file_counter += 1</span><br><span class="line">print(&apos;Number of files: &#123;0:d&#125;&apos;.format(file_counter))</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们来解释一下上面的代码。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这行代码导入了Python内置的os模块，它提供的函数可以列出和解析我们要处理的文件路径名。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for input_file in glob.glob(os.path.join(input_path, &apos;sales_*&apos;)):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里创建了一个<code>for</code>循环，它将数据处理扩展到多个文件中。os模块中的<code>os.path.join()</code>函数将圆括号中的两部分连在一起，其中<code>input_path</code>是包含输入文件的文件夹的路径，<code>sales_*</code>表示任何以模式<code>sales_</code>开头的文件名。glob模块中的<code>glob.glob()</code>函数将<code>sales_*</code>中的<code>*</code>转换为实际的文件名。也就是说，在这个例子中，<code>glob.glob()</code>和<code>os.path.join()</code>两个函数创建了一个包含3个输入文件的列表。然后，<code>for</code>循环语句对于列表中每个输入文件执行下面缩进的各行代码。<br>&emsp;&emsp;我们在命令行窗口中运行这个脚本。<br><img src="https://img-blog.csdnimg.cn/20200126173802298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;可以看到，输出结果显示脚本处理了3个文件，每个文件都有7行和5列。  </p>
<h2 id="从多个文件中连接数据"><a href="#从多个文件中连接数据" class="headerlink" title="从多个文件中连接数据"></a>从多个文件中连接数据</h2><p>&emsp;&emsp;上面讲了如何读取多个CSV文件，接下来讨论如何把多个CSV文件中的数据连接起来。  </p>
<h4 id="1-基础Python"><a href="#1-基础Python" class="headerlink" title="1.基础Python"></a>1.基础Python</h4><p>&emsp;&emsp;代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import csv</span><br><span class="line">import glob</span><br><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_path = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">first_file = True</span><br><span class="line">for input_file in glob.glob(os.path.join(input_path, &apos;sales_*&apos;)):</span><br><span class="line">    print(os.path.basename(input_file))</span><br><span class="line">    with open(input_file, &apos;r&apos;, newline=&apos;&apos;) as csv_in_file:</span><br><span class="line">        with open(output_file, &apos;a&apos;, newline=&apos;&apos;) as csv_out_file:</span><br><span class="line">            filereader = csv.reader(csv_in_file)</span><br><span class="line">            filewriter = csv.writer(csv_out_file)</span><br><span class="line">            if first_file:</span><br><span class="line">                for row in filereader:</span><br><span class="line">                    filewriter.writerow(row)</span><br><span class="line">                first_file = False</span><br><span class="line">            else:</span><br><span class="line">                header = next(filereader, None)</span><br><span class="line">                for row in filereader:</span><br><span class="line">                    filewriter.writerow(row)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们来解释一下上面的代码。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">with open(output_file, &apos;a&apos;, newline=&apos;&apos;) as csv_out_file:</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;和之前不同，这里<code>open()</code>函数中的参数不是<code>&#39;w&#39;</code>（可写）而是<code>&#39;a&#39;</code>（追加）。这里为什么不用可写模式呢？我们先来讨论一下可写模式和追加模式的区别。<br>模式|描述<br>——|——<br>w|打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。<br>a|打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。<br>&emsp;&emsp;使用追加模式，每个输入文件中的数据可以追加（也就是添加）到输出文件中。而如果使用可写模式，从一个输入文件中输出的数据会覆盖掉前一个输入文件中的数据，最后的输出文件会只包含最后处理的那个输入文件中的数据。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">first_file = True</span><br><span class="line">for input_file in glob.glob(os.path.join(input_path, &apos;sales_*&apos;)):</span><br><span class="line">    ...</span><br><span class="line">            if first_file:</span><br><span class="line">                for row in filereader:</span><br><span class="line">                    filewriter.writerow(row)</span><br><span class="line">                first_file = False</span><br><span class="line">            else:</span><br><span class="line">                header = next(filereader, None)</span><br><span class="line">                for row in filereader:</span><br><span class="line">                    filewriter.writerow(row)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里的<code>if-else</code>语句根据前面创建的<code>first_file</code>变量来区分当前文件是否为第一个输入文件。做这个区分的目的是将标题行仅写入输出文件一次，避免重复输入。<code>if</code>代码块处理第一个输入文件，将所有行写入输出文件。<code>else</code>代码块处理余下的输入文件，使用<code>next()</code>方法将每个输入文件中的标题行赋给变量<code>header</code>，这样就可以在后面的处理过程中跳过标题行，然后将数据行写入输出文件。<br>&emsp;&emsp;我们在命令行窗口运行这个脚本，并打开输出文件查看结果。<br><img src="https://img-blog.csdnimg.cn/20200126180013163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="2-pandas"><a href="#2-pandas" class="headerlink" title="2.pandas"></a>2.pandas</h4><p>&emsp;&emsp;pandas模块可以直接从多个文件中连接数据。代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import pandas as pd</span><br><span class="line">import glob</span><br><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_path = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">all_files = glob.glob(os.path.join(input_path, &apos;sales_*&apos;))</span><br><span class="line">all_data_frames = []</span><br><span class="line">for file in all_files:</span><br><span class="line">    data_frame = pd.read_csv(file, index_col=None)</span><br><span class="line">    all_data_frames.append(data_frame)</span><br><span class="line">data_frame_concat = pd.concat(all_data_frames, axis=0, ignore_index=True)</span><br><span class="line">data_frame_concat.to_csv(output_file, index=False)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;使用pandas模块连接多个文件中的数据，基本过程就是将每个输入文件读取到pandas数据框中，将所有数据框追加到一个数据框列表，然后使用<code>concat()</code>函数将所有数据框连接成一个数据框。<code>concat()</code>函数可以使用<code>axis</code>参数来设置连接数据框的方式，<code>axis=0</code>表示从头到尾垂直堆叠，<code>axis=1</code>表示并排地平行堆叠。<br>&emsp;&emsp;此处省略输出结果。  </p>
<h2 id="计算每个文件中值的总和与均值"><a href="#计算每个文件中值的总和与均值" class="headerlink" title="计算每个文件中值的总和与均值"></a>计算每个文件中值的总和与均值</h2><p>&emsp;&emsp;有些时候，当有多个输入文件时，需要对每个输入文件计算一些统计量，如总和、均值等。  </p>
<h4 id="1-基础Python-1"><a href="#1-基础Python-1" class="headerlink" title="1.基础Python"></a>1.基础Python</h4><p>&emsp;&emsp;代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import csv</span><br><span class="line">import glob</span><br><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_path = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">output_header_list = [&apos;file_name&apos;, &apos;total_sales&apos;, &apos;average_sales&apos;]</span><br><span class="line">csv_out_file = open(output_file, &apos;a&apos;, newline=&apos;&apos;)</span><br><span class="line">filewriter = csv.writer(csv_out_file)</span><br><span class="line">filewriter.writerow(output_header_list)</span><br><span class="line">for input_file in glob.glob(os.path.join(input_path, &apos;sales_*&apos;)):</span><br><span class="line">    with open(input_file, &apos;r&apos;, newline=&apos;&apos;) as csv_in_file:</span><br><span class="line">        filereader = csv.reader(csv_in_file)</span><br><span class="line">        output_list = []</span><br><span class="line">        output_list.append(os.path.basename(input_file))</span><br><span class="line">        header = next(filereader)</span><br><span class="line">        total_sales = 0.0</span><br><span class="line">        number_of_sales = 0.0</span><br><span class="line">        for row in filereader:</span><br><span class="line">            sale_amount = row[3]</span><br><span class="line">            total_sales += float(str(sale_amount).strip(&apos;$&apos;).replace(&apos;,&apos;, &apos;&apos;))</span><br><span class="line">            number_of_sales += 1</span><br><span class="line">        average_sales = &apos;&#123;0:.2f&#125;&apos;.format(total_sales / number_of_sales)</span><br><span class="line">        output_list.append(total_sales)</span><br><span class="line">        output_list.append(average_sales)</span><br><span class="line">        filewriter.writerow(output_list)</span><br><span class="line">csv_out_file.close()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们来解释一下上面的代码。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output_header_list = [&apos;file_name&apos;, &apos;total_sales&apos;, &apos;average_sales&apos;]</span><br><span class="line">csv_out_file = open(output_file, &apos;a&apos;, newline=&apos;&apos;)</span><br><span class="line">filewriter = csv.writer(csv_out_file)</span><br><span class="line">filewriter.writerow(output_header_list)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里创建了一个输出文件的列标题列表<code>output_header_list</code>，并创建<code>filewriter</code>对象，使用<code>writerow()</code>将标题行写入输出文件。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output_list = []</span><br><span class="line">output_list.append(os.path.basename(input_file))</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里创建了一个空列表<code>output_list</code>，保存要写入输出文件中的每行输出。下面一行代码将输入文件的文件名追加到<code>output_list</code>中。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header = next(filereader)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这行代码使用<code>next()</code>函数除去每个输入文件的标题行。<br>&emsp;&emsp;之后的代码内容和之前学习过的内容类似，代码本身也比较简单易懂，故在此不再赘述。<br>&emsp;&emsp;我们在命令行窗口运行这个脚本，并打开输出文件查看结果。<br><img src="https://img-blog.csdnimg.cn/20200126212653946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="2-pandas-1"><a href="#2-pandas-1" class="headerlink" title="2.pandas"></a>2.pandas</h4><p>&emsp;&emsp;pandas模块中提供了一些摘要统计函数，比如<code>sum()</code>和<code>mean()</code>。使用pandas模块的代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import pandas as pd</span><br><span class="line">import glob</span><br><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_path = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">all_files = glob.glob(os.path.join(input_path, &apos;sales_*&apos;))</span><br><span class="line">all_data_frames = []</span><br><span class="line">for input_file in all_files:</span><br><span class="line">    data_frame = pd.read_csv(input_file, index_col=None)</span><br><span class="line">    total_sales = pd.DataFrame([float(str(value).strip(&apos;$&apos;).replace(&apos;,&apos;, &apos;&apos;))</span><br><span class="line">                                for value in data_frame.loc[:, &apos;Sale Amount&apos;]]).sum()</span><br><span class="line">    average_sales = pd.DataFrame([float(str(value).strip(&apos;$&apos;).replace(&apos;,&apos;, &apos;&apos;))</span><br><span class="line">                                for value in data_frame.loc[:, &apos;Sale Amount&apos;]]).mean()</span><br><span class="line">    data = &#123;&apos;file_name&apos;: os.path.basename(input_file),</span><br><span class="line">            &apos;total_sales&apos;: total_sales,</span><br><span class="line">            &apos;average_sales&apos;: average_sales&#125;</span><br><span class="line">    all_data_frames.append(pd.DataFrame(data, columns=[&apos;file_name&apos;, &apos;total_sales&apos;, &apos;average_sales&apos;]))</span><br><span class="line">    data_frames_concat = pd.concat(all_data_frames, axis=0, ignore_index=True)</span><br><span class="line">    data_frames_concat.to_csv(output_file, index=False)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;使用列表生成式将销售额这一列中带<code>$</code>的字符转换为浮点数，然后使用数据框函数将这个对象转换为一个DataFrame，以便可以使用<code>sum()</code>和<code>mean()</code>这两个函数计算列的总计和均值。因为输出文件中的每行应该包含输入文件名，以及文件中销售额的总计和均值，所以可以将这3种数据组合成一个文本框，使用<code>concat()</code>函数将这些数据框连接成为一个数据框，并将这个数据框写入文件。<br>&emsp;&emsp;此处省略输出结果。  </p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>&emsp;&emsp;以上就是Python数据分析中有关CSV文件的全部内容。由于本人能力有限，学习时间也比较短，难免出现纰漏，如果发现还请指正。<br>&emsp;&emsp;我的邮箱：<a href="mailto:1398635912@qq.com" target="_blank" rel="noopener">1398635912@qq.com</a></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/01/24/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E4%B9%8BCSV%E6%96%87%E4%BB%B6(5)/">
                Python数据分析基础之CSV文件(5)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-01-24</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="选取连续的行"><a href="#选取连续的行" class="headerlink" title="选取连续的行"></a>选取连续的行</h2><p>&emsp;&emsp;有时，工作表的头部和尾部是我们不想处理的。在很多情况下，工作表头部是标题、作者信息等，尾部是来源、假设、附加说明、注意事项等，我们并不需要处理这些内容。在这时，我们可以用Python来选取CSV文件中连续的行。<br>&emsp;&emsp;我们把之前的supplier_data.csv文件打开，在工作表头部和尾部分别加入一些不需要处理的内容，如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200124103815623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="1-基础Python"><a href="#1-基础Python" class="headerlink" title="1.基础Python"></a>1.基础Python</h4><p>&emsp;&emsp;要使用基础Python选取特定的行，我们需要创建一个变量<code>row_counter</code>来跟踪行索引。在上面的示例中，我们知道应该保留行索引大于或等于3并且小于或等于15的行。代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import csv</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">row_counter = 0</span><br><span class="line">with open(input_file, &apos;r&apos;, newline=&apos;&apos;) as csv_in_file:</span><br><span class="line">    with open(output_file, &apos;w&apos;, newline=&apos;&apos;) as csv_out_file:</span><br><span class="line">        filereader = csv.reader(csv_in_file)</span><br><span class="line">        filewriter = csv.writer(csv_out_file)</span><br><span class="line">        for row in filereader:</span><br><span class="line">            if 3 &lt;= row_counter &lt;= 15:</span><br><span class="line">                filewriter.writerow([value.strip() for value in row])</span><br><span class="line">            row_counter += 1</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果我们对比一下之前的读写CSV文件的代码，不难发现上面的这个代码只是在原来的基础上稍微做了一下改动，引入变量<code>row_counter</code>，并且在遍历输入文件中所有的行时使用<code>if</code>语句跳过不需要的头部和尾部内容，只保留需要的行。<br>&emsp;&emsp;对于输入文件的前3行，行索引值为0,1,2，此时<code>if</code>的判断结果为<code>False</code>，所以不执行<code>if</code>代码块，并将<code>row_counter</code>的值加1。对于输入文件的最后3行，行索引值为16,17,18，<code>if</code>的判断结果也是<code>False</code>，也不执行<code>if</code>代码块，并将<code>row_counter</code>的值加1。<br>&emsp;&emsp;而对于想要保留的行，它们的行索引值为3~15，即<code>row_counter</code>在3和15之间。此时<code>if</code>判断结果为<code>True</code>，执行<code>if</code>代码块，处理这些行并将其写入输出文件。在列表生成式中，使用<code>strip()</code>函数除去每行两端的空格、制表符和换行符。<br>&emsp;&emsp;我们在命令行窗口中运行这个脚本，并打开输出文件查看结果。<br><img src="https://img-blog.csdnimg.cn/20200124111120350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="2-pandas"><a href="#2-pandas" class="headerlink" title="2.pandas"></a>2.pandas</h4><p>&emsp;&emsp;在pandas模块中，<code>drop()</code>函数可以根据行索引或列标题来丢弃行或列。也就是说，我们只需要使用<code>drop</code>函数丢弃掉前3行和后3行（即行索引为0,1,2,16,17,18的行）即可达到目的。代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import pandas as pd</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">data_frame = pd.read_csv(input_file, header=None)</span><br><span class="line">data_frame = data_frame.drop([0, 1, 2, 16, 17, 18])</span><br><span class="line">data_frame.columns = data_frame.iloc[0]</span><br><span class="line">data_frame = data_frame.reindex(data_frame.index.drop(3))</span><br><span class="line">data_frame.to_csv(output_file, index=False)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;pandas模块中的<code>iloc</code>函数功能强大，它可以根据行索引选取一个单独行作为列索引。<code>reindex()</code>函数可以为数据框重新生成索引。<br>&emsp;&emsp;此处省略输出结果。  </p>
<h2 id="添加标题行"><a href="#添加标题行" class="headerlink" title="添加标题行"></a>添加标题行</h2><p>&emsp;&emsp;有些时候，电子表格没有标题行，而我们却希望所有列都有列标题。使用Python脚本可以添加列标题。<br>&emsp;&emsp;我们打开supplier_data.csv文件。删除掉标题行，并将其保存为supplier_data_no_header_row.csv。<br><img src="https://img-blog.csdnimg.cn/20200124112545166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="1-基础Python-1"><a href="#1-基础Python-1" class="headerlink" title="1.基础Python"></a>1.基础Python</h4><p>&emsp;&emsp;代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import csv</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">with open(input_file, &apos;r&apos;, newline=&apos;&apos;) as csv_in_file:</span><br><span class="line">    with open(output_file, &apos;w&apos;, newline=&apos;&apos;) as csv_out_file:</span><br><span class="line">        filereader = csv.reader(csv_in_file)</span><br><span class="line">        filewriter = csv.writer(csv_out_file)</span><br><span class="line">        header_list = [&apos;Supplier Name&apos;, &apos;Invoice Number&apos;, &apos;Part Number&apos;, &apos;Cost&apos;, &apos;Purchase Date&apos;]</span><br><span class="line">        filewriter.writerow(header_list)</span><br><span class="line">        for row in filereader:</span><br><span class="line">            filewriter.writerow(row)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上面的代码中，创建了一个列表变量<code>header_list</code>，其中包含了作为列标题的5个字符串。<code>writerow()</code>函数将这些列表值写入输出文件的第一行。<br>&emsp;&emsp;我们在命令行窗口中运行这个脚本，并打开输出文件查看结果。<br><img src="https://img-blog.csdnimg.cn/20200124113200888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="2-pandas-1"><a href="#2-pandas-1" class="headerlink" title="2.pandas"></a>2.pandas</h4><p>&emsp;&emsp;pandas模块中的<code>read_csv()</code>函数可以直接指定输入文件不包含标题行，并可以提供一个列标题列表。代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import pandas as pd</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">header_list = [&apos;Supplier Name&apos;, &apos;Invoice Number&apos;, &apos;Part Number&apos;, &apos;Cost&apos;, &apos;Purchase Date&apos;]</span><br><span class="line">data_frame = pd.read_csv(input_file, header=None, names=header_list)</span><br><span class="line">data_frame.to_csv(output_file, index=False)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此处省略输出结果。  </p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/01/23/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E4%B9%8BCSV%E6%96%87%E4%BB%B6(4)/">
                Python数据分析基础之CSV文件(4)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-01-23</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <p>&emsp;&emsp;有些时候，我们也并不需要文件中所有的列。有两种方法可以在CSV文件中选取特定的列：<br>&emsp;&emsp;1.使用列索引值；<br>&emsp;&emsp;2.使用列标题。  </p>
<h2 id="使用列索引值"><a href="#使用列索引值" class="headerlink" title="使用列索引值"></a>使用列索引值</h2><h4 id="1-基础Python"><a href="#1-基础Python" class="headerlink" title="1.基础Python"></a>1.基础Python</h4><p>&emsp;&emsp;举个例子，在之前的CSV文件中，我们只想保留供应商姓名和成本这两列，使用Python编辑代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import csv</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">my_columns = [0, 3]</span><br><span class="line">with open(input_file, &apos;r&apos;, newline=&apos;&apos;) as csv_in_file:</span><br><span class="line">    with open(output_file, &apos;w&apos;, newline=&apos;&apos;) as csv_out_file:</span><br><span class="line">        filereader = csv.reader(csv_in_file)</span><br><span class="line">        filewriter = csv.writer(csv_out_file)</span><br><span class="line">        for row_list in filereader:</span><br><span class="line">            row_list_output = []</span><br><span class="line">            for index_value in my_columns:</span><br><span class="line">                row_list_output.append(row_list[index_value])</span><br><span class="line">            filewriter.writerow(row_list_output)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们来解释一下上面的代码。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_columns = [0, 3]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这行代码创建了一个列表变量<code>my_columns</code>，其中包含了想要保留的两列的索引值，分别对应供应商姓名和成本两列。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for row_list in filereader:</span><br><span class="line">    row_list_output = []</span><br><span class="line">    for index_value in my_columns:</span><br><span class="line">        row_list_output.append(row_list[index_value])</span><br><span class="line">    filewriter.writerow(row_list_output)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这个<code>for</code>循环中，首先创建了一个空列表变量<code>row_list_output</code>，保存每行中想要保留的值。在内层的<code>for</code>循环语句中，在<code>my_columns</code>中的各个索引值之间进行迭代，通过<code>append()</code>函数使用每行中<code>my_columns</code>索引位置的值为<code>row_list_output</code>填充元素。这几行代码生成了一个列表，其中包含了每行中要写入输出文件的值。<code>filewriter</code>的<code>writerow()</code>方法需要一个字符串序列或数值序列，而列表<code>row_list_out</code>正是一个字符串序列。<br>&emsp;&emsp;第一次循环时，<code>index_value</code>等于0，<code>append()</code>函数将<code>row[0]</code>加入<code>row_list_output</code>。此后，代码回到<code>for index_value ...</code>行，此时<code>index_value</code>等于3，<code>append()</code>函数将<code>row[3]</code>加入<code>row_list_output</code>。这时，内层<code>for</code>循环结束，代码前进到最后一行，<code>writerow()</code>将<code>row_list_output</code>中的列表值写入输出文件。然后，代码回到外层<code>for</code>循环，开始处理输入文件中的下一行。<br>&emsp;&emsp;我们在命令行窗口中运行这个脚本，并打开输出文件查看结果。<br><img src="https://img-blog.csdnimg.cn/20200123175303606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="2-pandas"><a href="#2-pandas" class="headerlink" title="2.pandas"></a>2.pandas</h4><p>&emsp;&emsp;使用pandas模块的代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import pandas as pd</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">data_frame = pd.read_csv(input_file)</span><br><span class="line">data_frame_column_by_index = data_frame.iloc[:, [0, 3]]</span><br><span class="line">data_frame_column_by_index.to_csv(output_file, index=False)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上述代码中，<code>iloc</code>函数根据索引位置选取列。<br>&emsp;&emsp;此处省略输出结果。  </p>
<h2 id="使用列标题"><a href="#使用列标题" class="headerlink" title="使用列标题"></a>使用列标题</h2><p>&emsp;&emsp;当想保留的列的标题非常容易识别，或者在处理多个输入文件时，各个输入文件中列的位置会发生改变，但标题不变的时候，使用列标题来选取特定的列的方法非常有效。  </p>
<h4 id="1-基础Python-1"><a href="#1-基础Python-1" class="headerlink" title="1.基础Python"></a>1.基础Python</h4><p>&emsp;&emsp;举个例子，在前面的CSV文件中，我们只想保留发票号码和购买日期两列，代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import csv</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">my_columns = [&apos;Invoice Number&apos;, &apos;Purchase Date&apos;]</span><br><span class="line">my_columns_index = []</span><br><span class="line">with open(input_file, &apos;r&apos;, newline=&apos;&apos;) as csv_in_file:</span><br><span class="line">    with open(output_file, &apos;w&apos;, newline=&apos;&apos;) as csv_out_file:</span><br><span class="line">        filereader = csv.reader(csv_in_file)</span><br><span class="line">        filewriter = csv.writer(csv_out_file)</span><br><span class="line">        header = next(filereader, None)</span><br><span class="line">        for index_value in range(len(header)):</span><br><span class="line">            if header[index_value] in my_columns:</span><br><span class="line">                my_columns_index.append(index_value)</span><br><span class="line">        filewriter.writerow(my_columns)</span><br><span class="line">        for row_list in filereader:</span><br><span class="line">            row_list_output = []</span><br><span class="line">            for index_value in my_columns_index:</span><br><span class="line">                row_list_output.append(row_list[index_value])</span><br><span class="line">            filewriter.writerow(row_list_output)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们来解释一下上面的代码。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_columns = [&apos;Invoice Number&apos;, &apos;Purchase Date&apos;]</span><br><span class="line">my_columns_index = []</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里创建了一个列表变量<code>my_columns</code>，其中包含的两个字符串即要保留的两列的名字。下面创建的空列表变量<code>my_columns_index</code>要使用两个保留列的索引值来填充。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header = next(filereader, None)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这行代码使用<code>next()</code>函数从输入文件中读取第一行，并保存在列表变量<code>header</code>中。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for index_value in range(len(header)):</span><br><span class="line">    if header[index_value] in my_columns:</span><br><span class="line">        my_columns_index.append(index_value)</span><br><span class="line">filewriter.writerow(my_columns)</span><br><span class="line">for row_list in filereader:</span><br><span class="line">    row_list_output = []</span><br><span class="line">    for index_value in my_columns_index:</span><br><span class="line">        row_list_output.append(row_list[index_value])</span><br><span class="line">    filewriter.writerow(row_list_output)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这几行代码与上一种方法的代码思路类似，在此不再赘述。<br>&emsp;&emsp;在命令行窗口中运行这个脚本，并打开输出文件查看结果。<br><img src="https://img-blog.csdnimg.cn/20200123182213177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="2-pandas-1"><a href="#2-pandas-1" class="headerlink" title="2.pandas"></a>2.pandas</h4><p>&emsp;&emsp;使用pandas模块的代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import pandas as pd</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">data_frame = pd.read_csv(input_file)</span><br><span class="line">data_frame_column_by_name = data_frame.loc[:, [&apos;Invoice Number&apos;, &apos;Purchase Date&apos;]]</span><br><span class="line">data_frame_column_by_name.to_csv(output_file, index=False)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上面的代码中，使用<code>loc</code>函数来选取列。<br>&emsp;&emsp;此处省略输出结果。  </p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/01/20/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E4%B9%8BCSV%E6%96%87%E4%BB%B6(3)/">
                Python数据分析基础之CSV文件(3)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-01-20</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <p>&emsp;&emsp;这一节主要讲一下在读写CSV文件时筛选特定的行。<br>&emsp;&emsp;有些时候，我们并不需要文件中所有的数据。例如，我们可能只需要一个包含特定词或数字的行的子集，或者是与某个具体日期关联的行的子集。在这些情况下，我们可以用Python筛选出特定的行来使用。<br>&emsp;&emsp;下面主要来讲在输入文件中筛选出特定行的3种方法：<br>&emsp;&emsp;1.行中的值满足某个条件；<br>&emsp;&emsp;2.行中的值属于某个集合；<br>&emsp;&emsp;3.行中的值匹配于某个模式（正则表达式）。<br>&emsp;&emsp;其实，这三种筛选方法的代码在结构上是一致的。通用结构如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for row in filereader:</span><br><span class="line">    ***if value in row meets some business rule or set of rules:***</span><br><span class="line">        do something</span><br><span class="line">    else:</span><br><span class="line">        do something else</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;下面我们来详细讨论一下上述3种方法。  </p>
<h2 id="行中的值满足某个条件"><a href="#行中的值满足某个条件" class="headerlink" title="行中的值满足某个条件"></a>行中的值满足某个条件</h2><h4 id="1-基础Python"><a href="#1-基础Python" class="headerlink" title="1.基础Python"></a>1.基础Python</h4><p>&emsp;&emsp;在之前的样例中，如果我们只想保留供应商名字为Supplier Z或成本大于$600.00的行，并将结果写入输出文件。代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import csv</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">with open(input_file, &apos;r&apos;, newline=&apos;&apos;) as csv_in_file:</span><br><span class="line">    with open(output_file, &apos;w&apos;, newline=&apos;&apos;) as csv_out_file:</span><br><span class="line">        filereader = csv.reader(csv_in_file)</span><br><span class="line">        filewriter = csv.writer(csv_out_file)</span><br><span class="line">        header = next(filereader)</span><br><span class="line">        filewriter.writerow(header)</span><br><span class="line">        for row_list in filereader:</span><br><span class="line">            supplier = str(row_list[0]).strip()</span><br><span class="line">            cost = str(row_list[3]).strip(&apos;$&apos;).replace(&apos;,&apos;, &apos;&apos;)</span><br><span class="line">            if supplier == &apos;Supplier Z&apos; or float(cost) &gt; 600.0:</span><br><span class="line">                filewriter.writerow(row_list)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们来解释一下上面的代码。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">header = next(filereader)</span><br><span class="line">filewriter.writerow(header)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这两行代码使用csv模块的<code>next()</code>函数读出输入文件的第一行，赋给列表变量<code>header</code>，并且使用<code>writerow()</code>函数将标题行写入输出文件。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supplier = str(row_list[0]).strip()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这行代码取出每行数据中的供应商名字，赋给变量<code>supplier</code>。这行代码使用列表索引取出每行数据的第一个值<code>row[0]</code>，使用<code>str()</code>函数将其转换为一个字符串，再使用<code>strip()</code>函数删除字符串两端的空格、制表符和换行符。最后，将处理好的字符串赋给变量<code>supplier</code>。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cost = str(row_list[3]).strip(&apos;$&apos;).replace(&apos;,&apos;, &apos;&apos;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这行代码取出每行数据中的成本，赋给变量<code>cost</code>。这行代码使用列表索引取出每行数据的第四个值<code>row[3]</code>，使用<code>str()</code>函数将其转换为一个字符串，再使用<code>strip(&#39;$&#39;)</code>函数从字符串中删除<code>$</code>符号，再使用<code>replace()</code>函数从字符串中删除逗号。最后，将处理好的字符串赋给变量<code>cost</code>。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if supplier == &apos;Supplier Z&apos; or float(cost) &gt; 600.0:</span><br><span class="line">    filewriter.writerow(row_list)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这两行代码通过创建<code>if</code>语句来检验每行中的这两个值是否满足条件，若条件满足，则使用<code>filewriter</code>的<code>writerow()</code>函数将其写入输出文件。<br>&emsp;&emsp;我们在命令行窗口运行这个脚本。在窗口中没有任何输出，我们可以打开输出文件来查看结果。<br><img src="https://img-blog.csdnimg.cn/20200120205540611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="2-pandas"><a href="#2-pandas" class="headerlink" title="2.pandas"></a>2.pandas</h4><p>&emsp;&emsp;pandas模块提供了一个<code>loc</code>函数，它可以同时选择特定的行与列。使用pandas模块的代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import pandas as pd</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">data_frame = pd.read_csv(input_file)</span><br><span class="line">data_frame[&apos;Cost&apos;] = data_frame[&apos;Cost&apos;].str.strip(&apos;$&apos;).astype(float)</span><br><span class="line">data_frame_value_meets_condition = data_frame.loc[(data_frame[&apos;Supplier Name&apos;].str.contains(&apos;Z&apos;))</span><br><span class="line">                                                  | (data_frame[&apos;Cost&apos;] &gt; 600.0), :]</span><br><span class="line">data_frame_value_meets_condition.to_csv(output_file, index=False)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们在命令行窗口运行这个脚本，同样地，在屏幕上我们看不到任何输出，我们可以打开输出文件查看结果。<br>&emsp;&emsp;此处省略输出结果。  </p>
<h2 id="行中的值属于某个集合"><a href="#行中的值属于某个集合" class="headerlink" title="行中的值属于某个集合"></a>行中的值属于某个集合</h2><p>&emsp;&emsp;有些时候，当行中的值属于某个集合时，才需要保留这些行。例如，我们希望在数据集中保留那些供应商名字属于集合<code>{Supplier X, Supplier Y}</code>的行，或者希望保留所有购买日期属于集合<code>{&#39;1/20/2014&#39;, &#39;1/30/2014&#39;}</code>的行。在这种情况下，我们可以检验行中的值是否属于某个集合，筛选出具有属于该集合的行。  </p>
<h4 id="1-基础Python-1"><a href="#1-基础Python-1" class="headerlink" title="1.基础Python"></a>1.基础Python</h4><p>&emsp;&emsp;代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import csv</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">important_dates = [&apos;1/20/2014&apos;, &apos;1/30/2014&apos;]</span><br><span class="line">with open(input_file, &apos;r&apos;, newline=&apos;&apos;) as csv_in_file:</span><br><span class="line">    with open(output_file, &apos;w&apos;, newline=&apos;&apos;) as csv_out_file:</span><br><span class="line">        filereader = csv.reader(csv_in_file)</span><br><span class="line">        filewriter = csv.writer(csv_out_file)</span><br><span class="line">        header = next(filereader)</span><br><span class="line">        filewriter.writerow(header)</span><br><span class="line">        for row_list in filereader:</span><br><span class="line">            a_date = row_list[4]</span><br><span class="line">            if a_date in important_dates:</span><br><span class="line">                filewriter.writerow(row_list)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们来讨论一下上述代码。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">important_dates = [&apos;1/20/2014&apos;, &apos;1/30/2014&apos;]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这行代码创建了一个名为<code>important_dates</code>的列表变量，其中包含了两个特定日期。这个列表变量就是我们的集合。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a_date = row_list[4]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这行代码取出每一行的购买日期，并赋给变量<code>a_date</code>。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if a_date in important_dates:</span><br><span class="line">    filewriter.writerow(row_list)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这行代码创建了一个<code>if</code>语句来检验变量<code>a_date</code>中的购买日期是否属于集合<code>important_date</code>，如果变量值在集合中，下一行代码就将这一行写入输出文件。<br>&emsp;&emsp;我们在命令行窗口中运行这个脚本，并打开输出文件来查看结果。<br><img src="https://img-blog.csdnimg.cn/20200120211035351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="2-pandas-1"><a href="#2-pandas-1" class="headerlink" title="2.pandas"></a>2.pandas</h4><p>&emsp;&emsp;使用pandas模块的代码如下所示：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import pandas as pd</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">data_frame = pd.read_csv(input_file)</span><br><span class="line">important_dates = [&apos;1/20/2014&apos;, &apos;1/30/2014&apos;]</span><br><span class="line">data_frame_value_in_set = data_frame.loc[data_frame[&apos;Purchase Date&apos;].isin(important_dates), :]</span><br><span class="line">data_frame_value_in_set.to_csv(output_file, index=False)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里的输出结果和上面基础Python方法的输出结果一致，故省略。  </p>
<h2 id="行中的值匹配于某个模式（正则表达式）"><a href="#行中的值匹配于某个模式（正则表达式）" class="headerlink" title="行中的值匹配于某个模式（正则表达式）"></a>行中的值匹配于某个模式（正则表达式）</h2><p>&emsp;&emsp;有些时候，当行中的值匹配或包含一个特定模式（正则表达式）时，才需要保留这些行。例如，我们希望在数据集中保留所有发票开始于“001-”的行，或者希望保留所有供应商名字中包含“Y”的行。在这种情况下，我们可以检验行中的值是否匹配或包含某种模式，然后筛选出匹配或包含该模式的行。  </p>
<h4 id="1-基础Python-2"><a href="#1-基础Python-2" class="headerlink" title="1.基础Python"></a>1.基础Python</h4><p>&emsp;&emsp;代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import csv</span><br><span class="line">import re</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">pattern = re.compile(r&apos;(?P&lt;my_pattern_group&gt;^001-.*)&apos;, re.I)</span><br><span class="line">with open(input_file, &apos;r&apos;, newline=&apos;&apos;) as csv_in_file:</span><br><span class="line">    with open(output_file, &apos;w&apos;, newline=&apos;&apos;) as csv_out_file:</span><br><span class="line">        filereader = csv.reader(csv_in_file)</span><br><span class="line">        filewriter = csv.writer(csv_out_file)</span><br><span class="line">        header = next(filereader)</span><br><span class="line">        filewriter.writerow(header)</span><br><span class="line">        for row_list in filereader:</span><br><span class="line">            invoice_number = row_list[1]</span><br><span class="line">            if pattern.search(invoice_number):</span><br><span class="line">                filewriter.writerow(row_list)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们来讨论一下上述代码。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这一行代码导入了re模块，也就是正则表达式模块。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(r&apos;(?P&lt;my_pattern_group&gt;^001-.*)&apos;, re.I)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这行代码使用re模块的<code>compile()</code>函数创建变量<code>pattern</code>。其中<code>r</code>表示将单引号之间的模式当作原始字符串来处理。元字符<code>?P&lt;my_pattern_group&gt;</code>捕获了名为<code>&lt;my_pattern_group&gt;</code>的组中匹配了的字符串，以便在需要的时候将它们打印到屏幕或写入文件。这里要搜索的实际模式是<code>^001-.*</code>。插入符号<code>^</code>表示只在字符串开头搜索模式，<code>*</code>表示重复前面的字符0次或更多次，<code>.*</code>组合在一起使用表示除换行符<code>\n</code>之外的任意字符可以在“001-”后面出现任意次。最后，参数<code>re.I</code>告诉了正则表达式进行大小写敏感的匹配。<br>&emsp;&emsp;有关正则表达式的内容，可以参考我之前写的博客：<a href="https://blog.csdn.net/qq_45554010/article/details/104022260" target="_blank" rel="noopener">Python与正则表达式</a>。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if pattern.search(invoice_number):</span><br><span class="line">    filewriter.writerow(row_list)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里使用re模块的<code>search()</code>函数在<code>invoice_number</code>的值中寻找模式，如果模式出现在变量值中，就将这行写入输出文件。<br>&emsp;&emsp;我们在命令行窗口运行这个脚本，得到输出文件如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200120212816274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="2-pandas-2"><a href="#2-pandas-2" class="headerlink" title="2.pandas"></a>2.pandas</h4><p>&emsp;&emsp;使用pandas模块的代码如下所示：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import pandas as pd</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">data_frame = pd.read_csv(input_file)</span><br><span class="line">data_frame_value_matches_pattern = data_frame.loc[data_frame[&apos;Invoice Number&apos;].str.startswith(&quot;001-&quot;), :]</span><br><span class="line">data_frame_value_matches_pattern.to_csv(output_file, index=False)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上述代码中，<code>startswith()</code>函数用来搜索数据，不用再使用正则表达式。<br>&emsp;&emsp;这里的输出结果和上面基础Python方法的输出结果一致，故省略。  </p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/01/19/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E4%B9%8BCSV%E6%96%87%E4%BB%B6(2)/">
                Python数据分析基础之CSV文件(2)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-01-19</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="基本字符串分析的失败"><a href="#基本字符串分析的失败" class="headerlink" title="基本字符串分析的失败"></a>基本字符串分析的失败</h2><p>&emsp;&emsp;在上一节我们讲了使用Python对CSV文件进行读写。事实上，当列中包含额外的逗号时，CSV分析会失败。<br>&emsp;&emsp;我们打开supplier_data.csv，将Cost列中的最后两个成本数量分别改为$6,015.00和$1,006,015.00，如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200119164515385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">&emsp;&emsp;之前的脚本是按照行中的逗号分析每行数据的，这会让脚本错误地拆分最后两行的数据，因为数据中有逗号。<br>&emsp;&emsp;有很多方法可以改进这个脚本中的代码，使它可以正确地处理包含逗号的数值。我们可以使用正则表达式，但为了不使脚本复杂化，我们可以使用Python内置的csv模块。这个模块可以方便灵活地处理复杂的CSV文件。  </p>
<h2 id="修改后的脚本读写CSV文件"><a href="#修改后的脚本读写CSV文件" class="headerlink" title="修改后的脚本读写CSV文件"></a>修改后的脚本读写CSV文件</h2><p>&emsp;&emsp;使用Python内置的csv模块处理CSV文件的一个优点是，这个模块就是被设计用于正确处理数据值中的嵌入逗号和其他复杂模式的，它可以识别出这些模式并正确地处理数据。<br>&emsp;&emsp;修改后的代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import csv</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">with open(input_file, &apos;r&apos;, newline=&apos;&apos;) as csv_in_file:</span><br><span class="line">    with open(output_file, &apos;w&apos;, newline=&apos;&apos;) as csv_out_file:</span><br><span class="line">        filereader = csv.reader(csv_in_file, delimiter=&apos;,&apos;)</span><br><span class="line">        filewriter = csv.writer(csv_out_file, delimiter=&apos;,&apos;)</span><br><span class="line">        for row_list in filereader:</span><br><span class="line">            print(row_list)</span><br><span class="line">            filewriter.writerow(row_list)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们来解释一下上面的代码。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import csv</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这行代码导入csv模块，以便可以使用其中的函数来分析输入文件，写入输入文件。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filereader = csv.reader(csv_in_file, delimiter=&apos;,&apos;)</span><br><span class="line">filewriter = csv.writer(csv_out_file, delimiter=&apos;,&apos;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这两行代码使用csv模块中的<code>reader()</code>函数和<code>writer()</code>函数分别创建了一个文件读取对象<code>filereader</code>和文件写入对象<code>filewriter</code>。这两个函数中的第二个参数<code>delimiter=&#39;,&#39;</code>是默认分隔符，如果输入文件和输出文件都是用逗号分隔的，就不需要指定这个参数。这里指定分隔符函数，是为了防备待处理的输入文件或要写入的输出文件具有不同的分隔符，例如分号<code>;</code>或制表符<code>\t</code>。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filewriter.writerow(row_list)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这行代码使用<code>filewriter</code>对象的<code>writerow()</code>函数来将每行中的列表值写入输出文件。<br>&emsp;&emsp;我们在命令行窗口运行这个脚本，如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200119170337420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200119170405927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/01/19/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E4%B9%8BCSV%E6%96%87%E4%BB%B6(1)/">
                Python数据分析基础之CSV文件(1)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-01-19</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <blockquote>
<p>参考资料：<br>《Python数据分析基础》，作者[美]Clinton W. Brownley，译者陈光欣，中国工信出版集团，人民邮电出版社</p>
</blockquote>
<h2 id="CSV文件简述"><a href="#CSV文件简述" class="headerlink" title="CSV文件简述"></a>CSV文件简述</h2><p>&emsp;&emsp;CSV（comma-separated value，逗号分隔值）文件格式是一种非常简单的<strong>数据存储与分享</strong>方式。CSV文件将数据表格存储为纯文本，表格（或电子表格）中的每个单元格都是一个数值或字符串。与Excel文件相比，CSV文件的一个主要优点是<strong>有很多程序可以存储、转换和处理纯文本文件</strong>；相比之下，能够处理Excel文件的程序却不多。<br>&emsp;&emsp;当我们使用CSV文件时，确实会失去某些Excel功能：在Excel电子表格中，每个单元格都有一个定义好的“类型”，<strong>CSV文件中的单元格则只是原始数据</strong>。使用CSV文件的另一个问题是<strong>它只能保存数据而不能保存公式</strong>。  </p>
<h2 id="CSV文件初体验"><a href="#CSV文件初体验" class="headerlink" title="CSV文件初体验"></a>CSV文件初体验</h2><p>&emsp;&emsp;我们打开一个电子表格，向其中加入数据，如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200119001909232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">&emsp;&emsp;把文件保存在合适的位置。我们用记事本来打开这个文件，如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200119002141811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">&emsp;&emsp;可以看到，supplier_data.csv确实是纯文本文件。  </p>
<h2 id="用Python读写CSV文件"><a href="#用Python读写CSV文件" class="headerlink" title="用Python读写CSV文件"></a>用Python读写CSV文件</h2><h4 id="1-基础Python，不使用csv模块"><a href="#1-基础Python，不使用csv模块" class="headerlink" title="1.基础Python，不使用csv模块"></a>1.基础Python，不使用csv模块</h4><p>&emsp;&emsp;我们新建一个Python脚本，命名为<code>1csv_read_with_simple_parsing_and_write.py</code>。输入以下代码：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">with open(input_file, &apos;r&apos;, newline=&apos;&apos;) as filereader:</span><br><span class="line">    with open(output_file, &apos;w&apos;, newline=&apos;&apos;) as filewriter:</span><br><span class="line">        header = filereader.readline()</span><br><span class="line">        header = header.strip()</span><br><span class="line">        header_list = header.split(&apos;,&apos;)</span><br><span class="line">        print(header_list)</span><br><span class="line">        filewriter.write(&apos;,&apos;.join(map(str, header_list)) + &apos;\n&apos;)</span><br><span class="line">        for row in filereader:</span><br><span class="line">            row = row.strip()</span><br><span class="line">            row_list = row.split(&apos;,&apos;)</span><br><span class="line">            print(row_list)</span><br><span class="line">            filewriter.write(&apos;,&apos;.join(map(str, row_list)) + &apos;\n&apos;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;下面我们来解释一下上面的代码。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这一行称为shebang行。在Python脚本中，我们应该一直把它作为第一行。以<code>#</code>开头的行为单行注释，在Windows系统中，计算机不读取也不执行这一行代码。但是，安装了Unix系统的计算机使用这一行来找到执行文件中代码的Python版本。加入这一行可以使脚本在不同操作系统的计算机之间具有可移植性。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这两行代码使用sys模块的argv参数，它是一个传递给Python脚本的命令行参数列表，也就是当你运行脚本时在命令行输入的内容。在argv这个特殊的列表中，第一个元素<code>argv[0]</code>用做脚本名称，<code>argv[1]</code>则用作CSV输入文件的路径和文件名，<code>argv[2]</code>用作CSV输出文件的路径和文件名。在上面的代码中，<code>argv[1]</code>和<code>argv[2]</code>被分别赋值给变量<code>input_file</code>和<code>output_file</code>。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(input_file, &apos;r&apos;, newline=&apos;&apos;) as filereader:</span><br><span class="line">    with open(output_file, &apos;w&apos;, newline=&apos;&apos;) as filewriter:</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里的<code>with</code>语句可以在语句结束时自动关闭文件对象。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">header = filereader.readline()</span><br><span class="line">header = header.strip()</span><br><span class="line">header_list = header.split(&apos;,&apos;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里使用了文件对象的<code>readline</code>方法读取输入文件中的第一行数据。第一行是标题行，读入后将其作为字符串赋给变量<code>header</code>。<code>strip()</code>去掉了<code>header</code>字符串两端的空格、制表符和换行符。接下来使用<code>split(&#39;,&#39;)</code>将字符串用逗号拆分成列表并赋给变量<code>header_list</code>，列表中的每个值都是一个列标题。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filewriter.write(&apos;,&apos;.join(map(str, header_list)) + &apos;\n&apos;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这行代码使用<code>filewriter</code>对象的<code>write()</code>方法将<code>header_list</code>中的每个值写入输出文件。<code>map()</code>函数将<code>str()</code>函数应用于<code>header_list</code>中的每个元素，确保每个元素都是字符串。<code>join()</code>函数在<code>header_list</code>中的每个值之间插入一个逗号，将这个列表转换为一个字符串。在此之后，在这个字符串最后添加一个换行符<code>\n</code>。<code>filewriter</code>对象将这个字符串写入输出文件，作为输出文件的第一行。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for row in filereader:</span><br><span class="line">    row = row.strip()</span><br><span class="line">    row_list = row.split(&apos;,&apos;)</span><br><span class="line">    print(row_list)</span><br><span class="line">    filewriter.write(&apos;,&apos;.join(map(str, row_list)) + &apos;\n&apos;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里创建了一个for循环，在输入文件剩余的各行中迭代。<code>strip()</code>除去每行字符串两端的空格、换行符和制表符。<code>split(&#39;,&#39;)</code>用逗号将字符串拆分成一个列表并赋给变量<code>row_list</code>，列表中的每个值都是这行中某一列的值。最后，将这些值打印到屏幕上并写入输出文件。<br>&emsp;&emsp;我们在命令行窗口运行这个脚本，如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200119082504658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">&emsp;&emsp;输入文件的所有行都被打印到了屏幕上，也被写入了输出文件。<br><img src="https://img-blog.csdnimg.cn/20200119082658257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="2-使用pandas模块"><a href="#2-使用pandas模块" class="headerlink" title="2.使用pandas模块"></a>2.使用pandas模块</h4><p>&emsp;&emsp;使用pandas模块处理CSV文件的代码如下所示：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line">data_frame = pd.read_csv(input_file)</span><br><span class="line">print(data_frame)</span><br><span class="line">data_frame.to_csv(output_file, index=False)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里我们创建了一个变量<code>data_frame</code>，这种数据方式叫做<strong>数据框</strong>。数据框中保留了“表格”这种组织方式，不需要使用列表套列表的方式来分析数据。数据框包含在pandas中，如果我们没有在脚本中导入pandas模块，就不能使用数据框。<br>&emsp;&emsp;在学习阶段，将这个变量命名为<code>data_frame</code>是可以的，但是以后，我们应该使用更有描述性的变量名。<br>&emsp;&emsp;我们在命令行窗口运行这个脚本，如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200119083552160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200119083641933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/01/17/Python%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">
                Python与正则表达式
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-01-17</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <blockquote>
<p>参考资料：<br>1.菜鸟教程-Python 3 正则表达式，网址：<a href="https://www.runoob.com/python3/python3-reg-expressions.html" target="_blank" rel="noopener">https://www.runoob.com/python3/python3-reg-expressions.html</a><br>2.《Python从小白到大牛》，作者关东升，清华大学出版社<br>3.《Python数据分析基础》，作者[美]Clinton W. Brownley，译者陈光欣，中国工信出版集团，人民邮电出版社</p>
</blockquote>
<h2 id="简述正则表达式"><a href="#简述正则表达式" class="headerlink" title="简述正则表达式"></a>简述正则表达式</h2><p>&emsp;&emsp;正则表达式（Regular Expression）是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。在Python中，正则表达式的应用非常广泛，如数据挖掘、数据分析、网络爬虫、输入有效性验证等。<br>&emsp;&emsp;re模块使Python拥有全部的正则表达式功能。我们使用下面的语句来导入该模块：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br></pre></td></tr></table></figure>
<h2 id="正则表达式字符串"><a href="#正则表达式字符串" class="headerlink" title="正则表达式字符串"></a>正则表达式字符串</h2><p>&emsp;&emsp;正则表达式字符串由普通字符和元字符组成。<br>&emsp;&emsp;普通字符是按照字符字面意义表示的字符。元字符是预先定义好的一些特殊字符，如<code>\w+</code>和<code>\.</code>都属于元字符。<br>&emsp;&emsp;下面是一些基本元字符：<br>字符|说明<br>——|——<br>\|转义符号<br>.|表示任意一个字符<br>+|表示重复一次或多次<br>*|表示重复零次或多次<br>?|表示重复零次或一次<br>||选择符号，表示“或”<br>{}|定义量词<br>[]|定义字符类<br>()|定义分组<br>^|表示取反，或匹配一行的开始<br>$|匹配一行的结束<br>&emsp;&emsp;上面提到了元字符<code>^</code>和<code>$</code>，它们可以匹配一行字符串的开始和结束。当以<code>^</code>开始时，要求一行字符串的开始位置匹配；当以<code>$</code>位置结束时，要求一行字符串的结束位置匹配。需要注意的是，正则表达式<code>\w+@qq\.com</code>和<code>^\w+@qq\.com$</code>是不同的。<br>&emsp;&emsp;定义字符类需要使用元字符<code>[]</code>。例如说我们想在输入的字符串中匹配Python或python，则可以使用正则表达式<code>[Pp]ython</code>。<br>&emsp;&emsp;在正则表达式中指定不想出现的字符，可以在字符类之前加<code>^</code>符号进行字符类取反。比如说，正则表达式<code>[^0123456789]</code>表示输入的字符串中出现非0~9数字即匹配，也就是出现在<code>[0123456789]</code>之外的任意字符即匹配。<br>&emsp;&emsp;上面所说的正则表达式<code>[^0123456789]</code>写起来非常麻烦。事实上，我们引入区间的概念之后，这种连续的字符可以使用区间来表示。区间使用连字符<code>-</code>表示。例如<code>[0123456789]</code>可以采用区间表示为<code>[0-9]</code>，<code>[^0123456789]</code>可以采用区间表示为<code>[^0-9]</code>。区间也可以表示连续的英文字母字符类，例如<code>[a-z]</code>表示所有小写字符类，<code>[A-Z]</code>表示所有大写字母字符类。除此之外，也可以表示多个不同区间，例如<code>[A-Za-z0-9]</code>表示所有字母和数字字符类，<code>[0-36-8]</code>表示0、1、2、3、6、7、8几个数字字符组成的字符类。<br>&emsp;&emsp;正则表达式提供了预定义字符类。预定义字符类如下表所示：<br>字符|说明<br>——|——<br>.|匹配任意一个字符<br>\\|匹配反斜杠\字符<br>\n|匹配换行符<br>\r|匹配回车符<br>\f|匹配一个换页符<br>\t|匹配一个水平制表符<br>\v|匹配一个垂直制表符<br>\s|匹配一个空格符（等价于[\t\n\r\f\v]）<br>\S|匹配一个非空格符（等价于[^\s]）<br>\d|匹配一个数字字符（等价于[0-9]）<br>\D|匹配一个非数字字符（等价于[^0-9]）<br>\w|匹配任何语言的单词字符（包括英文字母、亚洲文字等）、数字和下划线等字符，如果正则表达式编译标志设置为ASCII，则只匹配[a-zA-Z0-9_]<br>\W|等价于[^\w]</p>
<h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><p>&emsp;&emsp;在正则表达式中，元字符只能匹配显示一次字符或字符串。如果想要匹配显示多次字符或字符串，可以使用量词。<br>&emsp;&emsp;正则表达式中的量词如下表所示：<br>字符|说明<br>——|——<br>?|出现零次或一次<br>*|出现零次或多次<br>+|出现一次或多次<br>{n}|出现n次<br>{n,m}|至少出现n次但不超过m次<br>{n,}|至少出现n次<br>&emsp;&emsp;下面是一个量词的使用示例代码：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">m = re.search(r&apos;\d?&apos;, &apos;87654321&apos;)               # 出现数字一次</span><br><span class="line">print(m)                                        # 匹配字符&apos;8&apos;</span><br><span class="line"></span><br><span class="line">m = re.search(r&apos;\d?&apos;, &apos;ABC&apos;)                    # 出现数字零次</span><br><span class="line">print(m)                                        # 匹配字符&apos;&apos;</span><br><span class="line"></span><br><span class="line">m = re.search(r&apos;\d*&apos;, &apos;87654321&apos;)               # 出现数字多次</span><br><span class="line">print(m)                                        # 匹配字符&apos;87654321&apos;</span><br><span class="line"></span><br><span class="line">m = re.search(r&apos;\d*&apos;, &apos;ABC&apos;)                    # 出现数字零次</span><br><span class="line">print(m)                                        # 匹配字符&apos;&apos;</span><br><span class="line"></span><br><span class="line">m = re.search(r&apos;\d+&apos;, &apos;87654321&apos;)               # 出现数字多次</span><br><span class="line">print(m)                                        # 匹配字符&apos;87654321&apos;</span><br><span class="line"></span><br><span class="line">m = re.search(r&apos;\d+&apos;, &apos;ABC&apos;)</span><br><span class="line">print(m)                                        # 不匹配</span><br><span class="line"></span><br><span class="line">m = re.search(r&apos;\d&#123;8&#125;&apos;, &apos;87654321&apos;)             # 出现数字8次</span><br><span class="line">print(m)                                        # 匹配字符&apos;87654321&apos;</span><br><span class="line"></span><br><span class="line">m = re.search(r&apos;\d&#123;8&#125;&apos;, &apos;ABC&apos;)</span><br><span class="line">print(m)                                        # 不匹配</span><br><span class="line"></span><br><span class="line">m = re.search(r&apos;\d&#123;7,8&#125;&apos;, &apos;87654321&apos;)          # 出现数字8次</span><br><span class="line">print(m)                                        # 匹配字符&apos;87654321&apos;</span><br><span class="line"></span><br><span class="line">m = re.search(r&apos;\d&#123;9,&#125;&apos;, &apos;87654321&apos;)</span><br><span class="line">print(m)                                        # 不匹配</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;输出结果如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;re.Match object; span=(0, 1), match=&apos;8&apos;&gt;</span><br><span class="line">&lt;re.Match object; span=(0, 0), match=&apos;&apos;&gt;</span><br><span class="line">&lt;re.Match object; span=(0, 8), match=&apos;87654321&apos;&gt;</span><br><span class="line">&lt;re.Match object; span=(0, 0), match=&apos;&apos;&gt;</span><br><span class="line">&lt;re.Match object; span=(0, 8), match=&apos;87654321&apos;&gt;</span><br><span class="line">None</span><br><span class="line">&lt;re.Match object; span=(0, 8), match=&apos;87654321&apos;&gt;</span><br><span class="line">None</span><br><span class="line">&lt;re.Match object; span=(0, 8), match=&apos;87654321&apos;&gt;</span><br><span class="line">None</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;量词还可以细分为贪婪量词和懒惰量词。贪婪量词会尽可能多地匹配字符，懒惰量词会尽可能少地匹配字符。大多数计算机语言的正则表达式量词默认是贪婪量词，如果要使用懒惰量词，在量词之后加<code>?</code>即可。<br>&emsp;&emsp;下面是一个示例代码：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">m = re.search(r&apos;\d&#123;5,8&#125;&apos;, &apos;87654321&apos;)               # 出现数字8次</span><br><span class="line">print(m)                                            # 匹配字符&apos;87654321&apos;</span><br><span class="line"></span><br><span class="line">m = re.search(r&apos;\d&#123;5,8&#125;?&apos;, &apos;87654321&apos;)              # 出现数字5次</span><br><span class="line">print(m)                                            # 匹配字符&apos;87654&apos;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;输出结果如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;re.Match object; span=(0, 8), match=&apos;87654321&apos;&gt;</span><br><span class="line">&lt;re.Match object; span=(0, 5), match=&apos;87654&apos;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>&emsp;&emsp;量词只能重复显示一个字符，如果想让一个字符串作为整体使用量词，可以将这个字符串放到<code>()</code>中，这就是分组，也被称作子表达式。<br>&emsp;&emsp;下面是一个使用分组的示例代码：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">p = r&apos;(121)&#123;2&#125;&apos;</span><br><span class="line">m = re.search(p, &apos;121121abcabc&apos;)</span><br><span class="line">print(m)                                # 匹配</span><br><span class="line">print(m.group())                        # 返回匹配字符串</span><br><span class="line">print(m.group(1))                       # 获得第一组内容</span><br><span class="line">p = r&apos;(\d&#123;3,4&#125;)-(\d&#123;7,8&#125;)&apos;</span><br><span class="line">m = re.search(p, &apos;010-87654321&apos;)</span><br><span class="line">print(m)                                # 匹配</span><br><span class="line">print(m.group())                        # 返回匹配字符串</span><br><span class="line">print(m.groups())                       # 获得所有组内容</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;输出结果如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;re.Match object; span=(0, 6), match=&apos;121121&apos;&gt;</span><br><span class="line">121121</span><br><span class="line">121</span><br><span class="line">&lt;re.Match object; span=(0, 12), match=&apos;010-87654321&apos;&gt;</span><br><span class="line">010-87654321</span><br><span class="line">(&apos;010&apos;, &apos;87654321&apos;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在Python中访问分组时，除了可以通过组编号访问，还可以通过组名访问。这需要我们在正则表达式中为组命名。组命名通过在组开头添加<code>?P&lt;分组名&gt;</code>实现。<br>&emsp;&emsp;在正则表达式中，反向引用语法是<code>\组编号</code>。组编号从1开始。<br>&emsp;&emsp;前面所说的分组称为捕获分组。捕获分组的子表达式结果被暂时保存到内存中，以备表达式或其他程序通过组编号或组名进行引用。但是有时，我们并不想引用子表达式的匹配结果，不想捕获匹配结果，只是将小括号作为一个整体进行匹配。这个时候我们就可以使用非捕获分组。在组开头使用<code>?:</code>可以实现非捕获分组。  </p>
<h2 id="Python的re模块"><a href="#Python的re模块" class="headerlink" title="Python的re模块"></a>Python的re模块</h2><h4 id="re-search-函数"><a href="#re-search-函数" class="headerlink" title="re.search()函数"></a>re.search()函数</h4><p>&emsp;&emsp;re.search()函数在输入字符串中查找，返回第一个匹配内容，如果找到一个则match对象，如果没有找到则返回None。<br>&emsp;&emsp;函数语法如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.search(pattern, string, flags=0)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;参数说明如下：<br>参数|参数说明<br>——|——<br>pattern|匹配的正则表达式<br>string|要匹配的字符串<br>flags|标志位，用于控制正则表达式的匹配方式，如是否区分大小写，多行匹配等</p>
<h4 id="re-match-函数"><a href="#re-match-函数" class="headerlink" title="re.match()函数"></a>re.match()函数</h4><p>&emsp;&emsp;re.match()函数在输入字符串开始处查找匹配内容，如果找到一个则match对象，如果没有找到则返回None。<br>&emsp;&emsp;函数语法如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.match(pattern, string, flags=0)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;参数说明如下：<br>参数|参数说明<br>——|——<br>pattern|匹配的正则表达式<br>string|要匹配的字符串<br>flags|标志位，用于控制正则表达式的匹配方式，如是否区分大小写，多行匹配等<br>&emsp;&emsp;下面我们简单讨论一下re.search()和re.match()的区别。<br>&emsp;&emsp;re.match()只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；re.search()匹配整个字符串，直到找到一个匹配。<br>&emsp;&emsp;re.search()和re.match()如果匹配成功都返回match对象。下面是match对象的一些常用方法：<br>方法|返回值<br>——|——<br>group()|返回匹配的子字符串<br>start()|返回子字符串的开始索引<br>end()|返回子字符串的结束索引<br>span()|返回子字符串的跨度，它是一个二元素的元组</p>
<h4 id="re-findall-函数"><a href="#re-findall-函数" class="headerlink" title="re.findall()函数"></a>re.findall()函数</h4><p>&emsp;&emsp;re.findall()函数在输入字符串中查找所有匹配内容，如果匹配成功，则返回match列表对象，如果匹配失败则返回None。<br>&emsp;&emsp;函数语法如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.findall(string[, pos[, endpos]])</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;参数说明如下：<br>参数|参数说明<br>——|——<br>string|待匹配的字符串<br>pos|可选参数，指定字符串的起始位置，默认为0<br>endpos|可选参数，指定字符串的结束为止，默认为字符串的长度</p>
<h4 id="re-finditer-函数"><a href="#re-finditer-函数" class="headerlink" title="re.finditer()函数"></a>re.finditer()函数</h4><p>&emsp;&emsp;re.finditer()函数在输入字符串中查找所有匹配内容，如果匹配成功，则返回容纳match的可迭代对象，通过迭代对象每次可以返回一个match对象，如果匹配失败则返回None。<br>&emsp;&emsp;函数语法如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.finditer(pattern, string, flags=0)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;参数说明如下：<br>参数|参数说明<br>——|——<br>pattern|匹配的正则表达式<br>string|要匹配的字符串<br>flags|标志位，用于控制正则表达式的匹配方式，如是否区分大小写，多行匹配等</p>
<h4 id="re-split-函数"><a href="#re-split-函数" class="headerlink" title="re.split()函数"></a>re.split()函数</h4><p>&emsp;&emsp;re.split()函数按照匹配的字符串进行字符串分割，返回字符串列表对象。<br>&emsp;&emsp;函数语法如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.split(pattern, string[, maxsplit=0, flags=0])</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;参数说明如下：<br>参数|参数说明<br>——|——<br>pattern|匹配的正则表达式<br>string|要匹配的字符串<br>maxsplit|分割次数，默认为0，不限制次数<br>flags|标志位，用于控制正则表达式的匹配方式，如是否区分大小写，多行匹配等</p>
<h4 id="re-sub-函数"><a href="#re-sub-函数" class="headerlink" title="re.sub()函数"></a>re.sub()函数</h4><p>&emsp;&emsp;re.sub()函数用于替换匹配的子字符串，返回替换之后的字符串。<br>&emsp;&emsp;函数语法如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.sub(pattern, repl, string, count=0, flags=0)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;参数说明如下：<br>参数|参数说明<br>——|——<br>patern|正则中的模式字符串<br>repl|替换的字符串，也可为一个函数<br>string|要被查找替换的原始字符串<br>count|模式匹配后替换的最大次数，默认为0，表示替换所有的匹配<br>flags|编译时用的匹配模式，数字形式</p>
<h4 id="re-compile-函数"><a href="#re-compile-函数" class="headerlink" title="re.compile()函数"></a>re.compile()函数</h4><p>&emsp;&emsp;re.compile()函数可以编译正则表达式。<br>&emsp;&emsp;函数语法如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.compile(pattern[, flags=0])</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;参数说明如下：<br>参数|参数说明<br>——|——<br>pattern|一个字符串形式的正则表达式<br>flags|可选参数，表示匹配模式，如是否区分大小写，多行匹配等<br>&emsp;&emsp;re.compile()函数返回一个编译的正则表达式对象regex。  </p>
<h4 id="正则表达式修饰符"><a href="#正则表达式修饰符" class="headerlink" title="正则表达式修饰符"></a>正则表达式修饰符</h4><table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>re.I</td>
<td>使匹配对大小写不敏感</td>
</tr>
<tr>
<td>re.L</td>
<td>做本地化识别匹配</td>
</tr>
<tr>
<td>re.M</td>
<td>设置多行模式，多行匹配，影响^和$</td>
</tr>
<tr>
<td>re.S</td>
<td>使.匹配包括换行在内的所有字符</td>
</tr>
<tr>
<td>re.U</td>
<td>根据Unicode字符集解析字符，影响\w, \W, \b, \B</td>
</tr>
<tr>
<td>re.X</td>
<td>设置详细模式，详细模式下可以在正则表达式中添加注释， 可以有空格和换行</td>
</tr>
</tbody></table>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/12/24/%E3%80%90%E7%AE%97%E6%B3%95%E7%A7%AF%E7%B4%AF%E3%80%91%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/">
                【算法积累】最长公共前缀
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-12-24</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>&emsp;&emsp;注：本题来自LeetCode题库14.最长公共前缀。  </p>
<blockquote>
<p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”。</p>
</blockquote>
<p>&emsp;&emsp;示例1：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;示例2：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure>
<h2 id="解法1：字符串排序取首尾公共前缀"><a href="#解法1：字符串排序取首尾公共前缀" class="headerlink" title="解法1：字符串排序取首尾公共前缀"></a>解法1：字符串排序取首尾公共前缀</h2><p>&emsp;&emsp;简单来说，把字符串按字母顺序排序后，首字符串和尾字符串的公共前缀，就是这一组字符串的公共前缀。这种解法用C语言并不是很好实现。因为Python中内置函数min()和max()，在这里我使用Python 3来解决。代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 语言：Python 3</span><br><span class="line"># 执行用时：36ms</span><br><span class="line"># 内存消耗：12.8MB</span><br><span class="line">class Solution:</span><br><span class="line">    def longestCommonPrefix(self, strs: List[str]) -&gt; str:</span><br><span class="line">        if not strs:</span><br><span class="line">            return &quot;&quot;</span><br><span class="line">        strMin = min(strs)</span><br><span class="line">        strMax = max(strs)</span><br><span class="line">        string = []</span><br><span class="line">        for i in range(0, len(strMin)):</span><br><span class="line">            if strMin[i] == strMax[i]:</span><br><span class="line">                string.append(strMin[i])</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line">        return &quot;&quot;.join(string)</span><br></pre></td></tr></table></figure>
<h2 id="解法2：取最短字符串逐个比对"><a href="#解法2：取最短字符串逐个比对" class="headerlink" title="解法2：取最短字符串逐个比对"></a>解法2：取最短字符串逐个比对</h2><p>&emsp;&emsp;上面的解法依赖于Python的内置函数min()和max()。我们换一种思路，取出其中最短的字符串，用它和其他的字符串一一比对，找出公共前缀。<br>&emsp;&emsp;特殊地，如果输入的字符串数组长度为0，则只需返回空字符串“”；如果输入的字符串数组长度为1，则只需返回这个字符串，即strs[0]。<br>&emsp;&emsp;代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 语言：C</span><br><span class="line">// 执行用时：0ms</span><br><span class="line">// 内存消耗：7.1MB</span><br><span class="line">char * longestCommonPrefix(char ** strs, int strsSize)&#123;</span><br><span class="line">    int strLen = 0;</span><br><span class="line">    char *shortStr = NULL;</span><br><span class="line">    int shortLen = 0;</span><br><span class="line">    int i, j;</span><br><span class="line">    if (strs == NULL || strsSize == 0)</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    if (strs != NULL &amp;&amp; strsSize == 1)</span><br><span class="line">        return strs[0];</span><br><span class="line">    shortStr = strs[0];</span><br><span class="line">    shortLen = strlen(strs[0]);</span><br><span class="line">    for (i = 0; i &lt; strsSize; i++) &#123;</span><br><span class="line">        strLen = strlen(strs[i]);</span><br><span class="line">        if (shortLen &gt; strLen) &#123;</span><br><span class="line">            shortLen = strLen;</span><br><span class="line">            shortStr = strs[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (j = 0; j &lt; shortLen; j++) &#123;</span><br><span class="line">        for (i = 0; i &lt; strsSize; i++) &#123;</span><br><span class="line">            if (strs[i][j] != shortStr[j]) &#123;</span><br><span class="line">                if (j == 0) &#123;</span><br><span class="line">                    return &quot;&quot;;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    shortStr[j] = &apos;\0&apos;;</span><br><span class="line">                    return shortStr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return shortStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解法3：水平扫描法"><a href="#解法3：水平扫描法" class="headerlink" title="解法3：水平扫描法"></a>解法3：水平扫描法</h2><p>&emsp;&emsp;为了便于理解，我截取了LeetCode官方题解中水平扫描法的图解：<br><img src="https://img-blog.csdnimg.cn/20191224152137404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="Alt"><br>&emsp;&emsp;代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">语言：C</span><br><span class="line">执行用时：4ms</span><br><span class="line">内存消耗：7.1MB</span><br><span class="line">char * longestCommonPrefix(char ** strs, int strsSize)&#123;</span><br><span class="line">    int i, j;</span><br><span class="line">    if (strsSize == 0)</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    if (strsSize == 1)</span><br><span class="line">        return strs[0];</span><br><span class="line">    for (i = 0; i &lt; strlen(strs[0]); i++) &#123;</span><br><span class="line">        for (j = 1; j &lt; strsSize; j++)</span><br><span class="line">            if (strs[0][i] != strs[j][i]) &#123;</span><br><span class="line">                strs[0][i] = &apos;\0&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return strs[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解法4：使用Python的os-path模块"><a href="#解法4：使用Python的os-path模块" class="headerlink" title="解法4：使用Python的os.path模块"></a>解法4：使用Python的os.path模块</h2><p>&emsp;&emsp;最后放一个“大招”吧。正所谓“人生苦短，我用Python”，就在Python的os.path模块中，有一个叫做commonprefix()的方法，可以说是为这道题而生。<br>&emsp;&emsp;我们来对os.path.commonprefix()做一下说明。它可以返回list(多个路径)中所有path共有的最长的路径。怎么样，是不是完美适配这道题呢？<br>&emsp;&emsp;还是放一下代码吧，虽然只有短短一行：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 语言：Python 3</span><br><span class="line"># 执行用时：28ms</span><br><span class="line"># 内存消耗：12.7MB</span><br><span class="line">class Solution:</span><br><span class="line">    def longestCommonPrefix(self, strs: List[str]) -&gt; str:</span><br><span class="line">        return os.path.commonprefix(strs)</span><br></pre></td></tr></table></figure>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/12/22/Python%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93/">
                Python编码规范总结
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-12-22</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;有句俗话说得好：“没有规矩，不成方圆。”这句话在计算机编程领域同样适用。大家都知道，每个人编写代码的习惯与风格是不一样的。而代码风格的统一可以带来很多好处，我认为从最直观的角度来说就是增强了代码的可读性。此外，统一代码风格还有更容易发现bug、略微提高性能等好处。<br>&emsp;&emsp;之前曾经读过一篇文章，里面提到这样一句话：“任何一个傻瓜都能写出计算机可以理解的代码，唯有写出人类容易理解的代码，才是优秀的程序员。”这句话对我的影响很深。我是一名大一本科在读学生，在平时的学习中不乏和同学互相讨论研究代码。我说过最多的一句话大概就是：“你这个代码写得太不规范了。”但是从来没有任何一个同学重视这句话，他们甚至会不屑一顾地回复我：“无所谓，又不是不能运行。”<br>&emsp;&emsp;但我认为，在系统学习一门编程语言之前，首先应该学习编码规范，从开始就养成一个良好的习惯，对于以后的学习来说也是有百利而无一害。只有这样，我们才可以编写出可读性高，无论自己和他人都易于理解的代码。  </p>
<h1 id="Python编码规范"><a href="#Python编码规范" class="headerlink" title="Python编码规范"></a>Python编码规范</h1><blockquote>
<p>参考书籍：《Python从小白到大牛》<br>作者：关东升<br>出版社：清华大学出版社<br>ISBN：978-7-302-50933-2<br>除此之外，我还参考了PEP 8编码规范。  </p>
</blockquote>
<h3 id="1-命名规范"><a href="#1-命名规范" class="headerlink" title="1.命名规范"></a>1.命名规范</h3><p>&emsp;&emsp;1.包名：全部小写字母，中间可以由点分隔开，不推荐使用下划线。作为命名空间，包名应该具有唯一性，推荐采用公司或组织域名的倒置。<br>&emsp;&emsp;2.模块名：全部小写字母，如果由多个单词构成，可以用下划线隔开。<br>&emsp;&emsp;3.类名：采用大驼峰法（即每一个单词的首字母都大写）命名。<br>&emsp;&emsp;4.异常名：异常属于类，命名同类命名，但应该使用Error作为后缀。<br>&emsp;&emsp;5.变量名：全部小写字母，如果由多个单词构成，可以用下划线隔开。如果变量应用于模块或函数内部，则变量名可以由单下划线开头；变量类内部私有使用变量名可以双下划线开头。不要命名双下划线开头和结尾的变量，这是Python保留的。另外，避免使用小写L、大写O和大写I作为变量名。<br>&emsp;&emsp;6.函数名和方法名：命名同变量命名。<br>&emsp;&emsp;7.常量名：全部大写字母，如果由多个单词构成，可以用下划线隔开。  </p>
<h3 id="2-注释规范"><a href="#2-注释规范" class="headerlink" title="2.注释规范"></a>2.注释规范</h3><p>&emsp;&emsp;Python中的注释语法有3种，分别是单行注释、多行注释和文档注释。  </p>
<h5 id="2-1-文件注释"><a href="#2-1-文件注释" class="headerlink" title="2.1  文件注释"></a>2.1  文件注释</h5><p>&emsp;&emsp;文件注释就是在每一个文件开头添加注释，采用多行注释。文件注释通常包括如下信息：版权信息、文件名、所在模块、作者信息、历史版本信息、文件内容和作用等。<br>&emsp;&emsp;文件注释要根据实际情况包括内容。  </p>
<h5 id="2-2-文档注释"><a href="#2-2-文档注释" class="headerlink" title="2.2  文档注释"></a>2.2  文档注释</h5><p>&emsp;&emsp;文档注释就是文档字符串，注释内容能够生成API帮助文档，可以使用Python官方提供的pydoc工具从Python源代码文件中提取这些信息，也可以生成HTML文件。所有公有的模块、函数、类和方法都应该进行文档注释。<br>&emsp;&emsp;文档注释推荐使用一对三重双引号“””””包裹起来，注意不推荐使用三重单引号“’’’”。文档注释应该位于被注释的模块、函数、类和方法内部的第一条语句。如果文档注释一行能够注释完成，结束的三重双引号也在同一行。如果文档注释很长，第一行注释之后要留一个空行，然后剩下的注释内容换行要与开始三重双引号对齐，最后结束的三重双引号要独占一行，并与开始三重双引号对齐。  </p>
<h5 id="2-3-代码注释"><a href="#2-3-代码注释" class="headerlink" title="2.3  代码注释"></a>2.3  代码注释</h5><p>&emsp;&emsp;程序代码中处理文档注释时还需要在一些关键的地方添加代码注释，文档注释一般是给一些看不到源代码的人看的帮助文档，而代码注释是给阅读源代码的人参考的。代码注释一般采用单行注释和多行注释。<br>&emsp;&emsp;单行注释和多行注释要求与其后的代码具有一样的缩进级别。尾端进行注释要求注释内容极短，应该再有足够的空白（至少两个空格）来分开代码和注释。  </p>
<h5 id="2-4-使用TODO注释"><a href="#2-4-使用TODO注释" class="headerlink" title="2.4  使用TODO注释"></a>2.4  使用TODO注释</h5><p>&emsp;&emsp;很多IDE工具都为源代码提供了一些特殊的注释，就是在代码中加一些标识，便于IDE工具快速定位代码，TODO注释就是其中的一种。<br>&emsp;&emsp;TODO注释虽然不是Python官方所提供的，但是主流的IDE工具也都支持TODO注释。有TODO注释说明此处有待处理的任务，或代码没有编写完成。<br>&emsp;&emsp;以PyCharm为例，TODO注释可以在PyCharm的TODO视图查看，单击其中的TODO可跳转到注释处。  </p>
<h3 id="3-导入规范"><a href="#3-导入规范" class="headerlink" title="3.导入规范"></a>3.导入规范</h3><p>&emsp;&emsp;导入语句总是放在文件顶部，位于模块注释和文档注释之后，模块全局变量和常量之前。每一个导入语句只能导入一个模块。<br>&emsp;&emsp;推荐：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">import struct</span><br><span class="line">import binascii</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;不推荐：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import re, struct, binascii</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;但是如果from import后面跟有多个代码元素是可以的。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from codeop import CommandCompiler, compile_command</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;导入语句应该按照从通用到特殊的顺序分组，顺序是：标准库→第三方库→自己的模块。每一组之间有一个空行，而且组中模块是按照英文字母顺序排序的。  </p>
<h3 id="4-代码排版"><a href="#4-代码排版" class="headerlink" title="4.代码排版"></a>4.代码排版</h3><p>&emsp;&emsp;代码排版包括空行、空格、断行和缩进等内容。  </p>
<h5 id="4-1-空行"><a href="#4-1-空行" class="headerlink" title="4.1  空行"></a>4.1  空行</h5><p>&emsp;&emsp;空行用以将逻辑相关的代码段分隔开，以提高可读性。<br>&emsp;&emsp;1.import语句块前后保留两个空行。<br>&emsp;&emsp;2.函数声明之前保留两个空行。<br>&emsp;&emsp;3.类声明之前保留两个空行。<br>&emsp;&emsp;4.方法声明之前保留一个空行。<br>&emsp;&emsp;5.两个逻辑代码块之间应该保留一个空行。  </p>
<h5 id="4-2-空格"><a href="#4-2-空格" class="headerlink" title="4.2  空格"></a>4.2  空格</h5><p>&emsp;&emsp;代码中的有些位置是需要有空格的。<br>&emsp;&emsp;1.赋值符号“=”前后各有一个空格。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 10</span><br><span class="line">c = 10</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2.所有的二元运算符都应该使用空格与操作数分开。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a += c + d</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;3.一元运算符：算法运算符取反“-”和运算符取反“~”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b = 10</span><br><span class="line">a = -b</span><br><span class="line">y = ~b</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;4.括号内不要有空格，Python中括号包括小括号“()”、中括号“[]”和大括号“{}”。<br>&emsp;&emsp;推荐：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doque(cat[1], &#123;dogs: 2&#125;, [])</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;不推荐：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doque(cat[ 1 ], &#123; dogs: 2 &#125;, [ ])</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;5.不要在逗号、分号、冒号前面有空格，而是要在它们后面有一个空格，除非该符号已经是行尾了。<br>&emsp;&emsp;推荐：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if x == 88:</span><br><span class="line">    print(x, y)</span><br><span class="line">x, y = y, x</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;不推荐：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if x == 88:</span><br><span class="line">    print(x , y)</span><br><span class="line">x , y = y , x</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;6.参数列表、索引或切片的左括号前不应有空格。<br>&emsp;&emsp;推荐：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">doque(1)</span><br><span class="line">dogs[&apos;key&apos;] = list[index]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;不推荐：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">doque (1)</span><br><span class="line">dict [&apos;key&apos;] = list [index]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;7.如果使用具有不同优先级的运算符，请考虑在具有最低优先级的运算符周围添加空格。有时需要通过自己来判断；但是，不要使用一个以上的空格，并且在二元运算符的两边使用相同数量的空格。  </p>
<h5 id="4-3-缩进"><a href="#4-3-缩进" class="headerlink" title="4.3  缩进"></a>4.3  缩进</h5><p>&emsp;&emsp;4个空格常被作为缩进排版的一个级别。虽然在开发时程序员可以使用制表符进行缩进，而默认情况下一个制表符等于8个空格，但是不同的IDE工具中一个制表符与空格对应个数会有不同，所以不要使用制表符缩进。Python 3不允许同时使用空格和制表符的缩进。<br>&emsp;&emsp;代码块的内容相当于首行缩进一个级别（4个空格）。  </p>
<h5 id="4-4-断行"><a href="#4-4-断行" class="headerlink" title="4.4  断行"></a>4.4  断行</h5><p>&emsp;&emsp;一行代码中最多79个字符，对于文档注释和多行注释时一行最多72个字符，但是如果注视中包含URL地址可以不受这个限制。否则，如果超过则需断行。<br>&emsp;&emsp;1.在逗号后面断开。<br>&emsp;&emsp;2.在运算符前面断开。<br>&emsp;&emsp;3.尽量不要使用续行符“\”，当有括号（包括大括号、中括号和小括号）则在括号中断开，这样可以不使用续行符。有时为了省略续行符，会将表达式用小括号括起来。在括号中，续行是隐式的。<br>&emsp;&emsp;4.反斜杠有时依然很有用。比如，比较长的，多个with状态语句，不能使用隐式续行，所以反斜杠是可以接受。<br>&emsp;&emsp;5.续行应该与其包裹元素对齐，要么使用圆括号、方括号和花括号内的隐式行连接来垂直对齐，要么使用挂行缩进对齐。当使用挂行缩进时，应该考虑到第一行不应该有参数，以及使用缩进以区分自己是续行。四空格的规则对于续行是可选的。挂行缩进不一定要用4个空格。  </p>
<h3 id="5-源文件编码"><a href="#5-源文件编码" class="headerlink" title="5.源文件编码"></a>5.源文件编码</h3><p>&emsp;&emsp;Python核心发布版本中的代码总是以UTF-8格式编码（或者在Python 2中用ASCII编码）。<br>&emsp;&emsp;使用ASCII（在Python 2中）或UTF-8（在Python 3中）编码的文件不应具有编码声明。<br>&emsp;&emsp;在标准库中，非默认的编码应该只用于测试，或者当一个注释或者文档字符串需要提及一个包含内ASCII字符编码的作者名字的时候；否则，使用\x,\u,\U , 或者 \N 进行转义来包含非ASCII字符。<br>&emsp;&emsp;对于Python 3和更高版本，标准库规定了以下策略（参见 PEP 3131）：Python标准库中的所有标识符必须使用ASCII标识符，并在可行的情况下使用英语单词（在许多情况下，缩写和技术术语是非英语的）。此外，字符串文字和注释也必须是ASCII。唯一的例外是测试非ASCII特征的测试用例以及作者的名称。作者的名字如果不使用拉丁字母拼写，必须提供一个拉丁字母的音译。  </p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/12/21/%E3%80%90%E7%AE%97%E6%B3%95%E7%A7%AF%E7%B4%AF%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8E%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/">
                【算法积累】动态规划与斐波那契数列
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-12-21</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>&emsp;&emsp;注：本题来自LeetCode题库70.爬楼梯。  </p>
<blockquote>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>注意：给定 n 是一个正整数。  </p>
</blockquote>
<p>&emsp;&emsp;示例1：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure>
<p> &emsp;&emsp;示例2：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure></p>
<h2 id="解法1：动态规划法"><a href="#解法1：动态规划法" class="headerlink" title="解法1：动态规划法"></a>解法1：动态规划法</h2><p>&emsp;&emsp;不难发现，这个问题可以被分解为一些包含最优子结构的子问题，即它的最优解可以从其子问题的最优解来有效地构建，我们可以使用动态规划来解决这一问题。<br>&emsp;&emsp;假设我们要爬到第n个台阶，则有两种情况：一是爬到第(n-1)个台阶，然后再往上爬1个台阶即可；二是爬到第(n-2)个台阶，然后再往上爬2个台阶即可。也就是说，爬到第n个台阶的方法数，就是爬到第(n-1)个台阶的方法数与爬到第(n-2)个台阶的方法数之和。<br>&emsp;&emsp;特别地，当n=1时，方法数为1；当n=2时，方法数为2（即1+1或直接爬2个台阶）。<br>&emsp;&emsp;代码实现如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 语言：C</span><br><span class="line">// 执行用时：0ms（又是0ms，具体情况未知）</span><br><span class="line">// 内存消耗：6.8MB</span><br><span class="line">int climbStairs(int n)&#123;</span><br><span class="line">    if (n == 1)</span><br><span class="line">        return 1;</span><br><span class="line">    int first, second, third, i;</span><br><span class="line">    first = 1;</span><br><span class="line">    second = 2;</span><br><span class="line">    for (i = 3; i &lt; n + 1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        third = first + second;</span><br><span class="line">        first = second;</span><br><span class="line">        second = third;</span><br><span class="line">    &#125;</span><br><span class="line">    return second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这种解法的时间复杂度为O(n)，空间复杂度为O(n)。  </p>
<h2 id="解法2：斐波那契数列法"><a href="#解法2：斐波那契数列法" class="headerlink" title="解法2：斐波那契数列法"></a>解法2：斐波那契数列法</h2><p>&emsp;&emsp;我们再分析一下解法1，不难发现这其实就是斐波那契数列。所以这道题还可以用斐波那契数列法来解决。下面给出C和Python 3的代码：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 语言：C</span><br><span class="line">// 执行用时：0ms（我不想再说什么了……为啥又是0啊QAQ……）</span><br><span class="line">// 内存消耗：6.9MB</span><br><span class="line">int climbStairs(int n)&#123;</span><br><span class="line">    if (n == 1)</span><br><span class="line">        return 1;</span><br><span class="line">    int fib[100];</span><br><span class="line">    fib[1] = 1;</span><br><span class="line">    fib[2] = 2;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 3; i &lt;= n; i++)</span><br><span class="line">        fib[i] = fib[i - 1] + fib[i - 2];</span><br><span class="line">    return fib[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">语言：Python 3</span><br><span class="line">执行用时：36ms（诶它终于不是0ms了嘿嘿QvQ）</span><br><span class="line">内存消耗：12.7MB</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">class Solution:</span><br><span class="line">    def climbStairs(self, n: int) -&gt; int:</span><br><span class="line">        if n == 1:</span><br><span class="line">            return 1</span><br><span class="line">        fib = [1, 1, 2]</span><br><span class="line">        for i in range(3, n + 1):</span><br><span class="line">            next = fib[i - 1] + fib[i - 2]</span><br><span class="line">            fib.append(next)</span><br><span class="line">        return fib[n]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;同样地，这种解法的时间复杂度为O(n)，空间复杂度为O(n)。  </p>
<h2 id="解法3：斐波那契公式法"><a href="#解法3：斐波那契公式法" class="headerlink" title="解法3：斐波那契公式法"></a>解法3：斐波那契公式法</h2><p>&emsp;&emsp;既然知道这道题本质上就是斐波那契数列了，那么我们就可以直接使用公式啦！<br>&emsp;&emsp;斐波那契数列的公式如下：<br>$$F_n=\frac{1}{\sqrt{5}}\left(\left(\frac{1+\sqrt{5}}{2}\right)^{n+1}-\left(\frac{1-\sqrt{5}}{2}\right)^{n+1}\right)$$<br>&emsp;&emsp;套用这个公式可以很快地解决本题。Python 3代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">语言：Python 3</span><br><span class="line">执行用时：48ms（比上一个方法慢了不少诶QnQ）</span><br><span class="line">内存消耗：12.8MB</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import math</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def climbStairs(self, n: int) -&gt; int:</span><br><span class="line">        return int((pow((1+math.sqrt(5))/2, n+1) - pow((1-math.sqrt(5))/2, n+1)) / math.sqrt(5))</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这种方法的时间复杂度为O(log(n))（pow()将会用去log(n)的时间），空间复杂度为O(1)（使用常量级空间）。  </p>

        </div>
    

</div>
            
        </section>
    </div>
</div>



    <div class="row">
        <div class="col-sm-12">
            <div class="wrap-pagination">
                <a class="" href="/page/2/">
                    <i class="fa fa-chevron-left" aria-hidden="true"></i>
                </a>
                <a class="" href="/page/4/">
                    <i class="fa fa-chevron-right" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>




</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    I'd walk a million miles just to see your smile. 
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2020/03/16/%E5%AE%9E%E9%AA%8C%E5%AE%A420200314%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%80%BB%E7%BB%93/">实验室20200314数据处理任务总结</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/03/01/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8C%89%E8%AE%A1%E5%88%92%E8%87%AA%E5%8A%A8%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC%EF%BC%88Windows%E7%B3%BB%E7%BB%9F%EF%BC%89/">Python数据分析基础之按计划自动运行脚本（Wi</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/02/28/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8F%8F%E8%BF%B0%E6%80%A7%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%BB%BA%E6%A8%A1(1)/">Python数据分析基础之描述性统计与建模(1)</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/02/20/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9B%BE%E4%B8%8E%E5%9B%BE%E8%A1%A8%EF%BC%88ggplot%E7%95%AA%E5%A4%96%E7%AF%87%EF%BC%89/">Python数据分析基础之图与图表（ggplot番</a>
            </li>
            
        </ul>
    </div>



            
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/CCH21" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:1398635912@qq.com" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a href="http://www.codeblocq.com/" target="_blank" rel="noopener">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



</body>

</html>