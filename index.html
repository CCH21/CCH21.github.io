<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    

    <!--Author-->
    
        <meta name="author" content="John Doe">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Welcome to CCH21&#39;s Blog"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="Welcome to CCH21&#39;s Blog"/>

    <!--Type page-->
    
        <meta property="og:type" content="website" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>Welcome to CCH21&#39;s Blog</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about.html">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact.html">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
            <h1 id="main-title" class="title">Welcome to CCH21's Blog</h1>
        
    </div>
</header>

        <section class="main">
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/02/28/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8F%8F%E8%BF%B0%E6%80%A7%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%BB%BA%E6%A8%A1(1)/">
                Python数据分析基础之描述性统计与建模(1)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-02-28</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="葡萄酒质量数据集"><a href="#葡萄酒质量数据集" class="headerlink" title="葡萄酒质量数据集"></a>葡萄酒质量数据集</h2><p>&emsp;&emsp;葡萄酒质量数据集包括两个文件——红葡萄酒文件和白葡萄酒文件。红葡萄酒文件中包含1599条观测，白葡萄酒文件包含4898条观测。两个文件中都有1个输出变量和11个输入变量。输出变量是酒的质量，是一个从0（低质量）到10（高质量）的评分。输入变量是葡萄酒的物理化学成分和特性，包括非挥发性酸、挥发性酸、柠檬酸、残余糖分、氯化物、游离二氧化硫、总二氧化硫、密度、pH值、硫酸盐和酒精含量。<br>&emsp;&emsp;我们把这两个数据集合成一个数据集，保存在文件winequality-both.csv中。这个数据集中应该包括一个标题行和6497条。另外，还应该再添加一列，用来区分这行数据是红葡萄酒还是白葡萄酒的数据。<br>&emsp;&emsp;想要下载数据集？<a href="https://github.com/cbrownley/foundations-for-analytics-with-python/blob/master/statistics/winequality-both.csv" target="_blank" rel="noopener">点我</a>！<br><img src="https://img-blog.csdnimg.cn/2020022715304774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="描述性统计"><a href="#描述性统计" class="headerlink" title="描述性统计"></a>描述性统计</h2><p>&emsp;&emsp;我们来对这个数据集进行分析。首先，我们要计算出每列的总体描述性统计量、质量列中的唯一值以及和这个唯一值对应的观测数量。代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">import seaborn as sns</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import statsmodels.api as sm</span><br><span class="line">import statsmodels.formula.api as smf</span><br><span class="line">from statsmodels.formula.api import ols, glm</span><br><span class="line"></span><br><span class="line"># 将数据集读入到pandas数据框中</span><br><span class="line">wine = pd.read_csv(&apos;winequality-both.csv&apos;, sep=&apos;,&apos;, header=0)</span><br><span class="line">wine.columns = wine.columns.str.replace(&apos; &apos;, &apos;_&apos;)</span><br><span class="line">print(wine.head())</span><br><span class="line"></span><br><span class="line"># 显示所有变量的描述性统计量</span><br><span class="line">print(wine.describe())</span><br><span class="line"></span><br><span class="line"># 找出唯一值</span><br><span class="line">print(sorted(wine.quality.unique()))</span><br><span class="line"></span><br><span class="line"># 计算值的频率</span><br><span class="line">print(wine.quality.value_counts())</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在使用pandas模块的<code>read_csv()</code>方法将文本文件读入一个pandas数据框之后，我们使用<code>head()</code>函数检查一下标题行和前五行数据，确保数据被正确加载。第17行代码使用pandas的<code>describe()</code>函数打印出数据集中每个数值型变量的摘要统计量。第20行代码使用<code>unique()</code>识别出质量列中的唯一值，并以升序打印在屏幕上。最后，第23行代码计算出质量列中每个唯一值在数据集中出现的次数，并把它们以降序打印到屏幕上。<br>&emsp;&emsp;这段代码的运行结果如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  type  fixed_acidity  volatile_acidity  ...  sulphates  alcohol  quality</span><br><span class="line">0  red            7.4              0.70  ...       0.56      9.4        5</span><br><span class="line">1  red            7.8              0.88  ...       0.68      9.8        5</span><br><span class="line">2  red            7.8              0.76  ...       0.65      9.8        5</span><br><span class="line">3  red           11.2              0.28  ...       0.58      9.8        6</span><br><span class="line">4  red            7.4              0.70  ...       0.56      9.4        5</span><br><span class="line"></span><br><span class="line">[5 rows x 13 columns]</span><br><span class="line">       fixed_acidity  volatile_acidity  ...      alcohol      quality</span><br><span class="line">count    6497.000000       6497.000000  ...  6497.000000  6497.000000</span><br><span class="line">mean        7.215307          0.339666  ...    10.491801     5.818378</span><br><span class="line">std         1.296434          0.164636  ...     1.192712     0.873255</span><br><span class="line">min         3.800000          0.080000  ...     8.000000     3.000000</span><br><span class="line">25%         6.400000          0.230000  ...     9.500000     5.000000</span><br><span class="line">50%         7.000000          0.290000  ...    10.300000     6.000000</span><br><span class="line">75%         7.700000          0.400000  ...    11.300000     6.000000</span><br><span class="line">max        15.900000          1.580000  ...    14.900000     9.000000</span><br><span class="line"></span><br><span class="line">[8 rows x 12 columns]</span><br><span class="line">[3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">6    2836</span><br><span class="line">5    2138</span><br><span class="line">7    1079</span><br><span class="line">4     216</span><br><span class="line">8     193</span><br><span class="line">3      30</span><br><span class="line">9       5</span><br><span class="line">Name: quality, dtype: int64</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;输出显示，质量评分中有6497个观测，评分范围从3到9，平均质量评分为5.8，标准差为0.87；质量列中的唯一值是3、4、5、6、7、8和9；有2836个观测的质量评分为6，2138个观测的质量评分为5，1079个观测的质量评分为7，216个观测的质量评分为4，193个观测的质量评分为8，30个观测的质量评分为3，5个观测的质量评分为9。</p>
<h2 id="分组、直方图与t检验"><a href="#分组、直方图与t检验" class="headerlink" title="分组、直方图与t检验"></a>分组、直方图与t检验</h2><p>&emsp;&emsp;下面我们分别分析红葡萄酒数据和白葡萄酒数据，看看统计量是否会保持不变。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"># 按照葡萄酒类型显示质量的描述性统计量</span><br><span class="line">print(wine.groupby(&apos;type&apos;)[[&apos;quality&apos;]].describe().unstack(&apos;type&apos;))</span><br><span class="line"></span><br><span class="line"># 按照葡萄酒类型显示质量的特定分位数值</span><br><span class="line">print(wine.groupby(&apos;type&apos;)[[&apos;quality&apos;]].quantile([0.25, 0.75]).unstack(&apos;type&apos;))</span><br><span class="line"></span><br><span class="line"># 按照葡萄酒类型查看质量分布</span><br><span class="line">red_wine = wine.loc[wine[&apos;type&apos;] == &apos;red&apos;, &apos;quality&apos;]</span><br><span class="line">white_wine = wine.loc[wine[&apos;type&apos;] == &apos;white&apos;, &apos;quality&apos;]</span><br><span class="line">sns.set_style(&quot;dark&quot;)</span><br><span class="line">print(sns.distplot(red_wine, norm_hist=True, kde=False, color=&quot;red&quot;, label=&quot;Red wine&quot;))</span><br><span class="line">print(sns.distplot(white_wine, norm_hist=True, kde=False, color=&quot;white&quot;, label=&quot;White wine&quot;))</span><br><span class="line">sns.utils.axlabel(&quot;Quality Score&quot;, &quot;Density&quot;)</span><br><span class="line">plt.title(&quot;Distribution of Quality by Wine Type&quot;)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"># 检验红葡萄酒和白葡萄酒的平均质量是否有所不同</span><br><span class="line">print(wine.groupby([&apos;type&apos;])[[&apos;quality&apos;]].agg([&apos;std&apos;]))</span><br><span class="line">tstat, pvalue, df = sm.stats.ttest_ind(red_wine, white_wine)</span><br><span class="line">print(&apos;tstat: %.3f pvalue: %.4f&apos; % (tstat, pvalue))</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>groupby()</code>函数使用<code>type</code>列中的两个值将数据分为两组。方括号可以生成一个列表，列表中的元素是用来生成输出的列。在这里我们只对质量列应用<code>describe()</code>函数。这些命令的结果就是生成一列统计量，来自红葡萄酒数据的计算结果和白葡萄酒数据的计算结果是相互垂直地堆叠在一起的。<code>unstack()</code>函数将结果重新排列，这样红葡萄酒和白葡萄酒的统计量就会显示在并排的两列中。<code>quantile()</code>函数对质量列计算第25百分位数和第75百分位数。<br>&emsp;&emsp;接下来，我们使用seaborn创建直方图，红条表示红葡萄酒，白条表示白葡萄酒。因为白葡萄酒数据比红葡萄酒多，所以直方图显示密度分布而不是频率分布。<br>&emsp;&emsp;最后，进行一下t检验，判断红葡萄酒和白葡萄酒的平均评分是否有区别。在这里我们想知道红葡萄酒和白葡萄酒评分的标准差是否相同，所以在t检验中可以使用合并方差。<br>&emsp;&emsp;下面是这段代码的运行结果。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">                type </span><br><span class="line">quality  count  red      1599.000000</span><br><span class="line">                white    4898.000000</span><br><span class="line">         mean   red         5.636023</span><br><span class="line">                white       5.877909</span><br><span class="line">         std    red         0.807569</span><br><span class="line">                white       0.885639</span><br><span class="line">         min    red         3.000000</span><br><span class="line">                white       3.000000</span><br><span class="line">         25%    red         5.000000</span><br><span class="line">                white       5.000000</span><br><span class="line">         50%    red         6.000000</span><br><span class="line">                white       6.000000</span><br><span class="line">         75%    red         6.000000</span><br><span class="line">                white       6.000000</span><br><span class="line">         max    red         8.000000</span><br><span class="line">                white       9.000000</span><br><span class="line">dtype: float64</span><br><span class="line">     quality      </span><br><span class="line">type     red white</span><br><span class="line">0.25     5.0   5.0</span><br><span class="line">0.75     6.0   6.0</span><br><span class="line">AxesSubplot(0.125,0.11;0.775x0.77)</span><br><span class="line">AxesSubplot(0.125,0.11;0.775x0.77)</span><br><span class="line">        quality</span><br><span class="line">            std</span><br><span class="line">type           </span><br><span class="line">red    0.807569</span><br><span class="line">white  0.885639</span><br><span class="line">tstat: -9.686 pvalue: 0.0000</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200227210016145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;由绘制的密度分布直方图和输出结果可以得出结论：两种葡萄酒的评分都近似正态分布；t检验统计量为-9.686，p值为0.000，这说明白葡萄酒的平均质量评分在统计意义上大于红葡萄酒的平均质量评分。  </p>
<h2 id="成对变量之间的关系和相关性"><a href="#成对变量之间的关系和相关性" class="headerlink" title="成对变量之间的关系和相关性"></a>成对变量之间的关系和相关性</h2><p>&emsp;&emsp;前面已经检查了输出变量，下面简单研究一下输入变量。让我们计算一下输入变量两两之间的相关性，并为一些输入变量创建带有回归直线的散点图：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"># 计算所有变量的相关矩阵</span><br><span class="line">print(wine.corr())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 从红葡萄酒和白葡萄酒的数据中取出一个“小”样本来进行绘图</span><br><span class="line">def take_sample(data_frame, replace=False, n=200):</span><br><span class="line">    return data_frame.loc[np.random.choice(data_frame.index, replace=replace, size=n)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">reds_sample = take_sample(wine.loc[wine[&apos;type&apos;] == &apos;red&apos;, :])</span><br><span class="line">whites_sample = take_sample(wine.loc[wine[&apos;type&apos;] == &apos;white&apos;, :])</span><br><span class="line">wine_sample = pd.concat([reds_sample, whites_sample])</span><br><span class="line">wine[&apos;in_sample&apos;] = np.where(wine.index.isin(wine_sample.index), 1., 0.)</span><br><span class="line">print(pd.crosstab(wine.in_sample, wine.type, margins=True))</span><br><span class="line"></span><br><span class="line"># 查看成对变量之间的关系</span><br><span class="line">sns.set_style(&quot;dark&quot;)</span><br><span class="line">g = sns.pairplot(wine_sample, kind=&apos;reg&apos;, plot_kws=&#123;&quot;ci&quot;: False, &quot;x_jitter&quot;: 0.25, &quot;y_jitter&quot;: 0.25&#125;, hue=&apos;type&apos;,</span><br><span class="line">                 diag_kind=&apos;hist&apos;, diag_kws=&#123;&quot;bins&quot;: 10, &quot;alpha&quot;: 1.0&#125;, palette=dict(red=&quot;red&quot;, white=&quot;white&quot;),</span><br><span class="line">                 markers=[&quot;o&quot;, &quot;s&quot;], vars=[&apos;quality&apos;, &apos;alcohol&apos;, &apos;residual_sugar&apos;])</span><br><span class="line">print(g)</span><br><span class="line">plt.suptitle(&apos;Histograms and Scatter Plots of Quality, Alcohol, and Residual Sugar&apos;, fontsize=14,</span><br><span class="line">             horizontalalignment=&apos;center&apos;, verticalalignment=&apos;top&apos;, x=0.5, y=0.999)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>corr()</code>函数可以计算出数据集中所有变量两两之间的线性相关性。<br>&emsp;&emsp;数据集中有6000多个点，所以如果将它们都画在统计图中，就很难分辨出清楚的点。我们定义了一个函数<code>take_sample()</code>，用来抽取在统计图中使用的样本点。这个函数使用pandas数据框索引和numpy的<code>random.choice()</code>函数随机选择一个行的子集。我们是用这个函数对红葡萄酒和白葡萄酒分别进行抽样，并将抽样所得的两个数据框连接成一个数据框。然后，在wine数据框中创建一个新列<code>in_sample</code>，并使用numpy的<code>where()</code>函数和pandas的<code>isin()</code>函数对这个新列进行填充，填充的值根据此行的索引值是否在抽样数据的索引值中分别设为1和0.最后，我们使用pandas的<code>crosstab()</code>函数来确认<code>in_sample</code>列中包含400个1（200条红葡萄酒数据和200条白葡萄酒数据）和6097个0。<br>&emsp;&emsp;seaborn的<code>pairplot()</code>函数可以创建一个统计图矩阵。主对角线上的图以直方图或密度图的形式显示了每个变量的单变量分布，对角线之外的图以散点图的形式显示了每两个变量之间的双变量分布，散点图中可以有回归直线，也可以没有。因为质量评分都是整数，所以加上一点振动可以更容易看出数据在何处集中。<br>&emsp;&emsp;这段代码的运行结果如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">                      fixed_acidity  volatile_acidity  ...   alcohol   quality</span><br><span class="line">fixed_acidity              1.000000          0.219008  ... -0.095452 -0.076743</span><br><span class="line">volatile_acidity           0.219008          1.000000  ... -0.037640 -0.265699</span><br><span class="line">citric_acid                0.324436         -0.377981  ... -0.010493  0.085532</span><br><span class="line">residual_sugar            -0.111981         -0.196011  ... -0.359415 -0.036980</span><br><span class="line">chlorides                  0.298195          0.377124  ... -0.256916 -0.200666</span><br><span class="line">free_sulfur_dioxide       -0.282735         -0.352557  ... -0.179838  0.055463</span><br><span class="line">total_sulfur_dioxide      -0.329054         -0.414476  ... -0.265740 -0.041385</span><br><span class="line">density                    0.458910          0.271296  ... -0.686745 -0.305858</span><br><span class="line">pH                        -0.252700          0.261454  ...  0.121248  0.019506</span><br><span class="line">sulphates                  0.299568          0.225984  ... -0.003029  0.038485</span><br><span class="line">alcohol                   -0.095452         -0.037640  ...  1.000000  0.444319</span><br><span class="line">quality                   -0.076743         -0.265699  ...  0.444319  1.000000</span><br><span class="line"></span><br><span class="line">[12 rows x 12 columns]</span><br><span class="line">type        red  white   All</span><br><span class="line">in_sample                   </span><br><span class="line">0.0        1399   4698  6097</span><br><span class="line">1.0         200    200   400</span><br><span class="line">All        1599   4898  6497</span><br><span class="line">&lt;seaborn.axisgrid.PairGrid object at 0x00000249B4D11E48&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200227221539322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;根据相关系数的符号，从输出中可以知道酒精含量、硫酸盐、pH值、游离二氧化硫和柠檬酸这些指标与质量是正相关的，相反，非挥发性酸、挥发性酸、残余糖分、氯化物、总二氧化硫和密度这些指标与质量是负相关的。<br>&emsp;&emsp;从统计图中可以看出，对于红葡萄酒和白葡萄酒来说，酒精含量的均值和标准差是大致相同的，但是，白葡萄酒残余糖分的均值和标准差却大于红葡萄酒残余糖分的均值和标准差。从回归直线可以看出，对于两种类型的葡萄酒，酒精含量增加时，质量评分也随之提高，相反，残余糖分增加时，质量评分则随之降低。这两个变量对白葡萄酒的影响都要大于对红葡萄酒的影响。  </p>
<h2 id="使用最小二乘估计进行线性回归"><a href="#使用最小二乘估计进行线性回归" class="headerlink" title="使用最小二乘估计进行线性回归"></a>使用最小二乘估计进行线性回归</h2><p>&emsp;&emsp;相关系数和两两变量之间的统计图有助于对两个变量之间的关系进行量化和可视化，但是它们不能测量出每个自变量在其他自变量不变时与因变量之间的关系。线性回归可以解决这个问题。<br>&emsp;&emsp;线性回归模型如下：$$y_i\sim N(\mu_i,\sigma^2),$$$$\mu_i=\beta_0+\beta_1x_{i1}+\beta_2x_{i2}+…+\beta_px_{ip}$$对于$i=1,2,…，n$个观测和$p$个自变量。<br>&emsp;&emsp;这个模型表示观测$y_i$服从均值为$\mu_i$方差为$\sigma^2$的正态分布（高斯分布），其中$\mu_i$依赖于自变量，$\sigma^2$为一个常数。也就是说，给定了自变量的值之后，我们就可以得到一个具体的质量评分，但在另一天，给定同样的自变量值，我们可能会得到一个和前面不同的质量评分。但是，经过很多天自变量取同样的值（也就是一个很长的周期），质量评分会落在$\mu_i±\sigma$这个范围内。<br>&emsp;&emsp;下面我们使用statsmodel包来进行线性回归：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">my_formula = &apos;quality ~ alcohol + chlorides + citric_acid + density +fixed_acidity + free_sulfur_dioxide + pH&apos; \</span><br><span class="line">             &apos;+ residual_sugar + sulphates + total_sulfur_dioxide + volatile_acidity&apos;</span><br><span class="line"></span><br><span class="line">lm = ols(my_formula, data=wine).fit()</span><br><span class="line"></span><br><span class="line"># 或者，也可以使用广义线性模型（glm）语法进行线性回归</span><br><span class="line"># lm = glm(my_formula, data=wine, family=sm.families.Gaussian()).fit()</span><br><span class="line"></span><br><span class="line">print(lm.summary())</span><br><span class="line">print(&quot;\nQuantities you can extract from the result:\n%s&quot; % dir(lm))</span><br><span class="line">print(&quot;Coefficients:\n%s&quot; % lm.params)</span><br><span class="line">print(&quot;Coefficient Std Errors:\n%s&quot; % lm.bse)</span><br><span class="line">print(&quot;\nAdj. R-squared:\n%.2f&quot; % lm.rsquared_adj)</span><br><span class="line">print(&quot;\nF-statistic: %.1f   P-value: %.2f&quot; % (lm.fvalue, lm.f_pvalue))</span><br><span class="line">print(&quot;\nNumber of obs: %d   Number of fitted values: %d&quot; % (lm.nobs, len(lm.fittedvalues)))</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;运行结果如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">                            OLS Regression Results                            </span><br><span class="line">==============================================================================</span><br><span class="line">Dep. Variable:                quality   R-squared:                       0.292</span><br><span class="line">Model:                            OLS   Adj. R-squared:                  0.291</span><br><span class="line">Method:                 Least Squares   F-statistic:                     243.3</span><br><span class="line">Date:                Thu, 27 Feb 2020   Prob (F-statistic):               0.00</span><br><span class="line">Time:                        23:03:10   Log-Likelihood:                -7215.5</span><br><span class="line">No. Observations:                6497   AIC:                         1.445e+04</span><br><span class="line">Df Residuals:                    6485   BIC:                         1.454e+04</span><br><span class="line">Df Model:                          11                                         </span><br><span class="line">Covariance Type:            nonrobust                                         </span><br><span class="line">========================================================================================</span><br><span class="line">                           coef    std err          t      P&gt;|t|      [0.025      0.975]</span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line">Intercept               55.7627     11.894      4.688      0.000      32.447      79.079</span><br><span class="line">alcohol                  0.2670      0.017     15.963      0.000       0.234       0.300</span><br><span class="line">chlorides               -0.4837      0.333     -1.454      0.146      -1.136       0.168</span><br><span class="line">citric_acid             -0.1097      0.080     -1.377      0.168      -0.266       0.046</span><br><span class="line">density                -54.9669     12.137     -4.529      0.000     -78.760     -31.173</span><br><span class="line">fixed_acidity            0.0677      0.016      4.346      0.000       0.037       0.098</span><br><span class="line">free_sulfur_dioxide      0.0060      0.001      7.948      0.000       0.004       0.007</span><br><span class="line">pH                       0.4393      0.090      4.861      0.000       0.262       0.616</span><br><span class="line">residual_sugar           0.0436      0.005      8.449      0.000       0.033       0.054</span><br><span class="line">sulphates                0.7683      0.076     10.092      0.000       0.619       0.917</span><br><span class="line">total_sulfur_dioxide    -0.0025      0.000     -8.969      0.000      -0.003      -0.002</span><br><span class="line">volatile_acidity        -1.3279      0.077    -17.162      0.000      -1.480      -1.176</span><br><span class="line">==============================================================================</span><br><span class="line">Omnibus:                      144.075   Durbin-Watson:                   1.646</span><br><span class="line">Prob(Omnibus):                  0.000   Jarque-Bera (JB):              324.712</span><br><span class="line">Skew:                          -0.006   Prob(JB):                     3.09e-71</span><br><span class="line">Kurtosis:                       4.095   Cond. No.                     2.49e+05</span><br><span class="line">==============================================================================</span><br><span class="line"></span><br><span class="line">Warnings:</span><br><span class="line">[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.</span><br><span class="line">[2] The condition number is large, 2.49e+05. This might indicate that there are</span><br><span class="line">strong multicollinearity or other numerical problems.</span><br><span class="line"></span><br><span class="line">Quantities you can extract from the result:</span><br><span class="line">[&apos;HC0_se&apos;, &apos;HC1_se&apos;, &apos;HC2_se&apos;, &apos;HC3_se&apos;, &apos;_HCCM&apos;, &apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__module__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;__weakref__&apos;, &apos;_cache&apos;, &apos;_data_attr&apos;, &apos;_get_robustcov_results&apos;, &apos;_is_nested&apos;, &apos;_wexog_singular_values&apos;, &apos;aic&apos;, &apos;bic&apos;, &apos;bse&apos;, &apos;centered_tss&apos;, &apos;compare_f_test&apos;, &apos;compare_lm_test&apos;, &apos;compare_lr_test&apos;, &apos;condition_number&apos;, &apos;conf_int&apos;, &apos;conf_int_el&apos;, &apos;cov_HC0&apos;, &apos;cov_HC1&apos;, &apos;cov_HC2&apos;, &apos;cov_HC3&apos;, &apos;cov_kwds&apos;, &apos;cov_params&apos;, &apos;cov_type&apos;, &apos;df_model&apos;, &apos;df_resid&apos;, &apos;diagn&apos;, &apos;eigenvals&apos;, &apos;el_test&apos;, &apos;ess&apos;, &apos;f_pvalue&apos;, &apos;f_test&apos;, &apos;fittedvalues&apos;, &apos;fvalue&apos;, &apos;get_influence&apos;, &apos;get_prediction&apos;, &apos;get_robustcov_results&apos;, &apos;initialize&apos;, &apos;k_constant&apos;, &apos;llf&apos;, &apos;load&apos;, &apos;model&apos;, &apos;mse_model&apos;, &apos;mse_resid&apos;, &apos;mse_total&apos;, &apos;nobs&apos;, &apos;normalized_cov_params&apos;, &apos;outlier_test&apos;, &apos;params&apos;, &apos;predict&apos;, &apos;pvalues&apos;, &apos;remove_data&apos;, &apos;resid&apos;, &apos;resid_pearson&apos;, &apos;rsquared&apos;, &apos;rsquared_adj&apos;, &apos;save&apos;, &apos;scale&apos;, &apos;ssr&apos;, &apos;summary&apos;, &apos;summary2&apos;, &apos;t_test&apos;, &apos;t_test_pairwise&apos;, &apos;tvalues&apos;, &apos;uncentered_tss&apos;, &apos;use_t&apos;, &apos;wald_test&apos;, &apos;wald_test_terms&apos;, &apos;wresid&apos;]</span><br><span class="line">Coefficients:</span><br><span class="line">Intercept               55.762750</span><br><span class="line">alcohol                  0.267030</span><br><span class="line">chlorides               -0.483714</span><br><span class="line">citric_acid             -0.109657</span><br><span class="line">density                -54.966942</span><br><span class="line">fixed_acidity            0.067684</span><br><span class="line">free_sulfur_dioxide      0.005970</span><br><span class="line">pH                       0.439296</span><br><span class="line">residual_sugar           0.043559</span><br><span class="line">sulphates                0.768252</span><br><span class="line">total_sulfur_dioxide    -0.002481</span><br><span class="line">volatile_acidity        -1.327892</span><br><span class="line">dtype: float64</span><br><span class="line">Coefficient Std Errors:</span><br><span class="line">Intercept               11.893899</span><br><span class="line">alcohol                  0.016728</span><br><span class="line">chlorides                0.332683</span><br><span class="line">citric_acid              0.079619</span><br><span class="line">density                 12.137473</span><br><span class="line">fixed_acidity            0.015573</span><br><span class="line">free_sulfur_dioxide      0.000751</span><br><span class="line">pH                       0.090371</span><br><span class="line">residual_sugar           0.005156</span><br><span class="line">sulphates                0.076123</span><br><span class="line">total_sulfur_dioxide     0.000277</span><br><span class="line">volatile_acidity         0.077373</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">Adj. R-squared:</span><br><span class="line">0.29</span><br><span class="line"></span><br><span class="line">F-statistic: 243.3   P-value: 0.00</span><br><span class="line"></span><br><span class="line">Number of obs: 6497   Number of fitted values: 6497</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;字符串变量<code>my_formula</code>包含的是类似R语言语法的回归公式定义。波浪线左侧的变量<code>quality</code>是因变量，波浪线右侧的变量是自变量。<br>&emsp;&emsp;下一行代码使用公式和数据你喝一个普通最小二乘回归模型，并将结果赋给变量<code>lm</code>。被注释掉的那一行代码使用广义线性模型（glm）的语法代替普通最小二乘语法也可以拟合同样的模型。  </p>
<blockquote>
<p>Tips:<br>dir()：不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表<br>lm.params：以一个序列的形式返回模型系数<br>lm.rsquared_adj：返回修正R方<br>lm.fvalue：返回F统计量<br>lm.f_pvalue：返回F统计量的p值<br>lm.fittedvalues：返回拟合值</p>
</blockquote>
<h2 id="系数解释"><a href="#系数解释" class="headerlink" title="系数解释"></a>系数解释</h2><p>&emsp;&emsp;在这个模型中，某个自变量系数的意义是，在其他自变量保持不变的情况下，这个自变量发生1个单位的变化时，导致葡萄酒质量评分发生的平均变化。<br>&emsp;&emsp;并不是所有的系数都需要解释。例如，截距系数的意义是当所有自变量的值都为0时的期望评分。因为没有任何一种葡萄酒的各种成分都为0，所以截距系数没有具体意义。  </p>
<h2 id="自变量标准化"><a href="#自变量标准化" class="headerlink" title="自变量标准化"></a>自变量标准化</h2><p>&emsp;&emsp;关于这个模型，普通最小二乘回归是通过使残差平方和最小化来估计未知的$\beta$参数值的，这里的残差是指自变量观测值与拟合值之间的差别。因为残差大小是依赖于自变量的测量单位的，所以如果自变量的测量单位相差很大的话，那么将自变量标准化后，就可以更容易对模型进行解释了。对自变量进行标准化的方法是，先从自变量的每个观测值中减去均值，然后再除以这个自变量的标准差。自变量标准化完成以后，它的均值为0，标准差为1。  </p>
<blockquote>
<p>在 <em>Data Analysis Using Regression and Multilevel/Hierarchical Models</em> (Cambridge University Press, 2007, p.56) 中，Gelman and Hill建议在数据集中既有连续型自变量又有二值型自变量的情况下，用两杯标准差去除，而不是用一倍标准差。这样的话，标准化自变量一个单位的变化就对应于均值上下一个标准差的变化。  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"># 创建一个名为dependent_variable的序列来保存质量数据</span><br><span class="line">dependent_variable = wine[&apos;quality&apos;]</span><br><span class="line"></span><br><span class="line"># 创建一个名为independent_variables的数据框来保存初始的葡萄酒数据集中除quality、type和in_sample之外的所有变量</span><br><span class="line">independent_variables = wine[wine.columns.difference([&apos;quality&apos;, &apos;type&apos;, &apos;in_sample&apos;])]</span><br><span class="line"></span><br><span class="line"># 对自变量进行标准化</span><br><span class="line"># 对每个变量，在每个观测中减去变量的均值</span><br><span class="line"># 并且使用结果除以变量的标准差</span><br><span class="line">independent_variables_standardized = (independent_variables</span><br><span class="line">                                      - independent_variables.mean()) / independent_variables.std()</span><br><span class="line"></span><br><span class="line"># 将因变量quality作为一列添加到自变量数据框中</span><br><span class="line"># 创建一个带有标准化自变量的新数据集</span><br><span class="line">wine_standardized = pd.concat([dependent_variable, independent_variables_standardized], axis=1)</span><br><span class="line"></span><br><span class="line"># 重新进行线性回归，并查看一下摘要统计</span><br><span class="line">lm_standardized = ols(my_formula, data=wine_standardized).fit()</span><br><span class="line">print(lm_standardized.summary())</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;运行结果如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">                            OLS Regression Results                            </span><br><span class="line">==============================================================================</span><br><span class="line">Dep. Variable:                quality   R-squared:                       0.292</span><br><span class="line">Model:                            OLS   Adj. R-squared:                  0.291</span><br><span class="line">Method:                 Least Squares   F-statistic:                     243.3</span><br><span class="line">Date:                Fri, 28 Feb 2020   Prob (F-statistic):               0.00</span><br><span class="line">Time:                        16:31:15   Log-Likelihood:                -7215.5</span><br><span class="line">No. Observations:                6497   AIC:                         1.445e+04</span><br><span class="line">Df Residuals:                    6485   BIC:                         1.454e+04</span><br><span class="line">Df Model:                          11                                         </span><br><span class="line">Covariance Type:            nonrobust                                         </span><br><span class="line">========================================================================================</span><br><span class="line">                           coef    std err          t      P&gt;|t|      [0.025      0.975]</span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line">Intercept                5.8184      0.009    637.785      0.000       5.800       5.836</span><br><span class="line">alcohol                  0.3185      0.020     15.963      0.000       0.279       0.358</span><br><span class="line">chlorides               -0.0169      0.012     -1.454      0.146      -0.040       0.006</span><br><span class="line">citric_acid             -0.0159      0.012     -1.377      0.168      -0.039       0.007</span><br><span class="line">density                 -0.1648      0.036     -4.529      0.000      -0.236      -0.093</span><br><span class="line">fixed_acidity            0.0877      0.020      4.346      0.000       0.048       0.127</span><br><span class="line">free_sulfur_dioxide      0.1060      0.013      7.948      0.000       0.080       0.132</span><br><span class="line">pH                       0.0706      0.015      4.861      0.000       0.042       0.099</span><br><span class="line">residual_sugar           0.2072      0.025      8.449      0.000       0.159       0.255</span><br><span class="line">sulphates                0.1143      0.011     10.092      0.000       0.092       0.137</span><br><span class="line">total_sulfur_dioxide    -0.1402      0.016     -8.969      0.000      -0.171      -0.110</span><br><span class="line">volatile_acidity        -0.2186      0.013    -17.162      0.000      -0.244      -0.194</span><br><span class="line">==============================================================================</span><br><span class="line">Omnibus:                      144.075   Durbin-Watson:                   1.646</span><br><span class="line">Prob(Omnibus):                  0.000   Jarque-Bera (JB):              324.712</span><br><span class="line">Skew:                          -0.006   Prob(JB):                     3.09e-71</span><br><span class="line">Kurtosis:                       4.095   Cond. No.                         9.61</span><br><span class="line">==============================================================================</span><br><span class="line"></span><br><span class="line">Warnings:</span><br><span class="line">[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;自变量标准化会改变对模型系数的解释。现在每个自变量系数的含义是，不同的葡萄酒在其他自变量均相同的情况下，某个自变量相差1个标准差，会使葡萄酒的质量评分平均相差多少个标准差。<br>&emsp;&emsp;自变量标准化同样会改变对截距的解释。当解释变量被标准化后，截距表示的就是当所有自变量取值为均值时因变量的均值。  </p>
<h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 使用葡萄酒数据集中的前10个观测创建10个“新”观测</span><br><span class="line"># 新观测中只包含模型中使用的自变量</span><br><span class="line">new_observations = wine.loc[wine.index.isin(range(10)), independent_variables.columns]</span><br><span class="line"></span><br><span class="line"># 基于新观测中的葡萄酒特性预测质量评分</span><br><span class="line">y_predicted = lm.predict(new_observations)</span><br><span class="line"></span><br><span class="line"># 将预测值保留两位小数并打印到屏幕上</span><br><span class="line">y_predicted_rounded = [round(score, 2) for score in y_predicted]</span><br><span class="line">print(y_predicted_rounded)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;运行结果如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[5.0, 4.92, 5.03, 5.68, 5.0, 5.04, 5.02, 5.3, 5.24, 5.69]</span><br></pre></td></tr></table></figure>
        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/02/20/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9B%BE%E4%B8%8E%E5%9B%BE%E8%A1%A8%EF%BC%88ggplot%E7%95%AA%E5%A4%96%E7%AF%87%EF%BC%89/">
                Python数据分析基础之图与图表（ggplot番外篇）
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-02-20</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="ggplot简介"><a href="#ggplot简介" class="headerlink" title="ggplot简介"></a>ggplot简介</h2><p>&emsp;&emsp;ggplot是一个Python绘图包，它基于R语言的ggplot2包和图形语法。ggplot与其他绘图包的关键区别是它的语法将数据与实际绘图明确地分离开来。为了对数据进行可视化表示，ggplot提供了几种基本元素：几何对象、图形属性和标度。除此之外，为了进行更高级的绘图，ggplot还提供一些附加元素：统计变换、坐标系、子窗口和可视化主题。<br>&emsp;&emsp;Python的ggplot库不像R语言的ggplot2库那样成熟，所以它不具备ggplot2的所有功能。也就是说，它没有那么多的几何对象、统计变换和标度，也没有坐标系、注释和增强功能。在与ggplot相关的包进行了升级与修改之后，使用ggplot也可能会遇到问题。  </p>
<h2 id="安装ggplot模块"><a href="#安装ggplot模块" class="headerlink" title="安装ggplot模块"></a>安装ggplot模块</h2><p>&emsp;&emsp;打开Anaconda Prompt（如果你没有安装Anaconda的话，打开命令行窗口即可），输入命令<code>pip install ggplot</code>，等待安装完成。  </p>
<h2 id="参考书的示例代码及问题"><a href="#参考书的示例代码及问题" class="headerlink" title="参考书的示例代码及问题"></a>参考书的示例代码及问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">from ggplot import *</span><br><span class="line"></span><br><span class="line">print(mtcars.head())</span><br><span class="line">plt1 = ggplot(aes(x=&apos;mpg&apos;), data=mtcars) +\</span><br><span class="line"> 		geom_histogram(fill=&apos;darkblue&apos;, binwidth=2) +\</span><br><span class="line">		xlim(10, 35) + ylim(0, 10) +\</span><br><span class="line">		xlab(&quot;MPG&quot;) + ylab(&quot;Frequency&quot;) +\</span><br><span class="line">		ggtitle(&quot;Histogram of MPG&quot;) +\</span><br><span class="line">		theme_matplotlib()</span><br><span class="line">print(plt1)</span><br><span class="line"></span><br><span class="line">print(meat.head())</span><br><span class="line">plt2 = ggplot(aes(x=&apos;date&apos;, y=&apos;beef&apos;), data=meat) +\</span><br><span class="line">		geom_line(color=&apos;purple&apos;, size=1.5, alpha=0.75) +\</span><br><span class="line">		stat_smooth(colour=&apos;blue&apos;, size=2.0, span=0.15) +\</span><br><span class="line">		xlab(&quot;Year&quot;) + ylab(&quot;Head of Cattle Slaughtered&quot;) +\</span><br><span class="line">		ggtitle(&quot;Beef Consumption Over Time&quot;) +\</span><br><span class="line">		theme_seaborn()</span><br><span class="line">print(plt2)</span><br><span class="line"></span><br><span class="line">print(diamonds.head())</span><br><span class="line">plt3 = ggplot(diamonds, aes(x=&apos;carat&apos;, y=&apos;price&apos;, colour=&apos;cut&apos;)) +\</span><br><span class="line">		geom_point(alpha=0.5) +\</span><br><span class="line">		scale_color_gradient(low=&apos;#05D9F6&apos;, high=&apos;#5011D1&apos;) +\</span><br><span class="line">		xlim(0, 6) + ylim(0, 20000) +\</span><br><span class="line">		xlab(&quot;Carat&quot;) + ylab(&quot;Price&quot;) +\</span><br><span class="line">		ggtitle(&quot;Diamond Price by Carat and Cut&quot;) +\</span><br><span class="line">		theme_gray()</span><br><span class="line">print(plt3)</span><br><span class="line"></span><br><span class="line">ggsave(plt3, &quot;ggplot_plots.png&quot;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我在运行这个脚本的时候，PyCharm报错信息为：<code>AttributeError: module &#39;pandas&#39; has no attribute &#39;tslib&#39;</code>。我当时就懵了：这是什么情况？？？<br>&emsp;&emsp;后来我在网上查找了一下相关资料，以下是对这个问题的解答。  </p>
<blockquote>
<p>抱歉，看起来ggplot（又称ggpy）是一个官方不再维护的项目了，github上的最近一次提交还是三年前。而<code>AttributeError: module &#39;pandas&#39; has no attribute &#39;tslib&#39;</code>也是已知的由于 pandas 版本更新，API改变带来的bug。  </p>
</blockquote>
<p>&emsp;&emsp;解答者还在回答中提供了ggplot模块在GitHub上的issue和PR，但是我英语水平一般，就没有仔细地阅读这些，而是打算自己动手解决。  </p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>&emsp;&emsp;我们找到smoothers.py和utils.py这两个文件，如下图所示修改红框中的内容。  </p>
<blockquote>
<p>Tips:<br>smoothers.py的路径：D:\Anaconda3\Lib\site-packages\ggplot\stats\smoothers.py<br>utils.py的路径：D:\Anaconda3\Lib\site-packages\ggplot\utils.py<br>由于Anaconda3文件夹保存位置不同，路径可能会有差异。  </p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200220144626646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200220144707867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;修改完成之后，我们再次运行上面的代码。<br>&emsp;&emsp;运行结果显示报错信息：<code>NameError: name &#39;theme_matplotlib&#39; is not defined</code>。此时我的内心是崩溃的：我的天，怎么还是有问题啊！！！<br>&emsp;&emsp;好在我很快地冷静了下来，开始着手分析这个问题。<br>&emsp;&emsp;我打开了ggplot.py文件，按下Ctrl+F组合键，输入“theme”进行搜索，得到如下图所示的搜索信息。  </p>
<blockquote>
<p>Tips:<br>ggplot.py的路径：D:\Anaconda3\Lib\site-packages\ggplot\ggplot.py<br>由于Anaconda3文件夹保存位置不同，路径可能会有差异。  </p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/2020022014594812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;接下来，我打开了ggplot文件夹中的themes文件夹，发现……emmmm……它好像根本就没有<code>theme_matplotlib</code>和<code>theme_seaborn</code>啊！！！<br><img src="https://img-blog.csdnimg.cn/20200220150320281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;我的内心再一次崩溃。<br>&emsp;&emsp;算了，没有就没有吧，大不了我不用就是了。<br>&emsp;&emsp;于是，经过了一番折腾，代码变成了下面这个样子：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">from ggplot import *</span><br><span class="line"></span><br><span class="line">print(diamonds.head())</span><br><span class="line">plt = ggplot(diamonds, aes(x=&apos;carat&apos;, y=&apos;price&apos;, colour=&apos;cut&apos;)) + \</span><br><span class="line">      geom_point(alpha=0.5) + \</span><br><span class="line">      scale_color_gradient(low=&apos;#05D9F6&apos;, high=&apos;#5011D1&apos;) + \</span><br><span class="line">      xlim(0, 6) + ylim(0, 20000) + \</span><br><span class="line">      xlab(&quot;Carat&quot;) + ylab(&quot;Price&quot;) + \</span><br><span class="line">      ggtitle(&quot;Diamond Price by Carat and Cut&quot;) + \</span><br><span class="line">      theme_gray()</span><br><span class="line">print(plt)</span><br><span class="line"></span><br><span class="line">ggsave(plt, &quot;ggplot_plots.png&quot;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;再运行一次。你们猜怎么样？<br>&emsp;&emsp;又报错了。<br><img src="https://img-blog.csdnimg.cn/20200220150906918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;好在之前已经折腾了那么多，再报错我也见怪不怪了。我再次打开ggplot.py文件，以“save”为关键字搜索一下。<br><img src="https://img-blog.csdnimg.cn/20200220151233433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;原来它不叫<code>ggsave</code>而是叫<code>save</code>啊。这样一来就好办多了，我们再修改一下代码：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">from ggplot import *</span><br><span class="line"></span><br><span class="line">print(diamonds.head())</span><br><span class="line">plt = ggplot(diamonds, aes(x=&apos;carat&apos;, y=&apos;price&apos;, colour=&apos;cut&apos;)) + \</span><br><span class="line">      geom_point(alpha=0.5) + \</span><br><span class="line">      scale_color_gradient(low=&apos;#05D9F6&apos;, high=&apos;#5011D1&apos;) + \</span><br><span class="line">      xlim(0, 6) + ylim(0, 20000) + \</span><br><span class="line">      xlab(&quot;Carat&quot;) + ylab(&quot;Price&quot;) + \</span><br><span class="line">      ggtitle(&quot;Diamond Price by Carat and Cut&quot;) + \</span><br><span class="line">      theme_gray()</span><br><span class="line">print(plt)</span><br><span class="line"></span><br><span class="line">ggplot.save(plt, &quot;ggplot_plots.png&quot;, dpi=400)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这次，它终于没有报错！没有报错！没有报错！！！<br><img src="https://img-blog.csdnimg.cn/2020022015155596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;不过它保存出来的这个png格式文件……红框里面的内容不太一样，图上的点的颜色也有些许不同……这我就不是很清楚了。  </p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>&emsp;&emsp;我觉得，正是由于Python的ggplot模块没有R语言的ggplot2模块那么成熟，再加上官方已经有三年多的时间没有对其进行维护和升级了，这期间它所依赖的模块有所更新（比如pandas），才会导致这一系列问题。所以，如果想使用Python进行统计图表的绘制，相较于ggplot模块，matplotlib和seaborn会更加友好一些。  </p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/02/19/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9B%BE%E4%B8%8E%E5%9B%BE%E8%A1%A8(2)/">
                Python数据分析基础之图与图表(2)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-02-19</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <p>&emsp;&emsp;上一节主要学习了使用matplotlib模块绘制统计图。这一节主要学习使用pandas, seaborn等模块绘制统计图。  </p>
<h2 id="使用pandas绘制统计图"><a href="#使用pandas绘制统计图" class="headerlink" title="使用pandas绘制统计图"></a>使用pandas绘制统计图</h2><p>&emsp;&emsp;pandas模块提供了一个可以作用于序列和数据框的函数<code>plot()</code>，简化了基于序列和数据框中的数据创建图表的过程。<code>plot()</code>函数默认创建折线图，我们可以通过设置参数<code>kind</code>来创建其他类型的图表。<br>&emsp;&emsp;除了使用matplotlib模块创建标准统计图，还可以使用pandas模块可以创建其他类型的统计图，例如六边箱图（hexagonal bin plot）、矩阵散点图、密度图、Andrews曲线图、平行坐标图、延迟图、自相关图和自助抽样图。如果要向统计图中添加第二y轴、误差棒和数据表，使用pandas模块可以很直接地实现。<br>&emsp;&emsp;下面的代码是应用pandas模块创建一对条形图和箱线图的实例。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">plt.style.use(&apos;ggplot&apos;)</span><br><span class="line"></span><br><span class="line"># 准备数据</span><br><span class="line">fig, axes = plt.subplots(nrows=1, ncols=2)      # 创建两个并排放置的子图</span><br><span class="line">ax1, ax2 = axes.ravel()                         # 将两个子图分别赋给变量ax1和ax2</span><br><span class="line">data_frame = pd.DataFrame(np.random.rand(5, 3),</span><br><span class="line">                          index=[&apos;Customer 1&apos;, &apos;Customer 2&apos;, &apos;Customer 3&apos;, &apos;Customer 4&apos;, &apos;Customer 5&apos;],</span><br><span class="line">                          columns=pd.Index([&apos;Metric 1&apos;, &apos;Metric 2&apos;, &apos;Metric 3&apos;], name=&apos;Metrics&apos;))</span><br><span class="line"></span><br><span class="line"># 绘制条形图</span><br><span class="line">data_frame.plot(kind=&apos;bar&apos;, ax=ax1, alpha=0.75, title=&apos;Bar Plot&apos;)       # 创建条形图</span><br><span class="line">plt.setp(ax1.get_xticklabels(), rotation=45, fontsize=10)</span><br><span class="line">plt.setp(ax1.get_yticklabels(), rotation=0, fontsize=10)</span><br><span class="line">ax1.set_xlabel(&apos;Customer&apos;)</span><br><span class="line">ax1.set_ylabel(&apos;Value&apos;)</span><br><span class="line">ax1.xaxis.set_ticks_position(&apos;bottom&apos;)</span><br><span class="line">ax1.yaxis.set_ticks_position(&apos;left&apos;)</span><br><span class="line"></span><br><span class="line"># 绘制箱线图</span><br><span class="line">colors = dict(boxes=&apos;DarkBlue&apos;, whiskers=&apos;Gray&apos;, medians=&apos;Red&apos;, caps=&apos;Black&apos;)       # 为箱线图创建颜色字典</span><br><span class="line">data_frame.plot(kind=&apos;box&apos;, color=colors, sym=&apos;r.&apos;, ax=ax2, title=&apos;Box Plot&apos;)       # 创建箱线图</span><br><span class="line">plt.setp(ax2.get_xticklabels(), rotation=45, fontsize=10)</span><br><span class="line">plt.setp(ax2.get_yticklabels(), rotation=0, fontsize=10)</span><br><span class="line">ax2.set_xlabel(&apos;Metric&apos;)</span><br><span class="line">ax2.set_ylabel(&apos;Value&apos;)</span><br><span class="line">ax1.xaxis.set_ticks_position(&apos;bottom&apos;)</span><br><span class="line">ax1.yaxis.set_ticks_position(&apos;left&apos;)</span><br><span class="line"></span><br><span class="line"># 保存图片</span><br><span class="line">plt.savefig(&apos;pandas_plots.png&apos;, dpi=400, bbox_inches=&apos;tight&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;运行结果如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200219175354373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="使用seaborn绘制统计图"><a href="#使用seaborn绘制统计图" class="headerlink" title="使用seaborn绘制统计图"></a>使用seaborn绘制统计图</h2><p>&emsp;&emsp;seaborn模块简化了在Python中创建信息丰富的统计图表的过程。它可以创建标准统计图，包括直方图、密度图、条形图、箱线图和散点图。它可以对成对变量之间的相关性、线性与非线性回归模型以及统计估计的不确定性进行可视化。它可以用来在评估变量时检查变量之间的关系，并可以建立统计图矩阵来显示复杂的关系。它有内置的主题和调色板，可以用来制作精美的图标。最后，因为它是建立在matplotlib上的，所以我们可以使用matplotlib的命令来对图形进行更深入的定制。<br>&emsp;&emsp;下面的代码演示了如何使用seaborn创建各种统计图。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import seaborn as sns</span><br><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">sns.set(color_codes=True)</span><br><span class="line"></span><br><span class="line"># 直方图</span><br><span class="line">x = np.random.normal(size=100)</span><br><span class="line">sns.distplot(x, bins=20, kde=False, rug=True, label=&quot;Histogram w/o Density&quot;)</span><br><span class="line">sns.utils.axlabel(&quot;Value&quot;, &quot;Frequency&quot;)</span><br><span class="line">plt.title(&quot;Histogram of a Random Sample from a Normal Distribution&quot;)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.savefig(&quot;seaborn_plot_1.png&quot;, dpi=400, bbox_inches=&apos;tight&apos;)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"># 带有回归直线的散点图与单变量直方图</span><br><span class="line">mean, cov = [5, 10], [(1, .5), (.5, 1)]</span><br><span class="line">data = np.random.multivariate_normal(mean, cov, 200)</span><br><span class="line">data_frame = pd.DataFrame(data, columns=[&quot;x&quot;, &quot;y&quot;])</span><br><span class="line">sns.jointplot(x=&quot;x&quot;, y=&quot;y&quot;, data=data_frame, kind=&quot;reg&quot;).set_axis_labels(&quot;x&quot;, &quot;y&quot;)</span><br><span class="line">plt.suptitle(&quot;Joint Plot of Two Variables with Bivariate and Univariate Graphs&quot;)</span><br><span class="line">plt.savefig(&quot;seaborn_plot_2.png&quot;, dpi=400, bbox_inches=&apos;tight&apos;)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"># 成对变量之间的散点图与单变量直方图</span><br><span class="line">iris = sns.load_dataset(&quot;iris&quot;)</span><br><span class="line">sns.pairplot(iris)</span><br><span class="line">plt.savefig(&quot;seaborn_plot_3.png&quot;, dpi=400, bbox_inches=&apos;tight&apos;)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"># 按照某几个变量生成的箱线图</span><br><span class="line">tips = sns.load_dataset(&quot;tips&quot;)</span><br><span class="line">sns.catplot(x=&quot;time&quot;, y=&quot;total_bill&quot;, hue=&quot;smoker&quot;, col=&quot;day&quot;, data=tips, kind=&quot;box&quot;, height=4, aspect=.5)</span><br><span class="line">plt.savefig(&quot;seaborn_plot_4.png&quot;, dpi=400, bbox_inches=&apos;tight&apos;)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"># 带有bootstrap置信区间的线性回归模型</span><br><span class="line">sns.lmplot(x=&quot;total_bill&quot;, y=&quot;tip&quot;, data=tips)</span><br><span class="line">plt.savefig(&quot;seaborn_plot_5.png&quot;, dpi=400, bbox_inches=&apos;tight&apos;)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"># 带有bootstrap置信区间的逻辑斯蒂回归模型</span><br><span class="line">tips[&quot;big_tip&quot;] = (tips.tip / tips.total_bill) &gt; .15</span><br><span class="line">sns.lmplot(x=&quot;total_bill&quot;, y=&quot;big_tip&quot;, data=tips, logistic=True, y_jitter=.03).set_axis_labels(&quot;Total Bill&quot;, &quot;Big Tip&quot;)</span><br><span class="line">plt.title(&quot;Logistic Regression of Big Tip vs.Total Bill&quot;)</span><br><span class="line">plt.savefig(&quot;seaborn_plot_6.png&quot;, dpi=400, bbox_inches=&apos;tight&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;运行结果如下图所示。<br><img src="https://img-blog.csdnimg.cn/2020021921315838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/2020021921322176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200219213242114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200219213301861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200219213321535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200219213346185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/02/19/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9B%BE%E4%B8%8E%E5%9B%BE%E8%A1%A8(1)/">
                Python数据分析基础之图与图表(1)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-02-19</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <blockquote>
<p>参考资料：<br>《Python数据分析基础》，作者[美]Clinton W. Brownley，译者陈光欣，中国工信出版集团，人民邮电出版社</p>
</blockquote>
<p>&emsp;&emsp;数据可视化主要旨在借助于图形化手段，清晰有效地传达与沟通信息。它可以使我们看到变量的分布和变量之间的关系，还可以检查建模过程中的假设。<br>&emsp;&emsp;Python提供了若干种用于绘图的扩展包，包括matplotlib, pandas, ggplot和seaborn。<br>&emsp;&emsp;这一节主要对matplotlib进行学习。<br>&emsp;&emsp;有关matplotlib的相关函数及说明，可以参考我以前写的两篇博客：<a href="https://blog.csdn.net/qq_45554010/article/details/103628992" target="_blank" rel="noopener">《【总结篇】Python matplotlib之使用函数绘制matplotlib的图表组成元素》</a><a href="https://blog.csdn.net/qq_45554010/article/details/103643470" target="_blank" rel="noopener">《【总结篇】Python matplotlib之使用统计函数绘制简单图形》</a>。  </p>
<h2 id="使用matplotlib绘制条形图"><a href="#使用matplotlib绘制条形图" class="headerlink" title="使用matplotlib绘制条形图"></a>使用matplotlib绘制条形图</h2><p>&emsp;&emsp;代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">plt.style.use(&apos;ggplot&apos;)                     # 使用ggplot样式表来模拟ggplot2风格的图形</span><br><span class="line"></span><br><span class="line"># 为条形图准备数据</span><br><span class="line">customers = [&apos;ABC&apos;, &apos;DEF&apos;, &apos;GHI&apos;, &apos;JKL&apos;, &apos;MNO&apos;]</span><br><span class="line">customers_index = range(len(customers))</span><br><span class="line">sale_amounts = [127, 90, 201, 111, 232]</span><br><span class="line"></span><br><span class="line"># 绘图</span><br><span class="line">fig = plt.figure()                          # 创建了一个基础图</span><br><span class="line">ax1 = fig.add_subplot(1, 1, 1)              # 在基础图中创建1行1列的子图，并使用第1个也是唯一的一个子图</span><br><span class="line">ax1.bar(customers_index, sale_amounts, align=&apos;center&apos;, color=&apos;darkblue&apos;)    # 创建条形图</span><br><span class="line">ax1.xaxis.set_ticks_position(&apos;bottom&apos;)      # x刻度线位置</span><br><span class="line">ax1.yaxis.set_ticks_position(&apos;left&apos;)        # y刻度线位置</span><br><span class="line">plt.xticks(customers_index, customers, rotation=0, fontsize=&apos;small&apos;)        # 将刻度线标签更改为实际的客户名称</span><br><span class="line">plt.xlabel(&apos;Customer Name&apos;)                 # 添加x轴标签</span><br><span class="line">plt.ylabel(&apos;Sale Amount&apos;)                   # 添加y轴标签</span><br><span class="line">plt.title(&apos;Sale Amount per Customer&apos;)       # 添加图形标题</span><br><span class="line">plt.savefig(&apos;bar_plot.png&apos;, dpi=400, bbox_inches=&apos;tight&apos;)       # 保存统计图到当前文件夹</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips:<br>ax1.bar(customers_index, sale_amounts, align=’center’, color=’darkblue’)<br>customer_index：设置条形图左侧在x轴上的坐标<br>sale_amounts：设置条形的高度<br>align=’center’：设置条形与标签中间对齐<br>color=’darkblue’：设置标签的颜色</p>
</blockquote>
<blockquote>
<p>Tips:<br>plt.xticks(customers_index, customers, rotation=0, fontsize=’small’)<br>rotation=0：刻度标签是水平的<br>fontsize=’small’：将刻度标签的字体设为小字体</p>
</blockquote>
<blockquote>
<p>Tips:<br>plt.savefig(‘bar_plot.png’, dpi=400, bbox_inches=’tight’)<br>dpi=400：设置图形分辨率<br>bbox_inches=’tight’：在保存图形时，将图形四周的空白部分去掉</p>
</blockquote>
<p>&emsp;&emsp;运行结果如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200218223508577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="使用matplotlib绘制直方图"><a href="#使用matplotlib绘制直方图" class="headerlink" title="使用matplotlib绘制直方图"></a>使用matplotlib绘制直方图</h2><p>&emsp;&emsp;代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">plt.style.use(&apos;ggplot&apos;)</span><br><span class="line"></span><br><span class="line"># 为直方图准备数据</span><br><span class="line">mu1, mu2, sigma = 100, 130, 15</span><br><span class="line">x1 = mu1 + sigma * np.random.randn(10000)        # 使用随机数生成器创建两个正态分布变量</span><br><span class="line">x2 = mu2 + sigma * np.random.randn(10000)</span><br><span class="line"></span><br><span class="line"># 绘图</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax1 = fig.add_subplot(1, 1, 1)</span><br><span class="line">n, bins, patches = ax1.hist(x1, bins=50, density=False, color=&apos;darkgreen&apos;)          # 创建概率分布图</span><br><span class="line">n, bins, patches = ax1.hist(x2, bins=50, density=False, color=&apos;orange&apos;, alpha=0.5)</span><br><span class="line">ax1.xaxis.set_ticks_position(&apos;bottom&apos;)</span><br><span class="line">ax1.yaxis.set_ticks_position(&apos;left&apos;)</span><br><span class="line">plt.xlabel(&apos;Bins&apos;)</span><br><span class="line">plt.ylabel(&apos;Number of Values in Bin&apos;)</span><br><span class="line">fig.suptitle(&apos;Histograms&apos;, fontsize=14, fontweight=&apos;bold&apos;)      # 为基础图添加一个居中的标题</span><br><span class="line">ax1.set_title(&apos;Two Frequency Distributions&apos;)    # 为子图添加一个居中的标题，位于基础图标题下面</span><br><span class="line">plt.savefig(&apos;histogram.png&apos;, dpi=400, bbox_inches=&apos;tight&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips:<br>n, bins, patches = ax1.hist(x2, bins=50, density=False, color=’orange’, alpha=0.5)<br>bins=50：每个变量的值被分成50份<br>density=False：直方图显示的是频率分布，而不是概率密度<br>color=’darkgreen’：直方图颜色<br>alpha=0.5：透明度</p>
</blockquote>
<p>&emsp;&emsp;运行结果如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200218223538952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="使用matplotlib绘制折线图"><a href="#使用matplotlib绘制折线图" class="headerlink" title="使用matplotlib绘制折线图"></a>使用matplotlib绘制折线图</h2><p>&emsp;&emsp;代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">from numpy.random import randn</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">plt.style.use(&apos;ggplot&apos;)</span><br><span class="line"></span><br><span class="line"># 为折线图准备数据</span><br><span class="line">plot_data1 = randn(50).cumsum()         # 使用randn创建绘图所用的随机数据</span><br><span class="line">plot_data2 = randn(50).cumsum()</span><br><span class="line">plot_data3 = randn(50).cumsum()</span><br><span class="line">plot_data4 = randn(50).cumsum()</span><br><span class="line"></span><br><span class="line"># 绘图</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax1 = fig.add_subplot(1, 1, 1)</span><br><span class="line">ax1.plot(plot_data1, marker=r&apos;o&apos;, color=u&apos;blue&apos;, linestyle=&apos;-&apos;, label=&apos;Blue Solid&apos;)     # 创建4条折线</span><br><span class="line">ax1.plot(plot_data2, marker=r&apos;+&apos;, color=u&apos;red&apos;, linestyle=&apos;--&apos;, label=&apos;Red Dashed&apos;)</span><br><span class="line">ax1.plot(plot_data3, marker=r&apos;*&apos;, color=u&apos;green&apos;, linestyle=&apos;-.&apos;, label=&apos;Green Dash Dot&apos;)</span><br><span class="line">ax1.plot(plot_data4, marker=r&apos;s&apos;, color=u&apos;orange&apos;, linestyle=&apos;:&apos;, label=&apos;Orange Dotted&apos;)</span><br><span class="line">ax1.xaxis.set_ticks_position(&apos;bottom&apos;)</span><br><span class="line">ax1.yaxis.set_ticks_position(&apos;left&apos;)</span><br><span class="line">ax1.set_title(&apos;Line Plots: Markers, Colors, and Linestyles&apos;)</span><br><span class="line">plt.xlabel(&apos;Draw&apos;)</span><br><span class="line">plt.ylabel(&apos;Random Number&apos;)</span><br><span class="line">plt.legend(loc=&apos;best&apos;)      # 创建图例，根据图中的空白部分将图例放在最合适的位置</span><br><span class="line">plt.savefig(&apos;line_plot.png&apos;, dpi=400, bbox_inches=&apos;tight&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips:<br>ax1.plot(plot_data2, marker=r’+’, color=u’red’, linestyle=’–’, label=’Red Dashed’)<br>marker=r’+’：数据点类型<br>color=u’red’：颜色<br>linestyle=’–’：线型<br>label=’Red Dashed’：保证折线在图例中可以正确标记</p>
</blockquote>
<p>&emsp;&emsp;运行结果如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200218232430928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="使用matplotlib绘制散点图"><a href="#使用matplotlib绘制散点图" class="headerlink" title="使用matplotlib绘制散点图"></a>使用matplotlib绘制散点图</h2><p>&emsp;&emsp;代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">plt.style.use(&apos;ggplot&apos;)</span><br><span class="line"></span><br><span class="line"># 为散点图准备数据</span><br><span class="line">x = np.arange(start=1, stop=15, step=1)</span><br><span class="line">y_linear = x + 5 * np.random.randn(14)</span><br><span class="line">y_quadratic = x**2 + 10 * np.random.randn(14)</span><br><span class="line">fn_linear = np.poly1d(np.polyfit(x, y_linear, deg=1))</span><br><span class="line">fn_quadratic = np.poly1d(np.polyfit(x, y_quadratic, deg=2))</span><br><span class="line"></span><br><span class="line"># 绘图</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax1 = fig.add_subplot(1, 1, 1)</span><br><span class="line">ax1.plot(x, y_linear, &apos;bo&apos;, x, y_quadratic, &apos;go&apos;, x, fn_linear(x), &apos;b-&apos;,</span><br><span class="line">         x, fn_quadratic(x), &apos;g-&apos;, linewidth=2)                # 创建带有两条回归曲线的散点图</span><br><span class="line">ax1.xaxis.set_ticks_position(&apos;bottom&apos;)</span><br><span class="line">ax1.yaxis.set_ticks_position(&apos;left&apos;)</span><br><span class="line">ax1.set_title(&apos;Scatter Plots Regression Lines&apos;)</span><br><span class="line">plt.xlabel(&apos;x&apos;)</span><br><span class="line">plt.ylabel(&apos;f(x)&apos;)</span><br><span class="line">plt.xlim((min(x) - 1, max(x) + 1))        # 设置x轴范围</span><br><span class="line">plt.ylim((min(y_quadratic) - 10, max(y_quadratic) + 10))      # 设置y轴范围</span><br><span class="line">plt.savefig(&apos;scatter_plot.png&apos;, dpi=400, bbox_inches=&apos;tight&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips:<br>ax1.plot(x, y_linear, ‘bo’, x, y_quadratic, ‘go’, x, fn_linear(x), ‘b-‘, x, fn_quadratic(x), ‘g-‘, linewidth=2)<br>‘bo’：(x, y_linear)点是蓝色圆圈<br>‘go’：(x, y_quadratic)点是绿色圆圈<br>‘b-‘：(x, y_linear)点之间的线是一条蓝色实线<br>‘g-‘：(x, y_quadratic)点之间的线是一条绿色实线<br>linewidth=2：线的宽度</p>
</blockquote>
<p>&emsp;&emsp;运行结果如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200218233958906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="使用matplotlib绘制箱线图"><a href="#使用matplotlib绘制箱线图" class="headerlink" title="使用matplotlib绘制箱线图"></a>使用matplotlib绘制箱线图</h2><p>&emsp;&emsp;代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">plt.style.use(&apos;ggplot&apos;)</span><br><span class="line"></span><br><span class="line"># 为箱线图准备数据</span><br><span class="line">N = 500</span><br><span class="line">normal = np.random.normal(loc=0.0, scale=1.0, size=N)</span><br><span class="line">lognormal = np.random.lognormal(mean=0.0, sigma=1.0, size=N)</span><br><span class="line">index_value = np.random.random_integers(low=0, high=N-1, size=N)</span><br><span class="line">normal_sample = normal[index_value]</span><br><span class="line">lognormal_sample = lognormal[index_value]</span><br><span class="line">box_plot_data = [normal, normal_sample, lognormal, lognormal_sample]</span><br><span class="line"></span><br><span class="line"># 绘图</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax1 = fig.add_subplot(1, 1, 1)</span><br><span class="line">box_labels = [&apos;normal&apos;, &apos;normal_sample&apos;, &apos;lognormal&apos;, &apos;lognormal_sample&apos;]       # 保存每个箱线图的标签</span><br><span class="line">ax1.boxplot(box_plot_data, notch=False, sym=&apos;.&apos;, vert=True, whis=1.5, showmeans=True,</span><br><span class="line">            labels=box_labels)          # 创建4个箱线图</span><br><span class="line">ax1.xaxis.set_ticks_position(&apos;bottom&apos;)</span><br><span class="line">ax1.yaxis.set_ticks_position(&apos;left&apos;)</span><br><span class="line">ax1.set_title(&apos;Box Plots: Resampling of Two Distributions&apos;)</span><br><span class="line">plt.xlabel(&apos;Distribution&apos;)</span><br><span class="line">plt.ylabel(&apos;Value&apos;)</span><br><span class="line">plt.savefig(&apos;box_plot.png&apos;, dpi=400, bbox_inches=&apos;tight&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Tips:<br>ax1.boxplot(box_plot_data, notch=False, sym=’.’, vert=True, whis=1.5, showmeans=True, labels=box_labels)<br>notch=False：箱体是矩形，而不是在中间收缩<br>sym=’.’：表示离群点使用圆点，而不是默认的+符号<br>vert=True：箱体是垂直的，不是水平的<br>whis=1.5：设定了直线从第一四分位数和第三四分位数延伸出的范围<br>showmeans=True：箱体在显示中位数的同时也显示均值<br>labels=box_labels：使用box_labels中的值来标记箱线图</p>
</blockquote>
<p>&emsp;&emsp;运行结果如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200218235034791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/02/18/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/">
                Python数据分析基础之应用程序
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-02-18</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <blockquote>
<p>参考资料：<br>《Python数据分析基础》，作者[美]Clinton W. Brownley，译者陈光欣，中国工信出版集团，人民邮电出版社</p>
</blockquote>
<h2 id="在一个大文件集合中查找一组项目"><a href="#在一个大文件集合中查找一组项目" class="headerlink" title="在一个大文件集合中查找一组项目"></a>在一个大文件集合中查找一组项目</h2><p>&emsp;&emsp;当我们有大量历史数据的时候，要找到真正需要的数据是非常困难的。我们可以打开每个文件，找出需要的记录，并将其复制粘贴到一个新文件中。但这个过程既浪费时间，又容易出错。使用Python可以自动化地完成整个过程，既节省时间，又不会出错。<br>&emsp;&emsp;首先，我们在合适的位置创建一个文件夹，命名为file_archive。然后，我们打开Excel，输入下图所示的数据，并将其命名为supplies_2012.csv保存在file_archive文件夹中。<br><img src="https://img-blog.csdnimg.cn/20200218151216477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;我们再打开Excel，如下图所示创建一个Excel工作簿，命名为supplies.xls，并保存在file_archive文件夹中。这个Excel工作簿中包含两个工作表：supplies_2013和supplies_2014。<br><img src="https://img-blog.csdnimg.cn/20200218151451454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200218151500213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;然后，我们将这个Excel工作簿另存为supplies.xlsx，同样保存在file_archive文件夹中。<br><img src="https://img-blog.csdnimg.cn/20200218151645484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200218151655838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;现在，在file_archive文件夹中应该有3个文件。<br><img src="https://img-blog.csdnimg.cn/20200218151751773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;我们还需要建立一个item_numbers_to_find.csv文件。我们要搜索的5个数值项目就是下表所示的5个数值。<br><img src="https://img-blog.csdnimg.cn/20200218152019715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;我们的搜索任务是，搜索file_archive文件夹，找出包含我们所需的数值项目的文件，当找到一个数值项目时，需要把包含这个项目的整行数据写入输出文件。<br>&emsp;&emsp;Python脚本的代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import csv</span><br><span class="line">import glob</span><br><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line">from datetime import date</span><br><span class="line">from xlrd import open_workbook, xldate_as_tuple</span><br><span class="line"></span><br><span class="line">item_numbers_file = sys.argv[1]</span><br><span class="line">path_to_folder = sys.argv[2]</span><br><span class="line">output_file = sys.argv[3]</span><br><span class="line"></span><br><span class="line">item_numbers_to_find = []</span><br><span class="line">with open(item_numbers_file, &apos;r&apos;, newline=&apos;&apos;) as item_numbers_csv_file:</span><br><span class="line">    filereader = csv.reader(item_numbers_csv_file)</span><br><span class="line">    for row in filereader:</span><br><span class="line">        item_numbers_to_find.append(row[0])</span><br><span class="line">print(item_numbers_to_find)</span><br><span class="line"></span><br><span class="line">filewriter = csv.writer(open(output_file, &apos;a&apos;, newline=&apos;&apos;))</span><br><span class="line">file_counter = 0</span><br><span class="line">line_counter = 0</span><br><span class="line">count_of_item_numbers = 0</span><br><span class="line">for input_file in glob.glob(os.path.join(path_to_folder, &apos;*.*&apos;)):</span><br><span class="line">    file_counter += 1</span><br><span class="line">    if input_file.split(&apos;.&apos;)[1] == &apos;csv&apos;:</span><br><span class="line">        with open(input_file, &apos;r&apos;, newline=&apos;&apos;) as csv_in_file:</span><br><span class="line">            filereader = csv.reader(csv_in_file)</span><br><span class="line">            header = next(filereader)</span><br><span class="line">            for row in filereader:</span><br><span class="line">                row_of_output = []</span><br><span class="line">                for column in range(len(header)):</span><br><span class="line">                    if column == 3:</span><br><span class="line">                        cell_value = str(row[column]).lstrip(&apos;$&apos;).replace(&apos;,&apos;, &apos;&apos;).strip()</span><br><span class="line">                        row_of_output.append(cell_value)</span><br><span class="line">                    else:</span><br><span class="line">                        cell_value = str(row[column]).strip()</span><br><span class="line">                        row_of_output.append(cell_value)</span><br><span class="line">                row_of_output.append(os.path.basename(input_file))</span><br><span class="line">                if row[0] in item_numbers_to_find:</span><br><span class="line">                    filewriter.writerow(row_of_output)</span><br><span class="line">                    count_of_item_numbers += 1</span><br><span class="line">                line_counter += 1</span><br><span class="line">    elif input_file.split(&apos;.&apos;)[1] == &apos;xls&apos; or input_file.split(&apos;.&apos;)[1] == &apos;xlsx&apos;:</span><br><span class="line">        workbook = open_workbook(input_file)</span><br><span class="line">        for worksheet in workbook.sheets():</span><br><span class="line">            try:</span><br><span class="line">                header = worksheet.row_values(0)</span><br><span class="line">            except IndexError:</span><br><span class="line">                pass</span><br><span class="line">            for row in range(1, worksheet.nrows):</span><br><span class="line">                row_of_output = []</span><br><span class="line">                for column in range(len(header)):</span><br><span class="line">                    if worksheet.cell_type(row, column) == 3:</span><br><span class="line">                        cell_value = xldate_as_tuple(worksheet.cell(row, column).value, workbook.datemode)</span><br><span class="line">                        cell_value = str(date(*cell_value[0:3])).strip()</span><br><span class="line">                        row_of_output.append(cell_value)</span><br><span class="line">                    else:</span><br><span class="line">                        cell_value = str(worksheet.cell_value(row, column)).strip()</span><br><span class="line">                        row_of_output.append(cell_value)</span><br><span class="line">                row_of_output.append(os.path.basename(input_file))</span><br><span class="line">                row_of_output.append(worksheet.name)</span><br><span class="line">                if str(worksheet.cell(row, 0).value).split(&apos;.&apos;)[0].strip() in item_numbers_to_find:</span><br><span class="line">                    filewriter.writerow(row_of_output)</span><br><span class="line">                    count_of_item_numbers += 1</span><br><span class="line">                line_counter += 1</span><br><span class="line"></span><br><span class="line">print(&apos;Number of files: &apos;, file_counter)</span><br><span class="line">print(&apos;Number of lines: &apos;, line_counter)</span><br><span class="line">print(&apos;Number of item numbers: &apos;, count_of_item_numbers)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个脚本看似很长，但其实都是前面学过的内容，它只是将前面三章的内容综合了一下。我们在命令行窗口中运行这个脚本。<br><img src="https://img-blog.csdnimg.cn/20200218152644661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200218152741242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="为CSV文件中数据的任意数目分类计算统计量"><a href="#为CSV文件中数据的任意数目分类计算统计量" class="headerlink" title="为CSV文件中数据的任意数目分类计算统计量"></a>为CSV文件中数据的任意数目分类计算统计量</h2><p>&emsp;&emsp;我们创建一个CSV数据文件customer_category_history.csv，其中包含一个客户购买服务包的数据集。<br><img src="https://img-blog.csdnimg.cn/20200218164357532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;我们需要做的，是在这个数据集上执行计算，得到客户在他们购买的每个服务包类别上花费的总时间。代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import csv</span><br><span class="line">import sys</span><br><span class="line">from datetime import date, datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def date_diff(date1, date2):</span><br><span class="line">    try:</span><br><span class="line">        diff = str(datetime.strptime(date1, &apos;%m/%d/%Y&apos;) - datetime.strptime(date2, &apos;%m/%d/%Y&apos;)).split()[0]</span><br><span class="line">    except:</span><br><span class="line">        diff = 0</span><br><span class="line">    if diff == &apos;0:00:00&apos;:</span><br><span class="line">        diff = 0</span><br><span class="line">    return diff</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">packages = &#123;&#125;</span><br><span class="line">previous_name = &apos;N/A&apos;</span><br><span class="line">previous_package = &apos;N/A&apos;</span><br><span class="line">previous_package_date = &apos;N/A&apos;</span><br><span class="line">first_row = True</span><br><span class="line">today = date.today().strftime(&apos;%m/%d/%Y&apos;)</span><br><span class="line">with open(input_file, &apos;r&apos;, newline=&apos;&apos;) as input_csv_file:</span><br><span class="line">    filereader = csv.reader(input_csv_file)</span><br><span class="line">    header = next(filereader)</span><br><span class="line">    for row in filereader:</span><br><span class="line">        current_name = row[0]</span><br><span class="line">        current_package = row[1]</span><br><span class="line">        current_package_date = row[3]</span><br><span class="line">        if current_name not in packages:</span><br><span class="line">            packages[current_name] = &#123;&#125;</span><br><span class="line">        if current_package not in packages[current_name]:</span><br><span class="line">            packages[current_name][current_package] = 0</span><br><span class="line">        if current_name != previous_name:</span><br><span class="line">            if first_row:</span><br><span class="line">                first_row = False</span><br><span class="line">            else:</span><br><span class="line">                diff = date_diff(today, previous_package_date)</span><br><span class="line">                if previous_package not in packages[previous_name]:</span><br><span class="line">                    packages[previous_name][previous_package] = int(diff)</span><br><span class="line">                else:</span><br><span class="line">                    packages[previous_name][previous_package] += int(diff)</span><br><span class="line">        else:</span><br><span class="line">            diff = date_diff(current_package_date, previous_package_date)</span><br><span class="line">            packages[previous_name][previous_package] += int(diff)</span><br><span class="line">        previous_name = current_name</span><br><span class="line">        previous_package = current_package</span><br><span class="line">        previous_package_date = current_package_date</span><br><span class="line"></span><br><span class="line">header = [&apos;Customer Name&apos;, &apos;Category&apos;, &apos;Total Time (in Days)&apos;]</span><br><span class="line">with open(output_file, &apos;w&apos;, newline=&apos;&apos;) as output_csv_file:</span><br><span class="line">    filewriter = csv.writer(output_csv_file)</span><br><span class="line">    filewriter.writerow(header)</span><br><span class="line">    for customer_name, customer_name_value in packages.items():</span><br><span class="line">        for package_category, package_category_value in packages[customer_name].items():</span><br><span class="line">            row_of_output = []</span><br><span class="line">            print(customer_name, package_category, package_category_value)</span><br><span class="line">            row_of_output.append(customer_name)</span><br><span class="line">            row_of_output.append(package_category)</span><br><span class="line">            row_of_output.append(package_category_value)</span><br><span class="line">            filewriter.writerow(row_of_output)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个脚本使用了Python字典数据结构来组织和保存计算结果。实际上，这个脚本中使用的字典是嵌套的字典。外部字典的名称为<code>packages</code>，键为客户名称，与其对应的值是另一个字典，其中的键为服务包类别的名称，值为客户拥有这个服务包的天数。<br>&emsp;&emsp;我们在命令行窗口中运行这个脚本。<br><img src="https://img-blog.csdnimg.cn/20200218173552696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200218173621622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="为文本文件中数据的任意数目分类计算统计量"><a href="#为文本文件中数据的任意数目分类计算统计量" class="headerlink" title="为文本文件中数据的任意数目分类计算统计量"></a>为文本文件中数据的任意数目分类计算统计量</h2><p>&emsp;&emsp;文本文件（也称平面文件）也是商业中常用的文件类型。CSV文件实际上就是以逗号分隔的文本文件形式保存的。活动日志、错误日志和交易记录是商业数据保存在文本文件中的几个更常见的例子。<br>&emsp;&emsp;接下来我们试着访问MySQL错误日志。  </p>
<blockquote>
<p>作者注：MySQL错误日志文件的路径为：C:\ProgramData\MySQL\MySQL Server 8.0\Data\LAPTOP-LNF22KFU.err  </p>
</blockquote>
<p>&emsp;&emsp;我们选择以记事本方式打开该文件，可以看到错误日志中的信息。<br><img src="https://img-blog.csdnimg.cn/20200218174535926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;每个人的MySQL错误日志文件中的数据是不一样的。参考书上为我们提供了一个独立的、有代表性的MySQL错误日志文件，我们把它<a href="https://github.com/cbrownley/foundations-for-analytics-with-python/tree/master/applications" target="_blank" rel="noopener">下载</a>下来。<br><img src="https://img-blog.csdnimg.cn/20200218174943427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;接下来，我们需要做的就是通过Python脚本来进行错误消息的分析和计算。代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">messages = &#123;&#125;</span><br><span class="line">notes = []</span><br><span class="line">with open(input_file, &apos;r&apos;, newline=&apos;&apos;) as text_file:</span><br><span class="line">    for row in text_file:</span><br><span class="line">        if &apos;[Note]&apos; in row:</span><br><span class="line">            row_list = row.split(&apos; &apos;, 4)</span><br><span class="line">            day = row_list[0].strip()</span><br><span class="line">            note = row_list[4].strip(&apos;\n&apos;).strip()</span><br><span class="line">            if note not in notes:</span><br><span class="line">                notes.append(note)</span><br><span class="line">            if day not in messages:</span><br><span class="line">                messages[day] = &#123;&#125;</span><br><span class="line">            if note not in messages[day]:</span><br><span class="line">                messages[day][note] = 1</span><br><span class="line">            else:</span><br><span class="line">                messages[day][note] += 1</span><br><span class="line"></span><br><span class="line">filewriter = open(output_file, &apos;w&apos;, newline=&apos;&apos;)</span><br><span class="line">header = [&apos;Date&apos;]</span><br><span class="line">header.extend(notes)</span><br><span class="line">header = &apos;,&apos;.join(map(str, header)) + &apos;\n&apos;</span><br><span class="line">print(header)</span><br><span class="line">filewriter.write(header)</span><br><span class="line">for day, day_value in messages.items():</span><br><span class="line">    row_of_output = []</span><br><span class="line">    row_of_output.append(day)</span><br><span class="line">    for index in range(len(notes)):</span><br><span class="line">        if notes[index] in day_value.keys():</span><br><span class="line">            row_of_output.append(day_value[notes[index]])</span><br><span class="line">        else:</span><br><span class="line">            row_of_output.append(0)</span><br><span class="line">    output = &apos;,&apos;.join(map(str, row_of_output)) + &apos;\n&apos;</span><br><span class="line">    print(output)</span><br><span class="line">    filewriter.write(output)</span><br><span class="line">filewriter.close()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们在命令行窗口中运行这个脚本。<br><img src="https://img-blog.csdnimg.cn/20200218180006118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200218180026560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/02/15/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AF%92%E5%81%87%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%80%BB%E7%BB%93/">
                实验室寒假数据处理任务总结
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-02-15</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <p>想获取输入数据和源代码？<a href="https://github.com/CCH21/Data_processing" target="_blank" rel="noopener">点这里</a>！  </p>
<hr>
<p><strong>处理一</strong>：将数据中所有信息有问题的那行信息删除。如样例中第4行数据，这一行数据只有3个元素，而其他行都有6个元素，所以删除第4行即可。再如最后一行第3个信息明显有问题，所以该行也是问题行，删除即可。将全部数据处理完之后，每行单个元素以逗号为分隔，写入文件test1。<br><strong>输入数据样例</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">18 Jogging 102271561469000 -13.53 16.89 -6.4</span><br><span class="line">18 Jogging 102271641608000 -5.75 16.89 -0.46</span><br><span class="line">18 Jogging 102271681617000 -2.18 16.32 11.07</span><br><span class="line">18 Jogging 3.36</span><br><span class="line">18 Downstairs 103260201636000 -4.44 7.06 1.95</span><br><span class="line">18 Downstairs 103260241614000 -3.87 7.55 3.3</span><br><span class="line">18 Downstairs 103260321693000 -4.06 8.08 4.79</span><br><span class="line">18 Downstairs 103260365577000 -6.32 8.66 4.94</span><br><span class="line">18 Downstairs 103260403083000 -5.37 11.22 3.06</span><br><span class="line">18 Downstairs 103260443305000 -5.79 9.92 2.53</span><br><span class="line">6 Walking 0 0 0 3.214402</span><br></pre></td></tr></table></figure>

<p><strong>输出test1样例</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">18,Jogging,102271561469000,-13.53,16.89,-6.4</span><br><span class="line">18,Jogging,102271641608000,-5.75,16.89,-0.46</span><br><span class="line">18,Jogging,102271681617000,-2.18,16.32,11.07</span><br><span class="line">18,Downstairs,103260201636000,-4.44,7.06,1.95</span><br><span class="line">18,Downstairs,103260241614000,-3.87,7.55,3.3</span><br><span class="line">18,Downstairs,103260321693000,-4.06,8.08,4.79</span><br><span class="line">18,Downstairs,103260365577000,-6.32,8.66,4.94</span><br><span class="line">18,Downstairs,103260403083000,-5.37,11.22,3.06</span><br><span class="line">18,Downstairs,103260443305000,-5.79,9.92,2.53</span><br></pre></td></tr></table></figure>

<p><strong>我的代码</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import csv</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">with open(input_file, &apos;r&apos;, newline=&apos;&apos;) as csv_in_file:</span><br><span class="line">    with open(output_file, &apos;w&apos;, newline=&apos;&apos;) as csv_out_file:</span><br><span class="line">        filereader = csv.reader(csv_in_file, delimiter=&apos; &apos;)</span><br><span class="line">        filewriter = csv.writer(csv_out_file)</span><br><span class="line">        for row_list in filereader:</span><br><span class="line">            if len(row_list) == 6 and row_list[2] != &apos;0&apos;:</span><br><span class="line">                filewriter.writerow(row_list)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;处理一是一个数据清洗的过程。输出文件的要求是“每行单个元素以逗号为分隔”，这不难让人想到要使用CSV逗号分隔值文件。首先对输入文件和输出文件进行打开操作，然后使用csv模块的<code>reader()</code>和<code>writer()</code>函数分别创建了两个对象<code>filereader</code>和<code>filewriter</code>。因为输入文件的每行的单个元素都以空格分隔，因此我们在创建对象<code>filereader</code>的时候，需要把<code>reader()</code>函数的<code>delimiter</code>参数设置为<code>delimiter=&#39; &#39;</code>，表示以空格作为分隔符。<br>&emsp;&emsp;我们来分析一下数据样本。样本中有问题的数据行有两种，一种类似于上面输入数据样例的第4行数据，缺少数据元素；另一种类似于输入数据样例的最后一行数据，第3列的数据元素为0。针对第一类问题，我们可以通过判断列表长度的方法将其筛掉，即判断<code>len(row_list)</code>是否为6。而对于第二类问题，我们只需要判断<code>row_list</code>列表中索引为2的元素是否为<code>&#39;0&#39;</code>（注意这里的0是一个字符而并非一个数字）。对于满足条件的数据行，我们将其写入输出文件。  </p>
<hr>
<p><strong>处理二</strong>：将test1数据中所有动作的数目统计出来，将动作数目打印到屏幕。然后将动作数目变为100的倍数，多余的删除，将数据行写入输出文件test2。比如统计出Jogging的数量为3021次，那么打印出3021后只往输出文件test2中写入3000条。<br><strong>我的代码</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import csv</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">movementsDict = &#123;&#125;</span><br><span class="line">inputData = []</span><br><span class="line">with open(input_file, &apos;r&apos;, newline=&apos;&apos;) as csv_in_file:</span><br><span class="line">    filereader = csv.reader(csv_in_file)</span><br><span class="line">    movementsList = []</span><br><span class="line">    for row_list in filereader:</span><br><span class="line">        movementsList.append(row_list[1])</span><br><span class="line">    for movement in movementsList:</span><br><span class="line">        if movement not in movementsDict:</span><br><span class="line">            movementsDict[movement] = 1</span><br><span class="line">        else:</span><br><span class="line">            movementsDict[movement] += 1</span><br><span class="line">    for movement, movementsDict[movement] in movementsDict.items():</span><br><span class="line">        print(&apos;Movement: %-15s&apos; % movement, end=&apos;&apos;)</span><br><span class="line">        print(&apos;Amount: &apos; + str(movementsDict[movement]))</span><br><span class="line">        movementsDict[movement] = movementsDict[movement] // 100 * 100</span><br><span class="line">        inputData.append(movementsDict[movement])</span><br><span class="line">    csv_in_file.seek(0, 0)</span><br><span class="line">    with open(output_file, &apos;w&apos;, newline=&apos;&apos;) as csv_out_file:</span><br><span class="line">        filewriter = csv.writer(csv_out_file)</span><br><span class="line">        countWalking = 0</span><br><span class="line">        countJogging = 0</span><br><span class="line">        countUpstairs = 0</span><br><span class="line">        countDownstairs = 0</span><br><span class="line">        countStanding = 0</span><br><span class="line">        countSitting = 0</span><br><span class="line">        for row_list in filereader:</span><br><span class="line">            if row_list[1] == &apos;Walking&apos;:</span><br><span class="line">                if countWalking &lt; inputData[0]:</span><br><span class="line">                    filewriter.writerow(row_list)</span><br><span class="line">                    countWalking += 1</span><br><span class="line">            elif row_list[1] == &apos;Jogging&apos;:</span><br><span class="line">                if countJogging &lt; inputData[1]:</span><br><span class="line">                    filewriter.writerow(row_list)</span><br><span class="line">                    countJogging += 1</span><br><span class="line">            elif row_list[1] == &apos;Upstairs&apos;:</span><br><span class="line">                if countUpstairs &lt; inputData[2]:</span><br><span class="line">                    filewriter.writerow(row_list)</span><br><span class="line">                    countUpstairs += 1</span><br><span class="line">            elif row_list[1] == &apos;Downstairs&apos;:</span><br><span class="line">                if countDownstairs &lt; inputData[3]:</span><br><span class="line">                    filewriter.writerow(row_list)</span><br><span class="line">                    countDownstairs += 1</span><br><span class="line">            elif row_list[1] == &apos;Standing&apos;:</span><br><span class="line">                if countStanding &lt; inputData[4]:</span><br><span class="line">                    filewriter.writerow(row_list)</span><br><span class="line">                    countStanding += 1</span><br><span class="line">            else:</span><br><span class="line">                if countSitting &lt; inputData[5]:</span><br><span class="line">                    filewriter.writerow(row_list)</span><br><span class="line">                    countSitting += 1</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;对于计数，我们可以应用Python的字典。这和我之前写过的统计文章中单次出现的次数的程序类似。首先建立一个空字典<code>movementsDict</code>和一个空列表<code>movementsList</code>。读取文件时，每个数据行是一个具有6个元素的列表，其中索引为1的元素就是我们要计数的动作。我们把索引为1的元素加入到<code>movementsList</code>中，然后对其中的元素通过字典来计数。为了以100为精确度，我们进行<code>movementsDict[movement] = movementsDict[movement] // 100 * 100</code>的运算。在写入输出文件的时候，我采用了每个动作分别计数的策略，每写入一行就令计数器+1。当计数器变量超过给定数值的时候，停止写入。  </p>
<hr>
<p><strong>处理三</strong>：将test2中的数据读出，每行只取最后3列，每行数据中的单个元素以空格隔开，写入文件test3。<br><strong>输出test3样例</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-0.72 9.62 0.14982383</span><br><span class="line">-4.02 11.03 3.445948</span><br><span class="line">0.95 14.71 3.636633</span><br></pre></td></tr></table></figure>

<p><strong>我的代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import csv</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">my_columns = [3, 4, 5]</span><br><span class="line">with open(input_file, &apos;r&apos;, newline=&apos;&apos;) as csv_in_file:</span><br><span class="line">    with open(output_file, &apos;w&apos;, newline=&apos;&apos;) as csv_out_file:</span><br><span class="line">        filereader = csv.reader(csv_in_file)</span><br><span class="line">        filewriter = csv.writer(csv_out_file, delimiter=&apos; &apos;)</span><br><span class="line">        for row_list in filereader:</span><br><span class="line">            row_list_output = []</span><br><span class="line">            for index_value in my_columns:</span><br><span class="line">                row_list_output.append(row_list[index_value])</span><br><span class="line">            filewriter.writerow(row_list_output)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;处理三还是比较简单的。输出文件只要求保留最后三列，即列索引值为3, 4, 5的三列。我们创建一个列表变量<code>my_columns = [3, 4, 5]</code>，用来保存要保留的列索引值。输出文件还要求各个数据元素“以空格隔开”，所以我们在创建对象<code>filewriter</code>的时候，需要把<code>writer()</code>函数的<code>delimiter</code>参数设置为<code>delimiter=&#39; &#39;</code>。空列表<code>row_list_output</code>用来保存要输出的数据行。对于满足列索引值为3, 4, 5的数据元素，将其追加到列表<code>row_list_output</code>中，并将其写入输出文件。  </p>
<hr>
<p><strong>处理四</strong>：将test3中的数据读出，每行数据的单个元素用空格隔开，数据行与数据行用逗号隔开，每20个一行写入文件finally中，保证每行不会出现不够或者多出来的情况。<br><strong>输出finally单行样例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-0.72 9.62 0.14982383,-4.02 11.03 3.445948,0.95 14.71 3.636633,-3.57 5.75 -5.407278,-5.28 8.85 -9.615966,-1.14 15.02 -3.8681788,7.86 11.22 -1.879608,6.28 4.9 -2.3018389,0.95 7.06 -3.445948,-1.61 9.7 0.23154591,6.44 12.18 -0.7627395,5.83 12.07 -0.53119355,7.21 12.41 0.3405087,6.17 12.53 -6.701211,-1.08 17.54 -6.701211,-1.69 16.78 3.214402,-2.3 8.12 -3.486809,-2.91 0 -4.7535014,-2.91 0 -4.7535014,-4.44 1.84 -2.8330324</span><br></pre></td></tr></table></figure>

<p><strong>我的代码</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import csv</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line">output_file = sys.argv[2]</span><br><span class="line"></span><br><span class="line">with open(input_file, &apos;r&apos;, newline=&apos;&apos;) as csv_in_file:</span><br><span class="line">    with open(output_file, &apos;w&apos;, newline=&apos;&apos;) as csv_out_file:</span><br><span class="line">        filereader = csv.reader(csv_in_file)</span><br><span class="line">        filewriter = csv.writer(csv_out_file)</span><br><span class="line">        total = []</span><br><span class="line">        for row_list in filereader:</span><br><span class="line">            total.append(row_list[0])</span><br><span class="line">        outputList = []</span><br><span class="line">        a_list = []</span><br><span class="line">        a = 0</span><br><span class="line">        for data in total:</span><br><span class="line">            if a &lt; 19:</span><br><span class="line">                a += 1</span><br><span class="line">                a_list.append(data)</span><br><span class="line">            else:</span><br><span class="line">                a_list.append(data)</span><br><span class="line">                outputList.append(a_list)</span><br><span class="line">                a = 0</span><br><span class="line">                a_list = []</span><br><span class="line">        for output_line in outputList:</span><br><span class="line">            filewriter.writerow(output_line)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;第13行代码创建了空列表<code>total</code>，用来保存所有的数据行。第16-17行则是把数据行添加到<code>total</code>中的过程。第18行创建了空列表<code>outputList</code>，用来把<code>total</code>中的数据每20个一组进行拆分。第19行创建的<code>a_list</code>是辅助拆分列表的列表变量。<code>a</code>则是一个计数器变量。<br>&emsp;&emsp;遍历列表<code>total</code>，当<code>a</code>小于19时，<code>a</code>自加1，然后把<code>data</code>添加到<code>a_list</code>中。当<code>a</code>等于19时，再把<code>data</code>添加到<code>a_list</code>之后，<code>a_list</code>的长度为20，这时就需要把<code>a_list</code>添加到<code>outputList</code>中，然后将<code>a</code>归零，将<code>a_list</code>清空，继续下一轮拆分。拆分完成之后，逐行写入输出文件即可。  </p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/02/13/%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95/">
                自学数据结构与算法——算法
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-02-13</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <p>&emsp;&emsp;我正在学习的这门课程名叫“数据结构与算法”，这样看来，它们二者一定是有着某种关联。事实上，在学习数据结构的过程中，谈到“算法”是为了帮我们更好地理解数据结构。单说数据结构当然可以，在很短的时间内我们就可以学习完几种重要的数据结构。但是这样的话，我们学完后不会有什么感觉，也不知道数据结构有何作用。下面主要讨论一下有关算法的方方面面。  </p>
<h2 id="两种算法的比较"><a href="#两种算法的比较" class="headerlink" title="两种算法的比较"></a>两种算法的比较</h2><p>&emsp;&emsp;在之前，无论是学习C语言也好，学习Python也好，学习Java也好，我们一定写过这样一个程序：1-100求和。这是一个再简单不过的程序，我们也很快能写出这样的代码：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">	int i, sum = 0;</span><br><span class="line">	for (i = 1; i &lt;= 100; i++) &#123;</span><br><span class="line">		sum += i;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d\n&quot;, sum);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个简单的程序就是一种算法。程序本身没有什么需要解释的地方，就是应用了一个<code>for</code>循环来对1-100这些数字进行累加。我相信这也是大多数人拿到这个题目的第一想法。<br>&emsp;&emsp;相信很多人都听说过数学家高斯的一个故事。老师让所有的学生计算1+2+3+…+100的结果，这道题难倒了很多学生，但只有高斯很快地算出了结果。这让老师非常惊讶（可能老师也是通过1+2=3, 3+3=6, 6+4=10…这样的方法来计算的吧）。当被问到怎么样能如此快地计算出结果的时候，高斯解释道：  </p>
<center>∵ sum = 1 + 2 + 3 + ... + 99 + 100</center>
<center>又∵ sum = 100 + 99 + 98 + ... + 2 + 1</center>
<center>∴ 2 × sum = 101 + 101 + 101 + ... + 101 = 100 × 101</center>
<center>∴ sum = 5050</center>

<p>&emsp;&emsp;高斯用的方法相当于求等差数列前n项和的方法，用代码实现如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">	int n = 100, sum = 0;</span><br><span class="line">	sum = (1 + n) * n / 2;</span><br><span class="line">	printf(&quot;%d\n&quot;, sum);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个程序并没有用到循环。试想一下，如果我们要对1至1亿的所有数字进行求和（当然，这里的int要替换为长整型），如果用循环的方法，计算机要进行1亿次的循环累加，而应用高斯求和的方法，计算机运算出结果只是一瞬间的事。这大大节省了计算机运算的时间。  </p>
<h2 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h2><p>&emsp;&emsp;前面说了这么多，我们似乎还是摸不清头脑，什么是算法呢？<br>&emsp;&emsp;现在普遍认可的定义是：<strong>算法</strong>（Algorithm）是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。<br>&emsp;&emsp;在算法的定义中提到了指令。指令能被人或机器等计算装置执行，它可以是计算机指令，也可以是我们平时的语言文字。为了解决某个或某类问题，需要把指令表示成一定的操作序列，操作序列包括一组操作，每一个操作都完成特定的功能，这就是算法。  </p>
<h2 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h2><p>&emsp;&emsp;算法具有5个基本特性：输入，输出，有穷性，确定性，可行性。  </p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>&emsp;&emsp;算法具有零个，一个或多个输入。对于大多数算法来说，输入是必要的，但也有个别算法不需要输入任何参数。  </p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>&emsp;&emsp;算法至少有一个或多个输出，输出的形式可以是打印输出，也可以是返回一个或多个值等。  </p>
<h4 id="有穷性"><a href="#有穷性" class="headerlink" title="有穷性"></a>有穷性</h4><p>&emsp;&emsp;算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。这里的“有穷”并不是纯数学意义的，它更多是指在实际应用当中合理的、可以接受的“有边界”。  </p>
<h4 id="确定性"><a href="#确定性" class="headerlink" title="确定性"></a>确定性</h4><p>&emsp;&emsp;算法的每一步骤都具有确定的含义，不会出现二义性。算法在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果。算法的每个步骤被精确定义而无歧义。  </p>
<h4 id="可行性"><a href="#可行性" class="headerlink" title="可行性"></a>可行性</h4><p>&emsp;&emsp;算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。可行性意味着算法可以转换为程序上机运行，并得到正确的结果。  </p>
<h2 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h2><p>&emsp;&emsp;算法设计有以下几个要求：正确性，可读性，健壮性，时间效率高和存储量低。  </p>
<h4 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h4><p>&emsp;&emsp;一个好的算法，最起码得是正确的。如果连正确都谈不上，再谈别的要求也没有意义。<br>&emsp;&emsp;算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求，能够得到问题的正确答案。“正确”大体分为以下4个层次：<br>&emsp;&emsp;1.算法程序没有语法错误。<br>&emsp;&emsp;2.算法程序对于合法的输入数据能够产生满足要求的输出结果。<br>&emsp;&emsp;3.算法程序对于非法的输入数据能够得出满足规格说明的结果。<br>&emsp;&emsp;4.算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。<br>&emsp;&emsp;一般情况下，我们把层次3作为一个算法是否正确的标准。  </p>
<h4 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h4><p>&emsp;&emsp;算法设计的另一目的是为了便于阅读、理解和交流。可读性高有助于人们理解算法，晦涩难懂的算法往往隐含错误，不易被发现，并且难于调试和修改。<br>&emsp;&emsp;我们写代码的目的，一方面是为了让计算机执行，另一个很重要的方面是为了便于他人阅读，让人理解和交流。自己将来也有可能阅读自己的代码，如果可读性不好的话，时间长了自己都不知道写了些什么。由此可见，可读性是算法（包括实现它的代码）好坏的很重要的标准。  </p>
<h4 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h4><p>&emsp;&emsp;一个好的算法应该能对输入数据不合法的情况做合适的处理。当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名奇妙的结果。  </p>
<h4 id="时间效率高和存储量低"><a href="#时间效率高和存储量低" class="headerlink" title="时间效率高和存储量低"></a>时间效率高和存储量低</h4><p>&emsp;&emsp;好的算法还应该具备时间效率高和存储量低的特点。时间效率指的是算法的执行时间，执行时间短的算法效率高。存储量需求指的是算法在执行过程中需要的最大存储空间，主要指算法程序运行时所占用的内存或外部硬盘存储空间。设计算法应该尽量满足时间效率高和存储量低的需求。</p>
<h2 id="算法效率的度量方法"><a href="#算法效率的度量方法" class="headerlink" title="算法效率的度量方法"></a>算法效率的度量方法</h2><p>&emsp;&emsp;我们如何度量一个算法的执行时间呢？很简单，我们通过对算法的数据测试，利用计算机的计时功能，来计算不同算法的效率是高还是低。  </p>
<h4 id="事后统计方法"><a href="#事后统计方法" class="headerlink" title="事后统计方法"></a>事后统计方法</h4><p>&emsp;&emsp;<strong>事后统计方法</strong>主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。<br>&emsp;&emsp;但是这种方法具有很大的缺陷。如果我们花费了大量的时间和精力，最后编制出算法之后发现它根本就是很糟糕的，就会造成“竹篮打水一场空”的尴尬。<br>&emsp;&emsp;除此之外，算法的测试数据设计困难，而且程序运行时间也跟测试数据的规模大小密切相关。计算机的硬件、软件等环境因素有时也会掩盖算法本身的优劣。<br>&emsp;&emsp;综上所述，我们一般不采纳事后统计方法。  </p>
<h4 id="事前分析估算方法"><a href="#事前分析估算方法" class="headerlink" title="事前分析估算方法"></a>事前分析估算方法</h4><p>&emsp;&emsp;<strong>事前分析估算方法</strong>是指在计算机程序编制前依据统计方法对算法进行估算。一个用高级程序语言编写的程序在计算机上运行时所消耗的时间取决于下列因素：<br>&emsp;&emsp;1.算法采用的策略、方法。<br>&emsp;&emsp;2.编译产生的代码质量。<br>&emsp;&emsp;3.问题的输入规模。<br>&emsp;&emsp;4.机器执行指令的速度。<br>&emsp;&emsp;第1条当然是算法好坏的根本，第2条要由软件来支持，第4条要看硬件性能。抛开这些与计算机硬件、软件有关的因素，一个程序的运行时间，依赖于<strong>算法的好坏</strong>和<strong>问题的输入规模</strong>。所谓问题输入规模，就是指输入量的多少。<br>&emsp;&emsp;我们还是拿1-100求和这个问题举例子。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 算法1：循环求和</span><br><span class="line">int i, sum = 0;                 // 执行1次</span><br><span class="line">for (i = 1; i &lt;= 100; i++) &#123;    // 执行(n+1)次</span><br><span class="line">	sum += i;                   // 执行n次</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;, sum);            // 执行1次</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 算法2：高斯求和</span><br><span class="line">int n = 100, sum = 0;           // 执行1次</span><br><span class="line">sum = (1 + n) * n / 2;          // 执行1次</span><br><span class="line">printf(&quot;%d\n&quot;, sum);            // 执行1次</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;循环求和算法执行了[1+(n+1)+n+1]次=(2n+3)次，而高斯求和算法执行了(1+1+1)次=3次。事实上，两个算法的第一条和最后一条语句是一样的，我们关注的代码其实是中间的部分。我们把循环看作一个整体，忽略头尾循环判断的开销，那么这两个算法其实就是n次与1次的差距。<br>&emsp;&emsp;我们不关心编写程序使用了什么语言，也不关心这些程序将会在什么样的计算机中运行，我们只关心它所实现的算法。在分析程序的运行时间时，最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤。<br><img src="https://img-blog.csdnimg.cn/20200213165851207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;由上图可以明显看出，随着n的不断增大，它们在时间效率上的差异也就越来越大。  </p>
<h2 id="函数的渐进增长"><a href="#函数的渐进增长" class="headerlink" title="函数的渐进增长"></a>函数的渐进增长</h2><p>&emsp;&emsp;给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n&gt;N，f(n)总是比g(n)大，那么，我们说f(n)的增长渐进快于g(n)。也就是说，输入规模n在没有限制的情况下，只要超过一个数值N，这个函数就总是大于另一个函数，我们称函数是渐进增长的。<br>&emsp;&emsp;判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数。某个算法，随着n的增大，它会越来越优于另一算法，或者越来越差于另一算法。  </p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>&emsp;&emsp;在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。<br>&emsp;&emsp;这样用大写O()来体现算法时间复杂度的记法，我们称之为大O记法。<br>&emsp;&emsp;一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法。  </p>
<h4 id="推导大O阶方法"><a href="#推导大O阶方法" class="headerlink" title="推导大O阶方法"></a>推导大O阶方法</h4><p>&emsp;&emsp;1.用常数1取代运行时间中的所有加法常数。<br>&emsp;&emsp;2.在修改后的运行次数函数中，只保留最高阶项。<br>&emsp;&emsp;3.如果最高阶项存在且不是1，则去除与这个项相乘的函数。<br>&emsp;&emsp;经过上述3步运算，得到的结果就是大O阶。  </p>
<h4 id="常数阶"><a href="#常数阶" class="headerlink" title="常数阶"></a>常数阶</h4><p>&emsp;&emsp;我们还是以高斯求和算法为例。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int n = 100, sum = 0;           // 执行1次</span><br><span class="line">sum = (1 + n) * n / 2;          // 执行1次</span><br><span class="line">printf(&quot;%d\n&quot;, sum);            // 执行1次</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个算法的运行次数函数是f(n)=3。根据推导大O阶的方法，第1步，我们把常数项3改为1。它没有最高阶项，所以这个算法的时间复杂度为O(1)。<br>&emsp;&emsp;这种与问题的大小无关（n的多少），执行时间恒定的算法，我们称之为具有O(1)的时间复杂度，又叫常数阶。不管这个常数是多少，我们都记作O(1)，括号里不能是其他任何数字。<br>&emsp;&emsp;对于分支结构而言，无论是真还是假，执行的次数都是恒定的，不会随着n的变大而发生变化，所以单纯的分支结构（不包含在循环结构中），其时间复杂度也是O(1)。  </p>
<h4 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a>线性阶</h4><p>&emsp;&emsp;下面这段代码，它的循环的时间复杂度为O(n)，因为循环体中的代码执行了n次。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i;</span><br><span class="line">for (i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    /* 时间复杂度为O(1)的程序步骤序列 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对数阶"><a href="#对数阶" class="headerlink" title="对数阶"></a>对数阶</h4><p>&emsp;&emsp;我们再来看一段代码：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int count = 1;</span><br><span class="line">while (count &gt; n) &#123;</span><br><span class="line">    count = count * 2;</span><br><span class="line">    /* 时间复杂度为O(1)的程序步骤序列 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;由于每次<code>count</code>乘以2之后，就距离n更近了一分，也就是说，有多少个2相乘后大于n，则会退出循环。由$$2^x=n$$可得$$x=log_2n.$$所以这个循环的时间复杂度为O(logn)。  </p>
<h4 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a>平方阶</h4><p>&emsp;&emsp;下面的例子是一个循环嵌套：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int i, j;</span><br><span class="line">for (i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    for (j = 0; j &lt; n; j++) &#123;</span><br><span class="line">        /* 时间复杂度为O(1)的程序步骤序列 */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;刚才我们分析过，内循环的时间复杂度为O(n)。而对于外层的循环，其实就是内层的时间复杂度为O(n)的语句再循环n次。所以这段代码的时间复杂度为O(n^2^)。<br>&emsp;&emsp;我们对上面的代码稍作修改：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int i, j;</span><br><span class="line">for (i = 0; i &lt; m; i++) &#123;</span><br><span class="line">    for (j = 0; j &lt; n; j++) &#123;</span><br><span class="line">        /* 时间复杂度为O(1)的程序步骤序列 */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这段代码中，外循环的循环次数改为了m，那么时间复杂度就变为O(m×n)。<br>&emsp;&emsp;我们可以总结得出：<strong>循环的时间复杂度=循环体的复杂度×该循环运行的次数</strong>。<br>&emsp;&emsp;我们再来看一个循环嵌套：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int i, j;</span><br><span class="line">for (i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    for (j = i; j &lt; n; j++) &#123;</span><br><span class="line">        /* 时间复杂度为O(1)的程序步骤序列 */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当i=0时，内循环执行了n次；当i=1时，内循环执行了(n-1)次……当i=n-1时，内循环执行了一次。所以有总的执行次数为$$n+(n-1)+(n-2)+…+1=\frac{n(n+1)}{2}=\frac{n^2}{2}+\frac{n}{2}.$$<br>&emsp;&emsp;用推导大O阶的方法，最终这段代码的时间复杂度为O(n^2^)。<br>&emsp;&emsp;接下来我们来看一段相对复杂的代码：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void function(int count) &#123;</span><br><span class="line">    int j;</span><br><span class="line">    for (j = count; j &lt; n; j++) &#123;</span><br><span class="line">        /* 时间复杂度为O(1)的程序步骤序列 */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n++;</span><br><span class="line">function(n);</span><br><span class="line">int i, j;</span><br><span class="line">for (i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    function(i);</span><br><span class="line">&#125;</span><br><span class="line">for (i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    for (j = i; j &lt; n; j++) &#123;</span><br><span class="line">        /* 时间复杂度为O(1)的程序步骤序列 */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;函数<code>function()</code>的时间复杂度为O(n)。为了方便，我们把代码的下半部分单独拿出来，注释上每条语句的执行次数。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n++;                              // 执行次数为1</span><br><span class="line">function(n);                      // 执行次数为n</span><br><span class="line">int i, j;</span><br><span class="line">for (i = 0; i &lt; n; i++) &#123;         // 执行次数为n×n</span><br><span class="line">    function(i);</span><br><span class="line">&#125;</span><br><span class="line">for (i = 0; i &lt; n; i++) &#123;         // 执行次数为n(n+1)/2</span><br><span class="line">    for (j = i; j &lt; n; j++) &#123;</span><br><span class="line">        /* 时间复杂度为O(1)的程序步骤序列 */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;由上面的分析可得$$f(n)=1+n+n^2+\frac{n(n+1)}{2}=\frac{3}{2}n^2+\frac{3}{2}n+1.$$根据推导大O阶的方法，最终这段代码的时间复杂度也是O(n^2^)。  </p>
<h2 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h2><p>&emsp;&emsp;常见的时间复杂度如下表所示。<br>执行次数函数|阶|非正式术语<br>——|——|——<br>12|O(1)|常数阶<br>2n+3|O(n)|线性阶<br>3n^2^+2n+1|O(n^2^)|平方阶<br>5log<del>2</del>n+20|O(logn)|对数阶<br>2n+3nlog<del>2</del>n+19|O(nlogn)|nlogn阶<br>6n^3^+2n^2^+3n+4|O(n^3^)|立方阶<br>2^n^|O(2^n^)|指数阶</p>
<p>&emsp;&emsp;常用的时间复杂度所耗费的时间从小到大依次是：O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2^)&lt;O(n^3^)&lt;O(2^n^)&lt;O(n!)&lt;O(n^n^)。<br>&emsp;&emsp;O(n^3^)之后的时间复杂度，过大的n都会使结果变得不现实。尤其是指数阶和阶乘阶等，除非n很小，否则就是噩梦般的运行时间。这种时间复杂度是不切实际的，我们一般不去讨论它。  </p>
<h2 id="最坏情况与平均情况"><a href="#最坏情况与平均情况" class="headerlink" title="最坏情况与平均情况"></a>最坏情况与平均情况</h2><p>&emsp;&emsp;比如说我们查找一个有n个随机数字数组中的某个数字，最好的情况是第一个数字就是我们要找的数字，那么算法的时间复杂度为O(1)。最坏的情况就是我们要找的数字在数组的最后一个位置上，那么算法的时间复杂度就是O(n)。这就像我们在日常生活中找东西，运气好的话我们可以一下找到，不会花费太长时间；运气不好的话，我们怎么也找不到，花费的时间也是相当长。<br>&emsp;&emsp;最坏情况运行时间是一种保证，那就是运行时间将不会再长了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。<br>&emsp;&emsp;平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。从概率的角度看，这个数字在每一个位置的可能性是相同的，所以平均的查找时间为n/2次后发现这个目标元素。<br>&emsp;&emsp;一般在没有特殊说明的情况下，时间复杂度指最坏时间复杂度。  </p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>&emsp;&emsp;算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作S(n)=O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。<br>&emsp;&emsp;我们在写代码时，可以用空间来换取时间。<br>&emsp;&emsp;一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为O(1)。  </p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/02/12/%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%BB%AA%E8%AE%BA/">
                自学数据结构与算法——绪论
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-02-12</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <blockquote>
<p>参考资料：《大话数据结构》，作者程杰，清华大学出版社  </p>
</blockquote>
<h2 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h2><p>&emsp;&emsp;数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。这里不得不提一个著名的公式：<strong>程序设计=数据结构+算法</strong>。<br>&emsp;&emsp;在说数据结构之前，我们应该先要了解什么是数据。<strong>数据</strong>是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据包括整型、实型等<strong>数值类型</strong>，也包括字符、声音、图像、视频等<strong>非数值类型</strong>。也就是说，这里所说的数据其实就是符号，他们具备两个前提：<strong>可以输入到计算机中</strong>，<strong>能被计算机程序处理</strong>。<br>&emsp;&emsp;<strong>数据元素</strong>是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为<strong>记录</strong>。一个数据元素可以由若干个<strong>数据项</strong>组成。举个简单的例子，在人类中，人就是数据元素，而人的眼睛、耳朵、鼻子、手、脚等就是数据项，人的姓名、性别、年龄、联系方式等也可以是数据项。具体有哪些数据项，要视系统而决定。<strong>数据项是数据不可分割的最小单位</strong>。<br>&emsp;&emsp;<strong>数据对象</strong>是性质相同的数据元素的集合，是数据的子集。<br><img src="https://img-blog.csdnimg.cn/20200212213008839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;以上说的这么多都属于数据的范畴，接下来我们来说一下什么是结构。<br>&emsp;&emsp;简单来说，结构就是关系。而严格来说，<strong>结构</strong>是指各个组成部分相互搭配和排列的方式。不同数据元素之间不是独立的，而是存在特定的关系。<br>&emsp;&emsp;说了这么多，<strong>数据结构</strong>就是相互之间存在一种或多种特定关系的数据元素的集合。在计算机中，数据元素并不是孤立、杂乱无序的，而是具有内在联系的数据集合。数据元素之间存在的一种或多种特定关系，也就是数据的组织形式。  </p>
<h2 id="逻辑结构和物理结构"><a href="#逻辑结构和物理结构" class="headerlink" title="逻辑结构和物理结构"></a>逻辑结构和物理结构</h2><p>&emsp;&emsp;数据结构分为<strong>逻辑结构</strong>和<strong>物理结构</strong>。<br><img src="https://img-blog.csdnimg.cn/20200212210205553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;逻辑结构是指数据对象中数据元素之间的相互关系，分为以下四种：<br>&emsp;&emsp;1.集合结构：集合结构中的数据元素除了<strong>同属于一个集合</strong>外，它们之间<strong>没有其它关系</strong>。它类似于数学中的集合。如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200212210631112.png" alt="在这里插入图片描述"><br>&emsp;&emsp;2.线性结构：线性结构中的数据元素之间是<strong>一对一</strong>的关系。如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200212210603680.png" alt="在这里插入图片描述"><br>&emsp;&emsp;3.树形结构：树型结构中的数据元素之间存在一种<strong>一对多</strong>的层次关系。如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200212210744649.png" alt="在这里插入图片描述"><br>&emsp;&emsp;4.图形结构：图形结构的数据元素是<strong>多对多</strong>的关系。如下图所示。<br><img src="https://img-blog.csdnimg.cn/2020021221085452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;说完了逻辑结构，我们再来说一说物理结构（也叫存储结构）。物理结构是指数据的逻辑结构在计算机中的存储形式。它分为以下两种结构：<br>&emsp;&emsp;1.顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。数组就是这样的顺序存储结构。顺序存储结构如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200212211255349.png" alt="在这里插入图片描述"><br>&emsp;&emsp;2.链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，通过地址就可以找到相关联数据元素的位置。链式存储结构如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200212211541182.png" alt="在这里插入图片描述"></p>
<h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><p>&emsp;&emsp;<strong>数据类型</strong>是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。数据类型按照值的不同进行划分。在高级语言中，每个变量、常量和表达式都有各自的取值范围。类型用来说明变量或表达式的取值范围和所能进行的操作。<br>&emsp;&emsp;在C语言中，按照取值的不同，数据类型可以分为两类。一类是<strong>原子类型</strong>，它是<strong>不可以再分解</strong>的基本类型，包括整型、实型、字符型等。另一类是<strong>结构类型</strong>，它由若干个类型组合而成，是<strong>可以再分解</strong>的，比如整型数组就是由若干个整型数据组成的。<br>&emsp;&emsp;<strong>抽象数据类型</strong>（Abstract Data Type, ADT）是指一个数学模型及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。“抽象”的意义在于数据类型的数学抽象特性。事实上，抽象数据类型<strong>体现了程序设计中问题分解、抽象和信息隐藏的特性</strong>。<br>&emsp;&emsp;下面给出了描述抽象数据类型的标准格式。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ADT 抽象数据类型名</span><br><span class="line">Data</span><br><span class="line">    数据元素之间逻辑关系的定义</span><br><span class="line">Operation</span><br><span class="line">    操作1</span><br><span class="line">        初始条件</span><br><span class="line">        操作结果描述</span><br><span class="line">    操作2</span><br><span class="line">        ……</span><br><span class="line">    操作n</span><br><span class="line">        ……</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/02/11/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93(3)/">
                Python数据分析基础之数据库(3)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-02-11</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="查询一个表并将输出写入CSV文件"><a href="#查询一个表并将输出写入CSV文件" class="headerlink" title="查询一个表并将输出写入CSV文件"></a>查询一个表并将输出写入CSV文件</h2><p>&emsp;&emsp;数据表中有了数据之后，最常见的下一个步骤就是使用查询从表中取出一组数据进行分析。使用Python脚本可以从数据表中查询出一组特定记录。<br>&emsp;&emsp;下面的代码会从<code>Suppliers</code>数据表中查询出<code>Cost</code>列中的值大于700.00的所有记录，并将这些记录所有列中的值输出。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import csv</span><br><span class="line">import MySQLdb</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"># CSV输出文件的路径和文件名</span><br><span class="line">output_file = sys.argv[1]</span><br><span class="line"></span><br><span class="line"># 连接MySQL数据库</span><br><span class="line">con = MySQLdb.connect(host=&apos;localhost&apos;, port=3306, db=&apos;my_suppliers&apos;, user=&apos;root&apos;, passwd=&apos;## your password ##&apos;)</span><br><span class="line">c = con.cursor()</span><br><span class="line"></span><br><span class="line"># 创建写文件的对象，并写入标题行</span><br><span class="line">filewriter = csv.writer(open(output_file, &apos;w&apos;, newline=&apos;&apos;), delimiter=&apos;,&apos;)</span><br><span class="line">header = [&apos;Supplier Name&apos;, &apos;Invoice Number&apos;, &apos;Part Number&apos;, &apos;Cost&apos;, &apos;Purchase Date&apos;]</span><br><span class="line">filewriter.writerow(header)</span><br><span class="line"></span><br><span class="line"># 查询Suppliers表，并将结果写入CSV输出文件</span><br><span class="line">c.execute(&quot;&quot;&quot;SELECT *</span><br><span class="line">             FROM Suppliers</span><br><span class="line">             WHERE Cost &gt; 700.0;&quot;&quot;&quot;)</span><br><span class="line">rows = c.fetchall()</span><br><span class="line">for row in rows:</span><br><span class="line">    filewriter.writerow(row)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在命令行窗口中运行这个脚本，得到CSV输出文件。<br><img src="https://img-blog.csdnimg.cn/20200211181715793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="更新表中记录"><a href="#更新表中记录" class="headerlink" title="更新表中记录"></a>更新表中记录</h2><p>&emsp;&emsp;更新表中记录的方法与之前的插入新记录的方法类似，只是SQL语句有所变化，将<code>INSERT</code>语句变为了<code>UPDATE</code>语句。代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import csv</span><br><span class="line">import MySQLdb</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"># CSV输入文件的路径和文件名</span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line"></span><br><span class="line"># 连接MySQL数据库</span><br><span class="line">con = MySQLdb.connect(host=&apos;localhost&apos;, port=3306, db=&apos;my_suppliers&apos;, user=&apos;root&apos;, passwd=&apos;## your password ##&apos;)</span><br><span class="line">c = con.cursor()</span><br><span class="line"></span><br><span class="line"># 读取CSV文件并更新特定的行</span><br><span class="line">file_reader = csv.reader(open(input_file, &apos;r&apos;, newline=&apos;&apos;), delimiter=&apos;,&apos;)</span><br><span class="line">header = next(file_reader, None)</span><br><span class="line">for row in file_reader:</span><br><span class="line">    data = []</span><br><span class="line">    for column_index in range(len(header)):</span><br><span class="line">        data.append(str(row[column_index]).strip())</span><br><span class="line">    print(data)</span><br><span class="line">    c.execute(&quot;&quot;&quot;UPDATE Suppliers SET Cost=%s, Purchase_Date=%s WHERE Supplier_Name=%s;&quot;&quot;&quot;, data)</span><br><span class="line">con.commit()</span><br><span class="line"></span><br><span class="line"># 查询Suppliers表</span><br><span class="line">c.execute(&quot;SELECT * FROM Suppliers&quot;)</span><br><span class="line">rows = c.fetchall()</span><br><span class="line">for row in rows:</span><br><span class="line">    output = []</span><br><span class="line">    for column_index in range(len(row)):</span><br><span class="line">        output.append(str(row[column_index]))</span><br><span class="line">    print(output)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在<code>UPDATE</code>语句中，必须指定想要更新哪一条记录和哪一个列属性。在这里，我们想为一组特定的Supplier Names更新Cost值和Purchase Date值。<code>UPDATE</code>语句中需要几个值，就需要几个<code>%s</code>占位符表示出查询中的值的位置，CSV输入文件中数据的顺序也要同查询中属性的顺序一样。<br>&emsp;&emsp;现在我们新建一个CSV输入文件：<br><img src="https://img-blog.csdnimg.cn/20200211204909672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;在命令行窗口中运行这个脚本，得到输出结果如下：<br><img src="https://img-blog.csdnimg.cn/20200211205045296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;输出结果的前两行展示了来自于CSV输入文件中除标题行之外的两行数据。在这两行下面，输出展示了执行更新之后从数据表中取出的12行数据，每行数据占一行。<br>&emsp;&emsp;下面我们来确认一下MySQL数据表中与Supplier X和Supplier Y相关的8行数据是否已被更新。打开MySQL命令行客户端，输入命令<code>SELECT * FROM Suppliers</code>，然后按Enter键。<br><img src="https://img-blog.csdnimg.cn/2020021120553321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;下面的表格是更新后的数据表。这里我截取了本次和上一次的数据表，为的是有一个明显的对比。我们看到，Supplier X和Supplier Y相关的8行记录已经被更新为CSV输入文件中提供的数据。  </p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2020/02/11/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93(2)/">
                Python数据分析基础之数据库(2)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-02-11</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <p>&emsp;&emsp;上一篇博客主要讲了使用Python的内置模块sqlite3来创建内存数据库，这篇博客以及之后的博客主要讲MySQL数据库。  </p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>&emsp;&emsp;我们需要安装Python的MySQLdb扩展包，在Python 2中是MySQL-python，在Python 3中是mysqlclient。我使用的是Anaconda，这个扩展包随着安装Anaconda的时候就捆绑安装好了。<br>&emsp;&emsp;我们还需要安装MySQL。msi版安装教程可以参考我之前写的博客：<a href="https://blog.csdn.net/qq_45554010/article/details/104254892" target="_blank" rel="noopener">《MySQL Community 8.0.19.0 msi版安装教程》</a>，zip版安装教程请自行查阅。  </p>
<h2 id="在MySQL中创建新数据库"><a href="#在MySQL中创建新数据库" class="headerlink" title="在MySQL中创建新数据库"></a>在MySQL中创建新数据库</h2><p>&emsp;&emsp;打开MySQL 8.0 Command Line Client，输入root密码，进入MySQL。<br><img src="https://img-blog.csdnimg.cn/20200211113356992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;输入命令<code>SHOW DATABASES;</code>，然后按Enter键，我们可以看到，在MySQL数据库系统中已经有了4个数据库。这些数据库使MySQL数据库系统能够运行，并包含系统用户的权限信息。注意：在输入命令<code>SHOW DATABASES;</code>的时候，<strong>必须要输入分号</strong>。<br><img src="https://img-blog.csdnimg.cn/20200211113838267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;接下来我们来创建自己的数据库。输入命令<code>CREATE DATABASE my_suppliers;</code>，然后按Enter键。我们可以再运行一次<code>SHOW DATABASE;</code>命令，这时我们可以看到我们刚刚创建的<code>my_suppliers</code>数据库。<br><img src="https://img-blog.csdnimg.cn/20200211114219439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;要使用<code>my_suppliers</code>数据库，必须先选择它。输入命令<code>USE my_suppliers;</code>，然后按Enter键。这样我们就已经选择了<code>my_suppliers</code>数据库。<br><img src="https://img-blog.csdnimg.cn/20200211114436643.png" alt="在这里插入图片描述"></p>
<p>&emsp;&emsp;接下来我们创建一个数据表<code>Suppliers</code>。输入以下命令，然后按Enter键：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS Suppliers</span><br><span class="line">(Supplier_Name VARCHAR(20),</span><br><span class="line">Invoice_Number VARCHAR(20),</span><br><span class="line">Part_Number VARCHAR(20),</span><br><span class="line">Cost FLOAT,</span><br><span class="line">Purchase_Date DATE);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200211114912180.png" alt="在这里插入图片描述"></p>
<p>&emsp;&emsp;我们来解释一下上面的命令。<br>&emsp;&emsp;如果数据库中不存在数据表<code>Suppliers</code>，这个命令就创建数据表<code>Suppliers</code>。这个表有5个列。其中，前3个列是可变字符<code>VARCHAR</code>型字段。<code>20</code>表示为这个字段中的数据分配20个字符。如果输入这个字段的数据大于20个字符，那么数据将被截断。如果数据少于20个字符，那么这个字段就为数据分配一个更小的空间。<br>&emsp;&emsp;第4列是一个浮点数<code>FLOAT</code>字段。浮点数字段保存浮点数近似值。在本例中，第4列包含的是货币值，所以可以用<code>NUMERIC</code>定点确定值类型字段替代<code>FLOAT</code>类型字段。不使用<code>FLOAT</code>，也可以使用<code>NUMERIC(11, 2)</code>。其中<code>11</code>是数值的精度，也就是为数值保存的数位总数（包括小数点后面的位数）。<code>2</code>是小数位数，即小数点后面的数位总数。<br>&emsp;&emsp;第5列是一个日期<code>DATE</code>字段。<code>DATE</code>字段用来保存日期，形式为<code>YYYY-MM-DD</code>，没有时间部分。<br>&emsp;&emsp;为了确保数据表创建正确，输入命令<code>DESCRIBE Suppliers;</code>，然后按Enter键。<br><img src="https://img-blog.csdnimg.cn/20200211120009829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;我们看到了一个表格，其中列出了创建的列的名称，每列的数据类型以及列中的值是否可以为<code>NULL</code>。<br>&emsp;&emsp;接下来我们创建一个新用户。输入命令<code>CREATE USER &#39;username&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;secret_password&#39;;</code>（请注意用要使用的用户名替换<code>username</code>，用自己的密码替换<code>secret_password</code>），然后按Enter键。<br>&emsp;&emsp;输入以下两条命令，然后在每条命令后面按Enter键，来向新用户授于所有权限。同样地，用要使用的用户名替换下面的<code>username</code>。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON my_suppliers.* TO &apos;username&apos;@&apos;localhost&apos;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这样我们就可以同本地主机中的<code>my_suppliers</code>数据库中的<code>Suppliers</code>表进行交互了。<br><img src="https://img-blog.csdnimg.cn/20200211162149574.png" alt="在这里插入图片描述"></p>
<h2 id="向表中插入新记录"><a href="#向表中插入新记录" class="headerlink" title="向表中插入新记录"></a>向表中插入新记录</h2><p>&emsp;&emsp;下面的Python脚本会将数据从CSV文件中插入到我们的数据表，然后展示表中的数据。我们还是以supplier_data.csv为例。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import csv</span><br><span class="line">import MySQLdb</span><br><span class="line">import sys</span><br><span class="line">from datetime import datetime, date</span><br><span class="line"></span><br><span class="line"># CSV输入文件的路径和文件名</span><br><span class="line">input_file = sys.argv[1]</span><br><span class="line"></span><br><span class="line"># 连接MySQL数据库</span><br><span class="line">con = MySQLdb.connect(host=&apos;localhost&apos;, port=3306, db=&apos;my_suppliers&apos;, user=&apos;root&apos;, passwd=&apos;## your password ##&apos;)</span><br><span class="line">c = con.cursor()</span><br><span class="line"></span><br><span class="line"># 向Suppliers表中插入数据</span><br><span class="line">file_reader = csv.reader(open(input_file, &apos;r&apos;, newline=&apos;&apos;))</span><br><span class="line">header = next(file_reader)</span><br><span class="line">for row in file_reader:</span><br><span class="line">    data = []</span><br><span class="line">    for column_index in range(len(header)):</span><br><span class="line">        if column_index &lt; 4:</span><br><span class="line">            data.append(str(row[column_index]).lstrip(&apos;$&apos;).replace(&apos;,&apos;, &apos;&apos;).strip())</span><br><span class="line">        else:</span><br><span class="line">            a_date = datetime.date(datetime.strptime(str(row[column_index]), &apos;%m/%d/%Y&apos;))</span><br><span class="line">            a_date = a_date.strftime(&apos;%Y-%m-%d&apos;)</span><br><span class="line">            data.append(a_date)</span><br><span class="line">    print(data)</span><br><span class="line">    c.execute(&quot;&quot;&quot;INSERT INTO Suppliers VALUES (%s, %s, %s, %s, %s);&quot;&quot;&quot;, data)</span><br><span class="line">con.commit()</span><br><span class="line">print(&quot;&quot;)</span><br><span class="line"></span><br><span class="line"># 查询Suppliers表</span><br><span class="line">c.execute(&quot;SELECT * FROM Suppliers&quot;)</span><br><span class="line">rows = c.fetchall()</span><br><span class="line">for row in rows:</span><br><span class="line">    row_list_output = []</span><br><span class="line">    for column_index in range(len(row)):</span><br><span class="line">        row_list_output.append(str(row[column_index]))</span><br><span class="line">    print(row_list_output)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;第12行代码使用MySQLdb模块的<code>connect()</code>方法连接<code>my_suppliers</code>，即前面我们创建的MySQL数据库。在连接时，我们需要指定一些通用参数。<code>host</code>是数据库所在的机器的主机名，在这里，MySQL服务器保存在我们的计算机上，所以<code>host</code>是<code>localhost</code>。<code>port</code>是MySQL服务器的TCP/IP连接端口号，这里我们使用的端口号是默认的端口号3306。<code>db</code>是想要连接的数据库名称。<code>user</code>是进行数据库连接的用户的用户名，<code>passwd</code>即为密码。在这里我们作为“root”用户进行连接，使用的密码就是在安装MySQL服务器时创建的密码。我们此前新建了一个新用户，如果想使用新用户，我们只需要把用户名和密码相应地替换掉即可。<br>&emsp;&emsp;我们在命令行窗口中运行这个脚本，得到输出结果。<br><img src="https://img-blog.csdnimg.cn/20200211162509331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&emsp;&emsp;这个输出结果证明了数据被成功地加载到了<code>Suppliers</code>表中，并被成功读出。<br>&emsp;&emsp;我们打开MySQL命令行客户端，输入命令<code>SELECT * FROM Suppliers;</code>，可以看到一个表格，其中列出了<code>Suppliers</code>数据表中所有的列以及每列中的12行数据。<br><img src="https://img-blog.csdnimg.cn/20200211162818607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTU0MDEw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

        </div>
    

</div>
            
        </section>
    </div>
</div>



    <div class="row">
        <div class="col-sm-12">
            <div class="wrap-pagination">
                <a class="disabled" href="/">
                    <i class="fa fa-chevron-left" aria-hidden="true"></i>
                </a>
                <a class="" href="/page/2/">
                    <i class="fa fa-chevron-right" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>




</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    I'd walk a million miles just to see your smile. 
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2020/02/28/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8F%8F%E8%BF%B0%E6%80%A7%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%BB%BA%E6%A8%A1(1)/">Python数据分析基础之描述性统计与建模(1)</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/02/20/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9B%BE%E4%B8%8E%E5%9B%BE%E8%A1%A8%EF%BC%88ggplot%E7%95%AA%E5%A4%96%E7%AF%87%EF%BC%89/">Python数据分析基础之图与图表（ggplot番</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/02/19/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9B%BE%E4%B8%8E%E5%9B%BE%E8%A1%A8(2)/">Python数据分析基础之图与图表(2)</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2020/02/19/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9B%BE%E4%B8%8E%E5%9B%BE%E8%A1%A8(1)/">Python数据分析基础之图与图表(1)</a>
            </li>
            
        </ul>
    </div>



            
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/CCH21" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:1398635912@qq.com" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a href="http://www.codeblocq.com/" target="_blank" rel="noopener">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



</body>

</html>